#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>

#include "GLFW/glfw3.h"

namespace py = pybind11;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!
struct BoxedDouble
{
    double value;
    BoxedDouble(double v = 0.) : value(v) {}
    std::string __repr__() const { return std::string("BoxedDouble(") + std::to_string(value) + ")"; }
};
struct BoxedFloat
{
    float value;
    BoxedFloat(float v = 0.) : value(v) {}
    std::string __repr__() const { return std::string("BoxedFloat(") + std::to_string(value) + ")"; }
};
struct BoxedInt
{
    int value;
    BoxedInt(int v = 0) : value(v) {}
    std::string __repr__() const { return std::string("BoxedInt(") + std::to_string(value) + ")"; }
};

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Atrocious wrappers around GLFW opaque types: GLFWmonitor, GLFWwindow and GLFWcursor
// They are used as pointer in the GLFW API, however, pybind11 stubornly refuses to publish
// a pointer to an incompletely defined type.
//
// Part 1: wrapper structs
//
// Here, we use a dirty trick which is that
//     struct FooWrapper { Foo _; }
// has exactly the same memory layout as Foo...
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "glfw/src/internal.h"
struct GLFWmonitor { _GLFWmonitor _;};
struct GLFWwindow { _GLFWwindow _; };
struct GLFWcursor { _GLFWcursor _; };


void py_init_module_glfw(py::module& m)
{
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Atrocious wrappers around GLFW opaque types: GLFWmonitor, GLFWwindow and GLFWcursor
    // Part 2: publish bindings
    py::class_<GLFWmonitor>(m, "GLFWmonitor")
        .def("address", [](const GLFWmonitor& _) { return (size_t)(&_); })
        .def("null", []() { return (GLFWmonitor *)(nullptr); });

    py::class_<GLFWwindow>(m, "GLFWwindow")
        .def("address", [](const GLFWwindow& _) { return (size_t)(&_); })
        .def("null", []() { return (GLFWwindow *)(nullptr); });

    py::class_<GLFWcursor>(m, "GLFWcursor")
        .def("address", [](const GLFWcursor& _) { return (size_t)(&_); })
        .def("null", []() { return (GLFWcursor *)(nullptr); });
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Atrocious wrappers around callbacks which are C-style function pointers
    // Black magic to bind function using c-style function pointers
    // see https://stackoverflow.com/questions/74480093/pybind11-pass-c-style-function-pointer-as-a-parameter/74481325#74481325

#define ADD_FN_POINTER_CALLBACK_ONE_PARAM(functionNameCpp, function_name_python, CallbackType, Type1) \
    m.def(function_name_python, [](std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp([](Type1 v1) { \
            callback(v1); \
        });\
    });

#define ADD_FN_POINTER_CALLBACK_TWO_PARAMS(functionNameCpp, function_name_python, CallbackType, Type1, Type2) \
    m.def(function_name_python, [](std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp([](Type1 v1, Type2 v2) { \
            callback(v1, v2); \
        });\
    });


#define ADD_FN_POINTER_CALLBACK_WINDOW_0_PARAMS(functionNameCpp, function_name_python, CallbackType) \
    m.def(function_name_python, [](GLFWwindow *window, std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp(window, []() { \
            callback(); \
        });\
    });
#define ADD_FN_POINTER_CALLBACK_WINDOW_1_PARAMS(functionNameCpp, function_name_python, CallbackType, Type1) \
    m.def(function_name_python, [](GLFWwindow *window, std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp(window, [](Type1 v1) { \
            callback(v1); \
        });\
    });
#define ADD_FN_POINTER_CALLBACK_WINDOW_2_PARAMS(functionNameCpp, function_name_python, CallbackType, Type1, Type2) \
    m.def(function_name_python, [](GLFWwindow *window, std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp(window, [](Type1 v1, Type2 v2) { \
            callback(v1, v2); \
        });\
    });
#define ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(functionNameCpp, function_name_python, CallbackType, Type1, Type2, Type3) \
    m.def(function_name_python, [](GLFWwindow *window, std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp(window, [](Type1 v1, Type2 v2, Type3 v3) { \
            callback(v1, v2, v3); \
        });\
    });
#define ADD_FN_POINTER_CALLBACK_WINDOW_4_PARAMS(functionNameCpp, function_name_python, CallbackType, Type1, Type2, Type3, Type4) \
    m.def(function_name_python, [](GLFWwindow *window, std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp(window, [](Type1 v1, Type2 v2, Type3 v3, Type4 v4) { \
            callback(v1, v2, v3, v4); \
        });\
    });
#define ADD_FN_POINTER_CALLBACK_WINDOW_5_PARAMS(functionNameCpp, function_name_python, CallbackType, Type1, Type2, Type3, Type4, Type5) \
    m.def(function_name_python, [](GLFWwindow *window, std::function<std::remove_pointer_t<CallbackType>> f) { \
        static std::function<std::remove_pointer_t<CallbackType>> callback; \
        callback = std::move(f); \
        functionNameCpp(window, [](Type1 v1, Type2 v2, Type3 v3, Type4 v4, Type5 v5) { \
            callback(v1, v2, v3, v4, v5); \
        });\
    });


    ADD_FN_POINTER_CALLBACK_TWO_PARAMS(glfwSetErrorCallback, "set_error_callback", GLFWerrorfun, int, const char*);
    ADD_FN_POINTER_CALLBACK_TWO_PARAMS(glfwSetMonitorCallback, "set_monitor_callback", GLFWmonitorfun, GLFWmonitor*, int);

    ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetWindowPosCallback, "set_window_pos_callback", GLFWwindowposfun, GLFWwindow*, int, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetWindowSizeCallback, "set_window_size_callback", GLFWwindowposfun, GLFWwindow*, int, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_1_PARAMS(glfwSetWindowCloseCallback, "set_window_close_callback",GLFWwindowclosefun, GLFWwindow*);
    ADD_FN_POINTER_CALLBACK_WINDOW_1_PARAMS(glfwSetWindowRefreshCallback, "set_window_refresh_callback", GLFWwindowrefreshfun, GLFWwindow*);
    ADD_FN_POINTER_CALLBACK_WINDOW_2_PARAMS(glfwSetWindowFocusCallback, "set_window_focus_callback", GLFWwindowfocusfun, GLFWwindow*, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_2_PARAMS(glfwSetWindowIconifyCallback, "set_window_iconify_callback", GLFWwindowiconifyfun, GLFWwindow*, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_2_PARAMS(glfwSetWindowMaximizeCallback,"set_window_maximize_callback", GLFWwindowmaximizefun, GLFWwindow*, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetFramebufferSizeCallback, "set_framebuffer_size_callback", GLFWframebuffersizefun, GLFWwindow*, int, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetWindowContentScaleCallback, "set_window_content_size_callback", GLFWwindowcontentscalefun, GLFWwindow*, float, float);
    ADD_FN_POINTER_CALLBACK_WINDOW_5_PARAMS(glfwSetKeyCallback, "set_key_callback", GLFWkeyfun, GLFWwindow*, int, int, int, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_2_PARAMS(glfwSetCharCallback, "set_char_callback", GLFWcharfun, GLFWwindow*, unsigned int);
    ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetCharModsCallback, "set_char_mods_callback", GLFWcharmodsfun, GLFWwindow*, unsigned int, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_4_PARAMS(glfwSetMouseButtonCallback, "set_mouse_button_callback", GLFWmousebuttonfun, GLFWwindow*, int, int, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetCursorPosCallback, "set_mouse_cursor_callback", GLFWcursorposfun, GLFWwindow*, double, double);
    ADD_FN_POINTER_CALLBACK_WINDOW_2_PARAMS(glfwSetCursorEnterCallback, "set_cursor_enter_callback", GLFWcursorenterfun, GLFWwindow*, int);
    ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetScrollCallback, "set_scroll_callback", GLFWscrollfun, GLFWwindow*, double, double);
    // ADD_FN_POINTER_CALLBACK_WINDOW_3_PARAMS(glfwSetDropCallback, "set_drop_callback", GLFWdropfun, GLFWwindow*, int path_count, const char**);
    ADD_FN_POINTER_CALLBACK_TWO_PARAMS(glfwSetJoystickCallback, "set_joystick_callback", GLFWjoystickfun, int, int);

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:BoxedTypes>    ////////////////////
    auto pyClassBoxedDouble =
        py::class_<BoxedDouble>
            (m, "BoxedDouble", "")
        .def_readwrite("value", &BoxedDouble::value, "")
        .def(py::init<double>(),
            py::arg("v") = 0.)
        .def("__repr__",
            &BoxedDouble::__repr__)
        ;


    auto pyClassBoxedFloat =
        py::class_<BoxedFloat>
            (m, "BoxedFloat", "")
        .def_readwrite("value", &BoxedFloat::value, "")
        .def(py::init<float>(),
            py::arg("v") = 0.)
        .def("__repr__",
            &BoxedFloat::__repr__)
        ;


    auto pyClassBoxedInt =
        py::class_<BoxedInt>
            (m, "BoxedInt", "")
        .def_readwrite("value", &BoxedInt::value, "")
        .def(py::init<int>(),
            py::arg("v") = 0)
        .def("__repr__",
            &BoxedInt::__repr__)
        ;
    ////////////////////    </generated_from:BoxedTypes>    ////////////////////


    ////////////////////    <generated_from:glfw3.h>    ////////////////////
    m.attr("VERSION_MAJOR") = 3;
    m.attr("VERSION_MINOR") = 4;
    m.attr("VERSION_REVISION") = 0;
    m.attr("TRUE") = 1;
    m.attr("FALSE") = 0;
    m.attr("RELEASE") = 0;
    m.attr("PRESS") = 1;
    m.attr("REPEAT") = 2;
    m.attr("HAT_CENTERED") = 0;
    m.attr("HAT_UP") = 1;
    m.attr("HAT_RIGHT") = 2;
    m.attr("HAT_DOWN") = 4;
    m.attr("HAT_LEFT") = 8;
    m.attr("KEY_UNKNOWN") = -1;
    m.attr("KEY_SPACE") = 32;
    m.attr("KEY_APOSTROPHE") = 39;
    m.attr("KEY_COMMA") = 44;
    m.attr("KEY_MINUS") = 45;
    m.attr("KEY_PERIOD") = 46;
    m.attr("KEY_SLASH") = 47;
    m.attr("KEY_0") = 48;
    m.attr("KEY_1") = 49;
    m.attr("KEY_2") = 50;
    m.attr("KEY_3") = 51;
    m.attr("KEY_4") = 52;
    m.attr("KEY_5") = 53;
    m.attr("KEY_6") = 54;
    m.attr("KEY_7") = 55;
    m.attr("KEY_8") = 56;
    m.attr("KEY_9") = 57;
    m.attr("KEY_SEMICOLON") = 59;
    m.attr("KEY_EQUAL") = 61;
    m.attr("KEY_A") = 65;
    m.attr("KEY_B") = 66;
    m.attr("KEY_C") = 67;
    m.attr("KEY_D") = 68;
    m.attr("KEY_E") = 69;
    m.attr("KEY_F") = 70;
    m.attr("KEY_G") = 71;
    m.attr("KEY_H") = 72;
    m.attr("KEY_I") = 73;
    m.attr("KEY_J") = 74;
    m.attr("KEY_K") = 75;
    m.attr("KEY_L") = 76;
    m.attr("KEY_M") = 77;
    m.attr("KEY_N") = 78;
    m.attr("KEY_O") = 79;
    m.attr("KEY_P") = 80;
    m.attr("KEY_Q") = 81;
    m.attr("KEY_R") = 82;
    m.attr("KEY_S") = 83;
    m.attr("KEY_T") = 84;
    m.attr("KEY_U") = 85;
    m.attr("KEY_V") = 86;
    m.attr("KEY_W") = 87;
    m.attr("KEY_X") = 88;
    m.attr("KEY_Y") = 89;
    m.attr("KEY_Z") = 90;
    m.attr("KEY_LEFT_BRACKET") = 91;
    m.attr("KEY_BACKSLASH") = 92;
    m.attr("KEY_RIGHT_BRACKET") = 93;
    m.attr("KEY_GRAVE_ACCENT") = 96;
    m.attr("KEY_WORLD_1") = 161;
    m.attr("KEY_WORLD_2") = 162;
    m.attr("KEY_ESCAPE") = 256;
    m.attr("KEY_ENTER") = 257;
    m.attr("KEY_TAB") = 258;
    m.attr("KEY_BACKSPACE") = 259;
    m.attr("KEY_INSERT") = 260;
    m.attr("KEY_DELETE") = 261;
    m.attr("KEY_RIGHT") = 262;
    m.attr("KEY_LEFT") = 263;
    m.attr("KEY_DOWN") = 264;
    m.attr("KEY_UP") = 265;
    m.attr("KEY_PAGE_UP") = 266;
    m.attr("KEY_PAGE_DOWN") = 267;
    m.attr("KEY_HOME") = 268;
    m.attr("KEY_END") = 269;
    m.attr("KEY_CAPS_LOCK") = 280;
    m.attr("KEY_SCROLL_LOCK") = 281;
    m.attr("KEY_NUM_LOCK") = 282;
    m.attr("KEY_PRINT_SCREEN") = 283;
    m.attr("KEY_PAUSE") = 284;
    m.attr("KEY_F1") = 290;
    m.attr("KEY_F2") = 291;
    m.attr("KEY_F3") = 292;
    m.attr("KEY_F4") = 293;
    m.attr("KEY_F5") = 294;
    m.attr("KEY_F6") = 295;
    m.attr("KEY_F7") = 296;
    m.attr("KEY_F8") = 297;
    m.attr("KEY_F9") = 298;
    m.attr("KEY_F10") = 299;
    m.attr("KEY_F11") = 300;
    m.attr("KEY_F12") = 301;
    m.attr("KEY_F13") = 302;
    m.attr("KEY_F14") = 303;
    m.attr("KEY_F15") = 304;
    m.attr("KEY_F16") = 305;
    m.attr("KEY_F17") = 306;
    m.attr("KEY_F18") = 307;
    m.attr("KEY_F19") = 308;
    m.attr("KEY_F20") = 309;
    m.attr("KEY_F21") = 310;
    m.attr("KEY_F22") = 311;
    m.attr("KEY_F23") = 312;
    m.attr("KEY_F24") = 313;
    m.attr("KEY_F25") = 314;
    m.attr("KEY_KP_0") = 320;
    m.attr("KEY_KP_1") = 321;
    m.attr("KEY_KP_2") = 322;
    m.attr("KEY_KP_3") = 323;
    m.attr("KEY_KP_4") = 324;
    m.attr("KEY_KP_5") = 325;
    m.attr("KEY_KP_6") = 326;
    m.attr("KEY_KP_7") = 327;
    m.attr("KEY_KP_8") = 328;
    m.attr("KEY_KP_9") = 329;
    m.attr("KEY_KP_DECIMAL") = 330;
    m.attr("KEY_KP_DIVIDE") = 331;
    m.attr("KEY_KP_MULTIPLY") = 332;
    m.attr("KEY_KP_SUBTRACT") = 333;
    m.attr("KEY_KP_ADD") = 334;
    m.attr("KEY_KP_ENTER") = 335;
    m.attr("KEY_KP_EQUAL") = 336;
    m.attr("KEY_LEFT_SHIFT") = 340;
    m.attr("KEY_LEFT_CONTROL") = 341;
    m.attr("KEY_LEFT_ALT") = 342;
    m.attr("KEY_LEFT_SUPER") = 343;
    m.attr("KEY_RIGHT_SHIFT") = 344;
    m.attr("KEY_RIGHT_CONTROL") = 345;
    m.attr("KEY_RIGHT_ALT") = 346;
    m.attr("KEY_RIGHT_SUPER") = 347;
    m.attr("KEY_MENU") = 348;
    m.attr("MOD_SHIFT") = 0x0001;
    m.attr("MOD_CONTROL") = 0x0002;
    m.attr("MOD_ALT") = 0x0004;
    m.attr("MOD_SUPER") = 0x0008;
    m.attr("MOD_CAPS_LOCK") = 0x0010;
    m.attr("MOD_NUM_LOCK") = 0x0020;
    m.attr("MOUSE_BUTTON_1") = 0;
    m.attr("MOUSE_BUTTON_2") = 1;
    m.attr("MOUSE_BUTTON_3") = 2;
    m.attr("MOUSE_BUTTON_4") = 3;
    m.attr("MOUSE_BUTTON_5") = 4;
    m.attr("MOUSE_BUTTON_6") = 5;
    m.attr("MOUSE_BUTTON_7") = 6;
    m.attr("MOUSE_BUTTON_8") = 7;
    m.attr("JOYSTICK_1") = 0;
    m.attr("JOYSTICK_2") = 1;
    m.attr("JOYSTICK_3") = 2;
    m.attr("JOYSTICK_4") = 3;
    m.attr("JOYSTICK_5") = 4;
    m.attr("JOYSTICK_6") = 5;
    m.attr("JOYSTICK_7") = 6;
    m.attr("JOYSTICK_8") = 7;
    m.attr("JOYSTICK_9") = 8;
    m.attr("JOYSTICK_10") = 9;
    m.attr("JOYSTICK_11") = 10;
    m.attr("JOYSTICK_12") = 11;
    m.attr("JOYSTICK_13") = 12;
    m.attr("JOYSTICK_14") = 13;
    m.attr("JOYSTICK_15") = 14;
    m.attr("JOYSTICK_16") = 15;
    m.attr("GAMEPAD_BUTTON_A") = 0;
    m.attr("GAMEPAD_BUTTON_B") = 1;
    m.attr("GAMEPAD_BUTTON_X") = 2;
    m.attr("GAMEPAD_BUTTON_Y") = 3;
    m.attr("GAMEPAD_BUTTON_LEFT_BUMPER") = 4;
    m.attr("GAMEPAD_BUTTON_RIGHT_BUMPER") = 5;
    m.attr("GAMEPAD_BUTTON_BACK") = 6;
    m.attr("GAMEPAD_BUTTON_START") = 7;
    m.attr("GAMEPAD_BUTTON_GUIDE") = 8;
    m.attr("GAMEPAD_BUTTON_LEFT_THUMB") = 9;
    m.attr("GAMEPAD_BUTTON_RIGHT_THUMB") = 10;
    m.attr("GAMEPAD_BUTTON_DPAD_UP") = 11;
    m.attr("GAMEPAD_BUTTON_DPAD_RIGHT") = 12;
    m.attr("GAMEPAD_BUTTON_DPAD_DOWN") = 13;
    m.attr("GAMEPAD_BUTTON_DPAD_LEFT") = 14;
    m.attr("GAMEPAD_AXIS_LEFT_X") = 0;
    m.attr("GAMEPAD_AXIS_LEFT_Y") = 1;
    m.attr("GAMEPAD_AXIS_RIGHT_X") = 2;
    m.attr("GAMEPAD_AXIS_RIGHT_Y") = 3;
    m.attr("GAMEPAD_AXIS_LEFT_TRIGGER") = 4;
    m.attr("GAMEPAD_AXIS_RIGHT_TRIGGER") = 5;
    m.attr("NO_ERROR") = 0;
    m.attr("NOT_INITIALIZED") = 0x00010001;
    m.attr("NO_CURRENT_CONTEXT") = 0x00010002;
    m.attr("INVALID_ENUM") = 0x00010003;
    m.attr("INVALID_VALUE") = 0x00010004;
    m.attr("OUT_OF_MEMORY") = 0x00010005;
    m.attr("API_UNAVAILABLE") = 0x00010006;
    m.attr("VERSION_UNAVAILABLE") = 0x00010007;
    m.attr("PLATFORM_ERROR") = 0x00010008;
    m.attr("FORMAT_UNAVAILABLE") = 0x00010009;
    m.attr("NO_WINDOW_CONTEXT") = 0x0001000A;
    m.attr("CURSOR_UNAVAILABLE") = 0x0001000B;
    m.attr("FEATURE_UNAVAILABLE") = 0x0001000C;
    m.attr("FEATURE_UNIMPLEMENTED") = 0x0001000D;
    m.attr("PLATFORM_UNAVAILABLE") = 0x0001000E;
    m.attr("FOCUSED") = 0x00020001;
    m.attr("ICONIFIED") = 0x00020002;
    m.attr("RESIZABLE") = 0x00020003;
    m.attr("VISIBLE") = 0x00020004;
    m.attr("DECORATED") = 0x00020005;
    m.attr("AUTO_ICONIFY") = 0x00020006;
    m.attr("FLOATING") = 0x00020007;
    m.attr("MAXIMIZED") = 0x00020008;
    m.attr("CENTER_CURSOR") = 0x00020009;
    m.attr("TRANSPARENT_FRAMEBUFFER") = 0x0002000A;
    m.attr("HOVERED") = 0x0002000B;
    m.attr("FOCUS_ON_SHOW") = 0x0002000C;
    m.attr("MOUSE_PASSTHROUGH") = 0x0002000D;
    m.attr("RED_BITS") = 0x00021001;
    m.attr("GREEN_BITS") = 0x00021002;
    m.attr("BLUE_BITS") = 0x00021003;
    m.attr("ALPHA_BITS") = 0x00021004;
    m.attr("DEPTH_BITS") = 0x00021005;
    m.attr("STENCIL_BITS") = 0x00021006;
    m.attr("ACCUM_RED_BITS") = 0x00021007;
    m.attr("ACCUM_GREEN_BITS") = 0x00021008;
    m.attr("ACCUM_BLUE_BITS") = 0x00021009;
    m.attr("ACCUM_ALPHA_BITS") = 0x0002100A;
    m.attr("AUX_BUFFERS") = 0x0002100B;
    m.attr("STEREO") = 0x0002100C;
    m.attr("SAMPLES") = 0x0002100D;
    m.attr("SRGB_CAPABLE") = 0x0002100E;
    m.attr("REFRESH_RATE") = 0x0002100F;
    m.attr("DOUBLEBUFFER") = 0x00021010;
    m.attr("CLIENT_API") = 0x00022001;
    m.attr("CONTEXT_VERSION_MAJOR") = 0x00022002;
    m.attr("CONTEXT_VERSION_MINOR") = 0x00022003;
    m.attr("CONTEXT_REVISION") = 0x00022004;
    m.attr("CONTEXT_ROBUSTNESS") = 0x00022005;
    m.attr("OPENGL_FORWARD_COMPAT") = 0x00022006;
    m.attr("CONTEXT_DEBUG") = 0x00022007;
    m.attr("OPENGL_PROFILE") = 0x00022008;
    m.attr("CONTEXT_RELEASE_BEHAVIOR") = 0x00022009;
    m.attr("CONTEXT_NO_ERROR") = 0x0002200A;
    m.attr("CONTEXT_CREATION_API") = 0x0002200B;
    m.attr("SCALE_TO_MONITOR") = 0x0002200C;
    m.attr("COCOA_RETINA_FRAMEBUFFER") = 0x00023001;
    m.attr("COCOA_FRAME_NAME") = 0x00023002;
    m.attr("COCOA_GRAPHICS_SWITCHING") = 0x00023003;
    m.attr("X11_CLASS_NAME") = 0x00024001;
    m.attr("X11_INSTANCE_NAME") = 0x00024002;
    m.attr("WIN32_KEYBOARD_MENU") = 0x00025001;
    m.attr("NO_API") = 0;
    m.attr("OPENGL_API") = 0x00030001;
    m.attr("OPENGL_ES_API") = 0x00030002;
    m.attr("NO_ROBUSTNESS") = 0;
    m.attr("NO_RESET_NOTIFICATION") = 0x00031001;
    m.attr("LOSE_CONTEXT_ON_RESET") = 0x00031002;
    m.attr("OPENGL_ANY_PROFILE") = 0;
    m.attr("OPENGL_CORE_PROFILE") = 0x00032001;
    m.attr("OPENGL_COMPAT_PROFILE") = 0x00032002;
    m.attr("CURSOR") = 0x00033001;
    m.attr("STICKY_KEYS") = 0x00033002;
    m.attr("STICKY_MOUSE_BUTTONS") = 0x00033003;
    m.attr("LOCK_KEY_MODS") = 0x00033004;
    m.attr("RAW_MOUSE_MOTION") = 0x00033005;
    m.attr("CURSOR_NORMAL") = 0x00034001;
    m.attr("CURSOR_HIDDEN") = 0x00034002;
    m.attr("CURSOR_DISABLED") = 0x00034003;
    m.attr("ANY_RELEASE_BEHAVIOR") = 0;
    m.attr("RELEASE_BEHAVIOR_FLUSH") = 0x00035001;
    m.attr("RELEASE_BEHAVIOR_NONE") = 0x00035002;
    m.attr("NATIVE_CONTEXT_API") = 0x00036001;
    m.attr("EGL_CONTEXT_API") = 0x00036002;
    m.attr("OSMESA_CONTEXT_API") = 0x00036003;
    m.attr("ANGLE_PLATFORM_TYPE_NONE") = 0x00037001;
    m.attr("ANGLE_PLATFORM_TYPE_OPENGL") = 0x00037002;
    m.attr("ANGLE_PLATFORM_TYPE_OPENGLES") = 0x00037003;
    m.attr("ANGLE_PLATFORM_TYPE_D3D9") = 0x00037004;
    m.attr("ANGLE_PLATFORM_TYPE_D3D11") = 0x00037005;
    m.attr("ANGLE_PLATFORM_TYPE_VULKAN") = 0x00037007;
    m.attr("ANGLE_PLATFORM_TYPE_METAL") = 0x00037008;
    m.attr("ARROW_CURSOR") = 0x00036001;
    m.attr("IBEAM_CURSOR") = 0x00036002;
    m.attr("CROSSHAIR_CURSOR") = 0x00036003;
    m.attr("POINTING_HAND_CURSOR") = 0x00036004;
    m.attr("RESIZE_EW_CURSOR") = 0x00036005;
    m.attr("RESIZE_NS_CURSOR") = 0x00036006;
    m.attr("RESIZE_NWSE_CURSOR") = 0x00036007;
    m.attr("RESIZE_NESW_CURSOR") = 0x00036008;
    m.attr("RESIZE_ALL_CURSOR") = 0x00036009;
    m.attr("NOT_ALLOWED_CURSOR") = 0x0003600A;
    m.attr("CONNECTED") = 0x00040001;
    m.attr("DISCONNECTED") = 0x00040002;
    m.attr("JOYSTICK_HAT_BUTTONS") = 0x00050001;
    m.attr("ANGLE_PLATFORM_TYPE") = 0x00050002;
    m.attr("PLATFORM") = 0x00050003;
    m.attr("COCOA_CHDIR_RESOURCES") = 0x00051001;
    m.attr("COCOA_MENUBAR") = 0x00051002;
    m.attr("X11_XCB_VULKAN_SURFACE") = 0x00052001;
    m.attr("ANY_PLATFORM") = 0x00060000;
    m.attr("PLATFORM_WIN32") = 0x00060001;
    m.attr("PLATFORM_COCOA") = 0x00060002;
    m.attr("PLATFORM_WAYLAND") = 0x00060003;
    m.attr("PLATFORM_X11") = 0x00060004;
    m.attr("PLATFORM_NULL") = 0x00060005;
    m.attr("DONT_CARE") = -1;

    m.def("init",
        glfwInit, "! @brief Initializes the GLFW library.\n *\n *  This function initializes the GLFW library.  Before most GLFW functions can\n *  be used, GLFW must be initialized, and before an application terminates GLFW\n *  should be terminated in order to free any resources allocated during or\n *  after initialization.\n *\n *  If this function fails, it calls @ref glfwTerminate before returning.  If it\n *  succeeds, you should call @ref glfwTerminate before the application exits.\n *\n *  Additional calls to this function after successful initialization but before\n *  termination will return `GLFW_TRUE` immediately.\n *\n *  The @ref GLFW_PLATFORM init hint controls which platforms are considered during\n *  initialization.  This also depends on which platforms the library was compiled to\n *  support.\n *\n *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_PLATFORM_UNAVAILABLE and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @macos This function will change the current directory of the\n *  application to the `Contents/Resources` subdirectory of the application's\n *  bundle, if present.  This can be disabled with the @ref\n *  GLFW_COCOA_CHDIR_RESOURCES init hint.\n *\n *  @remark @macos This function will create the main menu and dock icon for the\n *  application.  If GLFW finds a `MainMenu.nib` it is loaded and assumed to\n *  contain a menu bar.  Otherwise a minimal menu bar is created manually with\n *  common commands like Hide, Quit and About.  The About entry opens a minimal\n *  about dialog with information from the application's bundle.  The menu bar\n *  and dock icon can be disabled entirely with the @ref GLFW_COCOA_MENUBAR init\n *  hint.\n *\n *  @remark @x11 This function will set the `LC_CTYPE` category of the\n *  application locale according to the current environment if that category is\n *  still \"C\".  This is because the \"C\" locale breaks Unicode text input.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref intro_init\n *  @sa @ref glfwInitHint\n *  @sa @ref glfwInitAllocator\n *  @sa @ref glfwTerminate\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup init\n");

    m.def("terminate",
        glfwTerminate, "! @brief Terminates the GLFW library.\n *\n *  This function destroys all remaining windows and cursors, restores any\n *  modified gamma ramps and frees any other allocated resources.  Once this\n *  function is called, you must again call @ref glfwInit successfully before\n *  you will be able to use most GLFW functions.\n *\n *  If GLFW has been successfully initialized, this function should be called\n *  before the application exits.  If initialization fails, there is no need to\n *  call this function, as it is called by @ref glfwInit before it returns\n *  failure.\n *\n *  This function has no effect if GLFW is not initialized.\n *\n *  @errors Possible errors include @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @warning The contexts of any remaining windows must not be current on any\n *  other thread when this function is called.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref intro_init\n *  @sa @ref glfwInit\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup init\n");

    m.def("init_hint",
        glfwInitHint,
        py::arg("hint"), py::arg("value"),
        "! @brief Sets the specified init hint to the desired value.\n *\n *  This function sets hints for the next initialization of GLFW.\n *\n *  The values you set hints to are never reset by GLFW, but they only take\n *  effect during initialization.  Once GLFW has been initialized, any values\n *  you set will be ignored until the library is terminated and initialized\n *  again.\n *\n *  Some hints are platform specific.  These may be set on any platform but they\n *  will only affect their specific platform.  Other platforms will ignore them.\n *  Setting these hints requires no platform specific headers or functions.\n *\n *  @param[in] hint The [init hint](@ref init_hints) to set.\n *  @param[in] value The new value of the init hint.\n *\n *  @errors Possible errors include @ref GLFW_INVALID_ENUM and @ref\n *  GLFW_INVALID_VALUE.\n *\n *  @remarks This function may be called before @ref glfwInit.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa init_hints\n *  @sa glfwInit\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup init\n");

    m.def("init_allocator",
        glfwInitAllocator,
        py::arg("allocator"),
        "! @brief Sets the init allocator to the desired value.\n *\n *  To use the default allocator, call this function with a `None` argument.\n *\n *  If you specify an allocator struct, every member must be a valid function\n *  pointer.  If any member is `None`, this function emits @ref\n *  GLFW_INVALID_VALUE and the init allocator is unchanged.\n *\n *  @param[in] allocator The allocator to use at the next initialization, or\n *  `None` to use the default one.\n *\n *  @errors Possible errors include @ref GLFW_INVALID_VALUE.\n *\n *  @pointer_lifetime The specified allocator is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref init_allocator\n *  @sa @ref glfwInit\n *\n *  @since Added in version 3.4.\n *\n *  @ingroup init\n");

    m.def("get_version",
        [](BoxedInt & major, BoxedInt & minor, BoxedInt & rev)
        {
            auto glfwGetVersion_adapt_modifiable_immutable = [](BoxedInt & major, BoxedInt & minor, BoxedInt & rev)
            {
                int * major_boxed_value = & (major.value);
                int * minor_boxed_value = & (minor.value);
                int * rev_boxed_value = & (rev.value);

                glfwGetVersion(major_boxed_value, minor_boxed_value, rev_boxed_value);
            };

            glfwGetVersion_adapt_modifiable_immutable(major, minor, rev);
        },
        py::arg("major"), py::arg("minor"), py::arg("rev"),
        "! @brief Retrieves the version of the GLFW library.\n *\n *  This function retrieves the major, minor and revision numbers of the GLFW\n *  library.  It is intended for when you are using GLFW as a shared library and\n *  want to ensure that you are using the minimum required version.\n *\n *  Any or all of the version arguments may be `None`.\n *\n *  @param[out] major Where to store the major version number, or `None`.\n *  @param[out] minor Where to store the minor version number, or `None`.\n *  @param[out] rev Where to store the revision number, or `None`.\n *\n *  @errors None.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref intro_version\n *  @sa @ref glfwGetVersionString\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup init\n");

    m.def("get_version_string",
        glfwGetVersionString, "! @brief Returns a string describing the compile-time configuration.\n *\n *  This function returns the compile-time generated\n *  [version string](@ref intro_version_string) of the GLFW library binary.  It describes\n *  the version, platforms, compiler and any platform or operating system specific\n *  compile-time options.  It should not be confused with the OpenGL or OpenGL ES version\n *  string, queried with `glGetString`.\n *\n *  __Do not use the version string__ to parse the GLFW library version.  The\n *  @ref glfwGetVersion function provides the version of the running library\n *  binary in numerical format.\n *\n *  __Do not use the version string__ to parse what platforms are supported.  The @ref\n *  glfwPlatformSupported function lets you query platform support.\n *\n *  @return The ASCII encoded GLFW version string.\n *\n *  @errors None.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @pointer_lifetime The returned string is static and compile-time generated.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref intro_version\n *  @sa @ref glfwGetVersion\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup init\n");

    m.def("get_platform",
        glfwGetPlatform, "! @brief Returns the currently selected platform.\n *\n *  This function returns the platform that was selected during initialization.  The\n *  returned value will be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,\n *  `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.\n *\n *  @return The currently selected platform, or zero if an error occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref platform\n *  @sa @ref glfwPlatformSupported\n *\n *  @since Added in version 3.4.\n *\n *  @ingroup init\n");

    m.def("platform_supported",
        glfwPlatformSupported,
        py::arg("platform"),
        "! @brief Returns whether the library includes support for the specified platform.\n *\n *  This function returns whether the library was compiled with support for the specified\n *  platform.  The platform must be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,\n *  `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.\n *\n *  @param[in] platform The platform to query.\n *  @return `GLFW_TRUE` if the platform is supported, or `GLFW_FALSE` otherwise.\n *\n *  @errors Possible errors include @ref GLFW_INVALID_ENUM.\n *\n *  @remark This function may be called before @ref glfwInit.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref platform\n *  @sa @ref glfwGetPlatform\n *\n *  @since Added in version 3.4.\n *\n *  @ingroup init\n");

    m.def("get_primary_monitor",
        glfwGetPrimaryMonitor, "! @brief Returns the primary monitor.\n *\n *  This function returns the primary monitor.  This is usually the monitor\n *  where elements like the task bar or global menu bar are located.\n *\n *  @return The primary monitor, or `None` if no monitors were found or if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @remark The primary monitor is always first in the array returned by @ref\n *  glfwGetMonitors.\n *\n *  @sa @ref monitor_monitors\n *  @sa @ref glfwGetMonitors\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n");

    m.def("get_monitor_pos",
        [](GLFWmonitor * monitor, BoxedInt & xpos, BoxedInt & ypos)
        {
            auto glfwGetMonitorPos_adapt_modifiable_immutable = [](GLFWmonitor * monitor, BoxedInt & xpos, BoxedInt & ypos)
            {
                int * xpos_boxed_value = & (xpos.value);
                int * ypos_boxed_value = & (ypos.value);

                glfwGetMonitorPos(monitor, xpos_boxed_value, ypos_boxed_value);
            };

            glfwGetMonitorPos_adapt_modifiable_immutable(monitor, xpos, ypos);
        },
        py::arg("monitor"), py::arg("xpos"), py::arg("ypos"),
        "! @brief Returns the position of the monitor's viewport on the virtual screen.\n *\n *  This function returns the position, in screen coordinates, of the upper-left\n *  corner of the specified monitor.\n *\n *  Any or all of the position arguments may be `None`.  If an error occurs, all\n *  non-`None` position arguments will be set to zero.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] xpos Where to store the monitor x-coordinate, or `None`.\n *  @param[out] ypos Where to store the monitor y-coordinate, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_properties\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n");

    m.def("get_monitor_workarea",
        [](GLFWmonitor * monitor, BoxedInt & xpos, BoxedInt & ypos, BoxedInt & width, BoxedInt & height)
        {
            auto glfwGetMonitorWorkarea_adapt_modifiable_immutable = [](GLFWmonitor * monitor, BoxedInt & xpos, BoxedInt & ypos, BoxedInt & width, BoxedInt & height)
            {
                int * xpos_boxed_value = & (xpos.value);
                int * ypos_boxed_value = & (ypos.value);
                int * width_boxed_value = & (width.value);
                int * height_boxed_value = & (height.value);

                glfwGetMonitorWorkarea(monitor, xpos_boxed_value, ypos_boxed_value, width_boxed_value, height_boxed_value);
            };

            glfwGetMonitorWorkarea_adapt_modifiable_immutable(monitor, xpos, ypos, width, height);
        },
        py::arg("monitor"), py::arg("xpos"), py::arg("ypos"), py::arg("width"), py::arg("height"),
        "! @brief Retrieves the work area of the monitor.\n *\n *  This function returns the position, in screen coordinates, of the upper-left\n *  corner of the work area of the specified monitor along with the work area\n *  size in screen coordinates. The work area is defined as the area of the\n *  monitor not occluded by the window system task bar where present. If no\n *  task bar exists then the work area is the monitor resolution in screen\n *  coordinates.\n *\n *  Any or all of the position and size arguments may be `None`.  If an error\n *  occurs, all non-`None` position and size arguments will be set to zero.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] xpos Where to store the monitor x-coordinate, or `None`.\n *  @param[out] ypos Where to store the monitor y-coordinate, or `None`.\n *  @param[out] width Where to store the monitor width, or `None`.\n *  @param[out] height Where to store the monitor height, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_workarea\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n");

    m.def("get_monitor_physical_size",
        [](GLFWmonitor * monitor, BoxedInt & widthMM, BoxedInt & heightMM)
        {
            auto glfwGetMonitorPhysicalSize_adapt_modifiable_immutable = [](GLFWmonitor * monitor, BoxedInt & widthMM, BoxedInt & heightMM)
            {
                int * widthMM_boxed_value = & (widthMM.value);
                int * heightMM_boxed_value = & (heightMM.value);

                glfwGetMonitorPhysicalSize(monitor, widthMM_boxed_value, heightMM_boxed_value);
            };

            glfwGetMonitorPhysicalSize_adapt_modifiable_immutable(monitor, widthMM, heightMM);
        },
        py::arg("monitor"), py::arg("width_mm"), py::arg("height_mm"),
        "! @brief Returns the physical size of the monitor.\n *\n *  This function returns the size, in millimetres, of the display area of the\n *  specified monitor.\n *\n *  Some platforms do not provide accurate monitor size information, either\n *  because the monitor\n *  [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)\n *  data is incorrect or because the driver does not report it accurately.\n *\n *  Any or all of the size arguments may be `None`.  If an error occurs, all\n *  non-`None` size arguments will be set to zero.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] widthMM Where to store the width, in millimetres, of the\n *  monitor's display area, or `None`.\n *  @param[out] heightMM Where to store the height, in millimetres, of the\n *  monitor's display area, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @remark @win32 On Windows 8 and earlier the physical size is calculated from\n *  the current resolution and system DPI instead of querying the monitor EDID data.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_properties\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n");

    m.def("get_monitor_content_scale",
        [](GLFWmonitor * monitor, BoxedFloat & xscale, BoxedFloat & yscale)
        {
            auto glfwGetMonitorContentScale_adapt_modifiable_immutable = [](GLFWmonitor * monitor, BoxedFloat & xscale, BoxedFloat & yscale)
            {
                float * xscale_boxed_value = & (xscale.value);
                float * yscale_boxed_value = & (yscale.value);

                glfwGetMonitorContentScale(monitor, xscale_boxed_value, yscale_boxed_value);
            };

            glfwGetMonitorContentScale_adapt_modifiable_immutable(monitor, xscale, yscale);
        },
        py::arg("monitor"), py::arg("xscale"), py::arg("yscale"),
        "! @brief Retrieves the content scale for the specified monitor.\n *\n *  This function retrieves the content scale for the specified monitor.  The\n *  content scale is the ratio between the current DPI and the platform's\n *  default DPI.  This is especially important for text and any UI elements.  If\n *  the pixel dimensions of your UI scaled by this look appropriate on your\n *  machine then it should appear at a reasonable size on other machines\n *  regardless of their DPI and scaling settings.  This relies on the system DPI\n *  and scaling settings being somewhat correct.\n *\n *  The content scale may depend on both the monitor resolution and pixel\n *  density and on user settings.  It may be very different from the raw DPI\n *  calculated from the physical size and current resolution.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] xscale Where to store the x-axis content scale, or `None`.\n *  @param[out] yscale Where to store the y-axis content scale, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_scale\n *  @sa @ref glfwGetWindowContentScale\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n");

    m.def("get_monitor_name",
        glfwGetMonitorName,
        py::arg("monitor"),
        "! @brief Returns the name of the specified monitor.\n *\n *  This function returns a human-readable name, encoded as UTF-8, of the\n *  specified monitor.  The name typically reflects the make and model of the\n *  monitor and is not guaranteed to be unique among the connected monitors.\n *\n *  @param[in] monitor The monitor to query.\n *  @return The UTF-8 encoded name of the monitor, or `None` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified monitor is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_properties\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n");

    m.def("set_monitor_user_pointer",
        glfwSetMonitorUserPointer,
        py::arg("monitor"), py::arg("pointer"),
        "! @brief Sets the user pointer of the specified monitor.\n *\n *  This function sets the user-defined pointer of the specified monitor.  The\n *  current value is retained until the monitor is disconnected.  The initial\n *  value is `None`.\n *\n *  This function may be called from the monitor callback, even for a monitor\n *  that is being disconnected.\n *\n *  @param[in] monitor The monitor whose pointer to set.\n *  @param[in] pointer The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref monitor_userptr\n *  @sa @ref glfwGetMonitorUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n");

    m.def("get_monitor_user_pointer",
        glfwGetMonitorUserPointer,
        py::arg("monitor"),
        "! @brief Returns the user pointer of the specified monitor.\n *\n *  This function returns the current value of the user-defined pointer of the\n *  specified monitor.  The initial value is `None`.\n *\n *  This function may be called from the monitor callback, even for a monitor\n *  that is being disconnected.\n *\n *  @param[in] monitor The monitor whose pointer to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref monitor_userptr\n *  @sa @ref glfwSetMonitorUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup monitor\n");

    m.def("get_video_modes",
        [](GLFWmonitor * monitor, BoxedInt & count) -> const GLFWvidmode *
        {
            auto glfwGetVideoModes_adapt_modifiable_immutable = [](GLFWmonitor * monitor, BoxedInt & count) -> const GLFWvidmode *
            {
                int * count_boxed_value = & (count.value);

                auto r = glfwGetVideoModes(monitor, count_boxed_value);
                return r;
            };

            return glfwGetVideoModes_adapt_modifiable_immutable(monitor, count);
        },
        py::arg("monitor"), py::arg("count"),
        "! @brief Returns the available video modes for the specified monitor.\n *\n *  This function returns an array of all video modes supported by the specified\n *  monitor.  The returned array is sorted in ascending order, first by color\n *  bit depth (the sum of all channel depths), then by resolution area (the\n *  product of width and height), then resolution width and finally by refresh\n *  rate.\n *\n *  @param[in] monitor The monitor to query.\n *  @param[out] count Where to store the number of video modes in the returned\n *  array.  This is set to zero if an error occurred.\n *  @return An array of video modes, or `None` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified monitor is\n *  disconnected, this function is called again for that monitor or the library\n *  is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_modes\n *  @sa @ref glfwGetVideoMode\n *\n *  @since Added in version 1.0.\n *  @glfw3 Changed to return an array of modes for a specific monitor.\n *\n *  @ingroup monitor\n");

    m.def("get_video_mode",
        glfwGetVideoMode,
        py::arg("monitor"),
        "! @brief Returns the current mode of the specified monitor.\n *\n *  This function returns the current video mode of the specified monitor.  If\n *  you have created a full screen window for that monitor, the return value\n *  will depend on whether that window is iconified.\n *\n *  @param[in] monitor The monitor to query.\n *  @return The current mode of the monitor, or `None` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified monitor is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_modes\n *  @sa @ref glfwGetVideoModes\n *\n *  @since Added in version 3.0.  Replaces `glfwGetDesktopMode`.\n *\n *  @ingroup monitor\n");

    m.def("set_gamma",
        glfwSetGamma,
        py::arg("monitor"), py::arg("gamma"),
        "! @brief Generates a gamma ramp and sets it for the specified monitor.\n *\n *  This function generates an appropriately sized gamma ramp from the specified\n *  exponent and then calls @ref glfwSetGammaRamp with it.  The value must be\n *  a finite number greater than zero.\n *\n *  The software controlled gamma ramp is applied _in addition_ to the hardware\n *  gamma correction, which today is usually an approximation of sRGB gamma.\n *  This means that setting a perfectly linear ramp, or gamma 1.0, will produce\n *  the default (usually sRGB-like) behavior.\n *\n *  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref\n *  GLFW_SRGB_CAPABLE hint.\n *\n *  @param[in] monitor The monitor whose gamma ramp to set.\n *  @param[in] gamma The desired exponent.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland Gamma handling is a privileged protocol, this function\n *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_gamma\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n");

    m.def("get_gamma_ramp",
        glfwGetGammaRamp,
        py::arg("monitor"),
        "! @brief Returns the current gamma ramp for the specified monitor.\n *\n *  This function returns the current gamma ramp of the specified monitor.\n *\n *  @param[in] monitor The monitor to query.\n *  @return The current gamma ramp, or `None` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland Gamma handling is a privileged protocol, this function\n *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR while\n *  returning `None`.\n *\n *  @pointer_lifetime The returned structure and its arrays are allocated and\n *  freed by GLFW.  You should not free them yourself.  They are valid until the\n *  specified monitor is disconnected, this function is called again for that\n *  monitor or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_gamma\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n");

    m.def("set_gamma_ramp",
        glfwSetGammaRamp,
        py::arg("monitor"), py::arg("ramp"),
        "! @brief Sets the current gamma ramp for the specified monitor.\n *\n *  This function sets the current gamma ramp for the specified monitor.  The\n *  original gamma ramp for that monitor is saved by GLFW the first time this\n *  function is called and is restored by @ref glfwTerminate.\n *\n *  The software controlled gamma ramp is applied _in addition_ to the hardware\n *  gamma correction, which today is usually an approximation of sRGB gamma.\n *  This means that setting a perfectly linear ramp, or gamma 1.0, will produce\n *  the default (usually sRGB-like) behavior.\n *\n *  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref\n *  GLFW_SRGB_CAPABLE hint.\n *\n *  @param[in] monitor The monitor whose gamma ramp to set.\n *  @param[in] ramp The gamma ramp to use.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark The size of the specified gamma ramp should match the size of the\n *  current ramp for that monitor.\n *\n *  @remark @win32 The gamma ramp size must be 256.\n *\n *  @remark @wayland Gamma handling is a privileged protocol, this function\n *  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The specified gamma ramp is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref monitor_gamma\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup monitor\n");

    m.def("default_window_hints",
        glfwDefaultWindowHints, "! @brief Resets all window hints to their default values.\n *\n *  This function resets all window hints to their\n *  [default values](@ref window_hints_values).\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hints\n *  @sa @ref glfwWindowHint\n *  @sa @ref glfwWindowHintString\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("window_hint",
        glfwWindowHint,
        py::arg("hint"), py::arg("value"),
        "! @brief Sets the specified window hint to the desired value.\n *\n *  This function sets hints for the next call to @ref glfwCreateWindow.  The\n *  hints, once set, retain their values until changed by a call to this\n *  function or @ref glfwDefaultWindowHints, or until the library is terminated.\n *\n *  Only integer value hints can be set with this function.  String value hints\n *  are set with @ref glfwWindowHintString.\n *\n *  This function does not check whether the specified hint values are valid.\n *  If you set hints to invalid values this will instead be reported by the next\n *  call to @ref glfwCreateWindow.\n *\n *  Some hints are platform specific.  These may be set on any platform but they\n *  will only affect their specific platform.  Other platforms will ignore them.\n *  Setting these hints requires no platform specific headers or functions.\n *\n *  @param[in] hint The [window hint](@ref window_hints) to set.\n *  @param[in] value The new value of the window hint.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hints\n *  @sa @ref glfwWindowHintString\n *  @sa @ref glfwDefaultWindowHints\n *\n *  @since Added in version 3.0.  Replaces `glfwOpenWindowHint`.\n *\n *  @ingroup window\n");

    m.def("window_hint_string",
        glfwWindowHintString,
        py::arg("hint"), py::arg("value"),
        "! @brief Sets the specified window hint to the desired value.\n *\n *  This function sets hints for the next call to @ref glfwCreateWindow.  The\n *  hints, once set, retain their values until changed by a call to this\n *  function or @ref glfwDefaultWindowHints, or until the library is terminated.\n *\n *  Only string type hints can be set with this function.  Integer value hints\n *  are set with @ref glfwWindowHint.\n *\n *  This function does not check whether the specified hint values are valid.\n *  If you set hints to invalid values this will instead be reported by the next\n *  call to @ref glfwCreateWindow.\n *\n *  Some hints are platform specific.  These may be set on any platform but they\n *  will only affect their specific platform.  Other platforms will ignore them.\n *  Setting these hints requires no platform specific headers or functions.\n *\n *  @param[in] hint The [window hint](@ref window_hints) to set.\n *  @param[in] value The new value of the window hint.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @pointer_lifetime The specified string is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hints\n *  @sa @ref glfwWindowHint\n *  @sa @ref glfwDefaultWindowHints\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n");

    m.def("create_window",
        glfwCreateWindow,
        py::arg("width"), py::arg("height"), py::arg("title"), py::arg("monitor"), py::arg("share"),
        "! @brief Creates a window and its associated context.\n *\n *  This function creates a window and its associated OpenGL or OpenGL ES\n *  context.  Most of the options controlling how the window and its context\n *  should be created are specified with [window hints](@ref window_hints).\n *\n *  Successful creation does not change which context is current.  Before you\n *  can use the newly created context, you need to\n *  [make it current](@ref context_current).  For information about the `share`\n *  parameter, see @ref context_sharing.\n *\n *  The created window, framebuffer and context may differ from what you\n *  requested, as not all parameters and hints are\n *  [hard constraints](@ref window_hints_hard).  This includes the size of the\n *  window, especially for full screen windows.  To query the actual attributes\n *  of the created window, framebuffer and context, see @ref\n *  glfwGetWindowAttrib, @ref glfwGetWindowSize and @ref glfwGetFramebufferSize.\n *\n *  To create a full screen window, you need to specify the monitor the window\n *  will cover.  If no monitor is specified, the window will be windowed mode.\n *  Unless you have a way for the user to choose a specific monitor, it is\n *  recommended that you pick the primary monitor.  For more information on how\n *  to query connected monitors, see @ref monitor_monitors.\n *\n *  For full screen windows, the specified size becomes the resolution of the\n *  window's _desired video mode_.  As long as a full screen window is not\n *  iconified, the supported video mode most closely matching the desired video\n *  mode is set for the specified monitor.  For more information about full\n *  screen windows, including the creation of so called _windowed full screen_\n *  or _borderless full screen_ windows, see @ref window_windowed_full_screen.\n *\n *  Once you have created the window, you can switch it between windowed and\n *  full screen mode with @ref glfwSetWindowMonitor.  This will not affect its\n *  OpenGL or OpenGL ES context.\n *\n *  By default, newly created windows use the placement recommended by the\n *  window system.  To create the window at a specific position, make it\n *  initially invisible using the [GLFW_VISIBLE](@ref GLFW_VISIBLE_hint) window\n *  hint, set its [position](@ref window_pos) and then [show](@ref window_hide)\n *  it.\n *\n *  As long as at least one full screen window is not iconified, the screensaver\n *  is prohibited from starting.\n *\n *  Window systems put limits on window sizes.  Very large or very small window\n *  dimensions may be overridden by the window system on creation.  Check the\n *  actual [size](@ref window_size) after creation.\n *\n *  The [swap interval](@ref buffer_swap) is not set during window creation and\n *  the initial value may vary depending on driver settings and defaults.\n *\n *  @param[in] width The desired width, in screen coordinates, of the window.\n *  This must be greater than zero.\n *  @param[in] height The desired height, in screen coordinates, of the window.\n *  This must be greater than zero.\n *  @param[in] title The initial, UTF-8 encoded window title.\n *  @param[in] monitor The monitor to use for full screen mode, or `None` for\n *  windowed mode.\n *  @param[in] share The window whose context to share resources with, or `None`\n *  to not share resources.\n *  @return The handle of the created window, or `None` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE, @ref GLFW_API_UNAVAILABLE, @ref\n *  GLFW_VERSION_UNAVAILABLE, @ref GLFW_FORMAT_UNAVAILABLE and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @win32 Window creation will fail if the Microsoft GDI software\n *  OpenGL implementation is the only one available.\n *\n *  @remark @win32 If the executable has an icon resource named `GLFW_ICON,` it\n *  will be set as the initial icon for the window.  If no such icon is present,\n *  the `IDI_APPLICATION` icon will be used instead.  To set a different icon,\n *  see @ref glfwSetWindowIcon.\n *\n *  @remark @win32 The context to share resources with must not be current on\n *  any other thread.\n *\n *  @remark @macos The OS only supports core profile contexts for OpenGL\n *  versions 3.2 and later.  Before creating an OpenGL context of version 3.2 or\n *  later you must set the [GLFW_OPENGL_PROFILE](@ref GLFW_OPENGL_PROFILE_hint)\n *  hint accordingly.  OpenGL 3.0 and 3.1 contexts are not supported at all\n *  on macOS.\n *\n *  @remark @macos The GLFW window has no icon, as it is not a document\n *  window, but the dock icon will be the same as the application bundle's icon.\n *  For more information on bundles, see the\n *  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)\n *  in the Mac Developer Library.\n *\n *  @remark @macos On OS X 10.10 and later the window frame will not be rendered\n *  at full resolution on Retina displays unless the\n *  [GLFW_COCOA_RETINA_FRAMEBUFFER](@ref GLFW_COCOA_RETINA_FRAMEBUFFER_hint)\n *  hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the\n *  application bundle's `Info.plist`.  For more information, see\n *  [High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)\n *  in the Mac Developer Library.  The GLFW test and example programs use\n *  a custom `Info.plist` template for this, which can be found as\n *  `CMake/Info.plist.in` in the source tree.\n *\n *  @remark @macos When activating frame autosaving with\n *  [GLFW_COCOA_FRAME_NAME](@ref GLFW_COCOA_FRAME_NAME_hint), the specified\n *  window size and position may be overridden by previously saved values.\n *\n *  @remark @x11 Some window managers will not respect the placement of\n *  initially hidden windows.\n *\n *  @remark @x11 Due to the asynchronous nature of X11, it may take a moment for\n *  a window to reach its requested state.  This means you may not be able to\n *  query the final size, position or other attributes directly after window\n *  creation.\n *\n *  @remark @x11 The class part of the `WM_CLASS` window property will by\n *  default be set to the window title passed to this function.  The instance\n *  part will use the contents of the `RESOURCE_NAME` environment variable, if\n *  present and not empty, or fall back to the window title.  Set the\n *  [GLFW_X11_CLASS_NAME](@ref GLFW_X11_CLASS_NAME_hint) and\n *  [GLFW_X11_INSTANCE_NAME](@ref GLFW_X11_INSTANCE_NAME_hint) window hints to\n *  override this.\n *\n *  @remark @wayland Compositors should implement the xdg-decoration protocol\n *  for GLFW to decorate the window properly.  If this protocol isn't\n *  supported, or if the compositor prefers client-side decorations, a very\n *  simple fallback frame will be drawn using the wp_viewporter protocol.  A\n *  compositor can still emit close, maximize or fullscreen events, using for\n *  instance a keybind mechanism.  If neither of these protocols is supported,\n *  the window won't be decorated.\n *\n *  @remark @wayland A full screen window will not attempt to change the mode,\n *  no matter what the requested size or refresh rate.\n *\n *  @remark @wayland Screensaver inhibition requires the idle-inhibit protocol\n *  to be implemented in the user's compositor.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_creation\n *  @sa @ref glfwDestroyWindow\n *\n *  @since Added in version 3.0.  Replaces `glfwOpenWindow`.\n *\n *  @ingroup window\n");

    m.def("destroy_window",
        glfwDestroyWindow,
        py::arg("window"),
        "! @brief Destroys the specified window and its context.\n *\n *  This function destroys the specified window and its context.  On calling\n *  this function, no further callbacks will be called for that window.\n *\n *  If the context of the specified window is current on the main thread, it is\n *  detached before being destroyed.\n *\n *  @param[in] window The window to destroy.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @note The context of the specified window must not be current on any other\n *  thread when this function is called.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_creation\n *  @sa @ref glfwCreateWindow\n *\n *  @since Added in version 3.0.  Replaces `glfwCloseWindow`.\n *\n *  @ingroup window\n");

    m.def("window_should_close",
        glfwWindowShouldClose,
        py::arg("window"),
        "! @brief Checks the close flag of the specified window.\n *\n *  This function returns the value of the close flag of the specified window.\n *\n *  @param[in] window The window to query.\n *  @return The value of the close flag.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_close\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("set_window_should_close",
        glfwSetWindowShouldClose,
        py::arg("window"), py::arg("value"),
        "! @brief Sets the close flag of the specified window.\n *\n *  This function sets the value of the close flag of the specified window.\n *  This can be used to override the user's attempt to close the window, or\n *  to signal that it should be closed.\n *\n *  @param[in] window The window whose flag to change.\n *  @param[in] value The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_close\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("set_window_title",
        glfwSetWindowTitle,
        py::arg("window"), py::arg("title"),
        "! @brief Sets the title of the specified window.\n *\n *  This function sets the window title, encoded as UTF-8, of the specified\n *  window.\n *\n *  @param[in] window The window whose title to change.\n *  @param[in] title The UTF-8 encoded window title.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @macos The window title will not be updated until the next time you\n *  process events.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_title\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n");

    m.def("set_window_icon",
        glfwSetWindowIcon,
        py::arg("window"), py::arg("count"), py::arg("images"),
        "! @brief Sets the icon for the specified window.\n *\n *  This function sets the icon of the specified window.  If passed an array of\n *  candidate images, those of or closest to the sizes desired by the system are\n *  selected.  If no images are specified, the window reverts to its default\n *  icon.\n *\n *  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight\n *  bits per channel with the red channel first.  They are arranged canonically\n *  as packed sequential rows, starting from the top-left corner.\n *\n *  The desired image sizes varies depending on platform and system settings.\n *  The selected images will be rescaled as needed.  Good sizes include 16x16,\n *  32x32 and 48x48.\n *\n *  @param[in] window The window whose icon to set.\n *  @param[in] count The number of images in the specified array, or zero to\n *  revert to the default window icon.\n *  @param[in] images The images to create the icon from.  This is ignored if\n *  count is zero.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE, @ref GLFW_PLATFORM_ERROR and @ref\n *  GLFW_FEATURE_UNAVAILABLE (see remarks).\n *\n *  @pointer_lifetime The specified image data is copied before this function\n *  returns.\n *\n *  @remark @macos Regular windows do not have icons on macOS.  This function\n *  will emit @ref GLFW_FEATURE_UNAVAILABLE.  The dock icon will be the same as\n *  the application bundle's icon.  For more information on bundles, see the\n *  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)\n *  in the Mac Developer Library.\n *\n *  @remark @wayland There is no existing protocol to change an icon, the\n *  window will thus inherit the one defined in the application's desktop file.\n *  This function will emit @ref GLFW_FEATURE_UNAVAILABLE.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_icon\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n");

    m.def("get_window_pos",
        [](GLFWwindow * window, BoxedInt & xpos, BoxedInt & ypos)
        {
            auto glfwGetWindowPos_adapt_modifiable_immutable = [](GLFWwindow * window, BoxedInt & xpos, BoxedInt & ypos)
            {
                int * xpos_boxed_value = & (xpos.value);
                int * ypos_boxed_value = & (ypos.value);

                glfwGetWindowPos(window, xpos_boxed_value, ypos_boxed_value);
            };

            glfwGetWindowPos_adapt_modifiable_immutable(window, xpos, ypos);
        },
        py::arg("window"), py::arg("xpos"), py::arg("ypos"),
        "! @brief Retrieves the position of the content area of the specified window.\n *\n *  This function retrieves the position, in screen coordinates, of the\n *  upper-left corner of the content area of the specified window.\n *\n *  Any or all of the position arguments may be `None`.  If an error occurs, all\n *  non-`None` position arguments will be set to zero.\n *\n *  @param[in] window The window to query.\n *  @param[out] xpos Where to store the x-coordinate of the upper-left corner of\n *  the content area, or `None`.\n *  @param[out] ypos Where to store the y-coordinate of the upper-left corner of\n *  the content area, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_PLATFORM_ERROR and @ref GLFW_FEATURE_UNAVAILABLE (see remarks).\n *\n *  @remark @wayland There is no way for an application to retrieve the global\n *  position of its windows.  This function will emit @ref\n *  GLFW_FEATURE_UNAVAILABLE.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_pos\n *  @sa @ref glfwSetWindowPos\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("set_window_pos",
        glfwSetWindowPos,
        py::arg("window"), py::arg("xpos"), py::arg("ypos"),
        "! @brief Sets the position of the content area of the specified window.\n *\n *  This function sets the position, in screen coordinates, of the upper-left\n *  corner of the content area of the specified windowed mode window.  If the\n *  window is a full screen window, this function does nothing.\n *\n *  __Do not use this function__ to move an already visible window unless you\n *  have very good reasons for doing so, as it will confuse and annoy the user.\n *\n *  The window manager may put limits on what positions are allowed.  GLFW\n *  cannot and should not override these limits.\n *\n *  @param[in] window The window to query.\n *  @param[in] xpos The x-coordinate of the upper-left corner of the content area.\n *  @param[in] ypos The y-coordinate of the upper-left corner of the content area.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_PLATFORM_ERROR and @ref GLFW_FEATURE_UNAVAILABLE (see remarks).\n *\n *  @remark @wayland There is no way for an application to set the global\n *  position of its windows.  This function will emit @ref\n *  GLFW_FEATURE_UNAVAILABLE.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_pos\n *  @sa @ref glfwGetWindowPos\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n");

    m.def("get_window_size",
        [](GLFWwindow * window, BoxedInt & width, BoxedInt & height)
        {
            auto glfwGetWindowSize_adapt_modifiable_immutable = [](GLFWwindow * window, BoxedInt & width, BoxedInt & height)
            {
                int * width_boxed_value = & (width.value);
                int * height_boxed_value = & (height.value);

                glfwGetWindowSize(window, width_boxed_value, height_boxed_value);
            };

            glfwGetWindowSize_adapt_modifiable_immutable(window, width, height);
        },
        py::arg("window"), py::arg("width"), py::arg("height"),
        "! @brief Retrieves the size of the content area of the specified window.\n *\n *  This function retrieves the size, in screen coordinates, of the content area\n *  of the specified window.  If you wish to retrieve the size of the\n *  framebuffer of the window in pixels, see @ref glfwGetFramebufferSize.\n *\n *  Any or all of the size arguments may be `None`.  If an error occurs, all\n *  non-`None` size arguments will be set to zero.\n *\n *  @param[in] window The window whose size to retrieve.\n *  @param[out] width Where to store the width, in screen coordinates, of the\n *  content area, or `None`.\n *  @param[out] height Where to store the height, in screen coordinates, of the\n *  content area, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_size\n *  @sa @ref glfwSetWindowSize\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n");

    m.def("set_window_size_limits",
        glfwSetWindowSizeLimits,
        py::arg("window"), py::arg("minwidth"), py::arg("minheight"), py::arg("maxwidth"), py::arg("maxheight"),
        "! @brief Sets the size limits of the specified window.\n *\n *  This function sets the size limits of the content area of the specified\n *  window.  If the window is full screen, the size limits only take effect\n *  once it is made windowed.  If the window is not resizable, this function\n *  does nothing.\n *\n *  The size limits are applied immediately to a windowed mode window and may\n *  cause it to be resized.\n *\n *  The maximum dimensions must be greater than or equal to the minimum\n *  dimensions and all must be greater than or equal to zero.\n *\n *  @param[in] window The window to set limits for.\n *  @param[in] minwidth The minimum width, in screen coordinates, of the content\n *  area, or `GLFW_DONT_CARE`.\n *  @param[in] minheight The minimum height, in screen coordinates, of the\n *  content area, or `GLFW_DONT_CARE`.\n *  @param[in] maxwidth The maximum width, in screen coordinates, of the content\n *  area, or `GLFW_DONT_CARE`.\n *  @param[in] maxheight The maximum height, in screen coordinates, of the\n *  content area, or `GLFW_DONT_CARE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark If you set size limits and an aspect ratio that conflict, the\n *  results are undefined.\n *\n *  @remark @wayland The size limits will not be applied until the window is\n *  actually resized, either by the user or by the compositor.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_sizelimits\n *  @sa @ref glfwSetWindowAspectRatio\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n");

    m.def("set_window_aspect_ratio",
        glfwSetWindowAspectRatio,
        py::arg("window"), py::arg("numer"), py::arg("denom"),
        "! @brief Sets the aspect ratio of the specified window.\n *\n *  This function sets the required aspect ratio of the content area of the\n *  specified window.  If the window is full screen, the aspect ratio only takes\n *  effect once it is made windowed.  If the window is not resizable, this\n *  function does nothing.\n *\n *  The aspect ratio is specified as a numerator and a denominator and both\n *  values must be greater than zero.  For example, the common 16:9 aspect ratio\n *  is specified as 16 and 9, respectively.\n *\n *  If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect\n *  ratio limit is disabled.\n *\n *  The aspect ratio is applied immediately to a windowed mode window and may\n *  cause it to be resized.\n *\n *  @param[in] window The window to set limits for.\n *  @param[in] numer The numerator of the desired aspect ratio, or\n *  `GLFW_DONT_CARE`.\n *  @param[in] denom The denominator of the desired aspect ratio, or\n *  `GLFW_DONT_CARE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark If you set size limits and an aspect ratio that conflict, the\n *  results are undefined.\n *\n *  @remark @wayland The aspect ratio will not be applied until the window is\n *  actually resized, either by the user or by the compositor.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_sizelimits\n *  @sa @ref glfwSetWindowSizeLimits\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n");

    m.def("set_window_size",
        glfwSetWindowSize,
        py::arg("window"), py::arg("width"), py::arg("height"),
        "! @brief Sets the size of the content area of the specified window.\n *\n *  This function sets the size, in screen coordinates, of the content area of\n *  the specified window.\n *\n *  For full screen windows, this function updates the resolution of its desired\n *  video mode and switches to the video mode closest to it, without affecting\n *  the window's context.  As the context is unaffected, the bit depths of the\n *  framebuffer remain unchanged.\n *\n *  If you wish to update the refresh rate of the desired video mode in addition\n *  to its resolution, see @ref glfwSetWindowMonitor.\n *\n *  The window manager may put limits on what sizes are allowed.  GLFW cannot\n *  and should not override these limits.\n *\n *  @param[in] window The window to resize.\n *  @param[in] width The desired width, in screen coordinates, of the window\n *  content area.\n *  @param[in] height The desired height, in screen coordinates, of the window\n *  content area.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland A full screen window will not attempt to change the mode,\n *  no matter what the requested size.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_size\n *  @sa @ref glfwGetWindowSize\n *  @sa @ref glfwSetWindowMonitor\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n");

    m.def("get_framebuffer_size",
        [](GLFWwindow * window, BoxedInt & width, BoxedInt & height)
        {
            auto glfwGetFramebufferSize_adapt_modifiable_immutable = [](GLFWwindow * window, BoxedInt & width, BoxedInt & height)
            {
                int * width_boxed_value = & (width.value);
                int * height_boxed_value = & (height.value);

                glfwGetFramebufferSize(window, width_boxed_value, height_boxed_value);
            };

            glfwGetFramebufferSize_adapt_modifiable_immutable(window, width, height);
        },
        py::arg("window"), py::arg("width"), py::arg("height"),
        "! @brief Retrieves the size of the framebuffer of the specified window.\n *\n *  This function retrieves the size, in pixels, of the framebuffer of the\n *  specified window.  If you wish to retrieve the size of the window in screen\n *  coordinates, see @ref glfwGetWindowSize.\n *\n *  Any or all of the size arguments may be `None`.  If an error occurs, all\n *  non-`None` size arguments will be set to zero.\n *\n *  @param[in] window The window whose framebuffer to query.\n *  @param[out] width Where to store the width, in pixels, of the framebuffer,\n *  or `None`.\n *  @param[out] height Where to store the height, in pixels, of the framebuffer,\n *  or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_fbsize\n *  @sa @ref glfwSetFramebufferSizeCallback\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("get_window_frame_size",
        [](GLFWwindow * window, BoxedInt & left, BoxedInt & top, BoxedInt & right, BoxedInt & bottom)
        {
            auto glfwGetWindowFrameSize_adapt_modifiable_immutable = [](GLFWwindow * window, BoxedInt & left, BoxedInt & top, BoxedInt & right, BoxedInt & bottom)
            {
                int * left_boxed_value = & (left.value);
                int * top_boxed_value = & (top.value);
                int * right_boxed_value = & (right.value);
                int * bottom_boxed_value = & (bottom.value);

                glfwGetWindowFrameSize(window, left_boxed_value, top_boxed_value, right_boxed_value, bottom_boxed_value);
            };

            glfwGetWindowFrameSize_adapt_modifiable_immutable(window, left, top, right, bottom);
        },
        py::arg("window"), py::arg("left"), py::arg("top"), py::arg("right"), py::arg("bottom"),
        "! @brief Retrieves the size of the frame of the window.\n *\n *  This function retrieves the size, in screen coordinates, of each edge of the\n *  frame of the specified window.  This size includes the title bar, if the\n *  window has one.  The size of the frame may vary depending on the\n *  [window-related hints](@ref window_hints_wnd) used to create it.\n *\n *  Because this function retrieves the size of each window frame edge and not\n *  the offset along a particular coordinate axis, the retrieved values will\n *  always be zero or positive.\n *\n *  Any or all of the size arguments may be `None`.  If an error occurs, all\n *  non-`None` size arguments will be set to zero.\n *\n *  @param[in] window The window whose frame size to query.\n *  @param[out] left Where to store the size, in screen coordinates, of the left\n *  edge of the window frame, or `None`.\n *  @param[out] top Where to store the size, in screen coordinates, of the top\n *  edge of the window frame, or `None`.\n *  @param[out] right Where to store the size, in screen coordinates, of the\n *  right edge of the window frame, or `None`.\n *  @param[out] bottom Where to store the size, in screen coordinates, of the\n *  bottom edge of the window frame, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_size\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup window\n");

    m.def("get_window_content_scale",
        [](GLFWwindow * window, BoxedFloat & xscale, BoxedFloat & yscale)
        {
            auto glfwGetWindowContentScale_adapt_modifiable_immutable = [](GLFWwindow * window, BoxedFloat & xscale, BoxedFloat & yscale)
            {
                float * xscale_boxed_value = & (xscale.value);
                float * yscale_boxed_value = & (yscale.value);

                glfwGetWindowContentScale(window, xscale_boxed_value, yscale_boxed_value);
            };

            glfwGetWindowContentScale_adapt_modifiable_immutable(window, xscale, yscale);
        },
        py::arg("window"), py::arg("xscale"), py::arg("yscale"),
        "! @brief Retrieves the content scale for the specified window.\n *\n *  This function retrieves the content scale for the specified window.  The\n *  content scale is the ratio between the current DPI and the platform's\n *  default DPI.  This is especially important for text and any UI elements.  If\n *  the pixel dimensions of your UI scaled by this look appropriate on your\n *  machine then it should appear at a reasonable size on other machines\n *  regardless of their DPI and scaling settings.  This relies on the system DPI\n *  and scaling settings being somewhat correct.\n *\n *  On platforms where each monitors can have its own content scale, the window\n *  content scale will depend on which monitor the system considers the window\n *  to be on.\n *\n *  @param[in] window The window to query.\n *  @param[out] xscale Where to store the x-axis content scale, or `None`.\n *  @param[out] yscale Where to store the y-axis content scale, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_scale\n *  @sa @ref glfwSetWindowContentScaleCallback\n *  @sa @ref glfwGetMonitorContentScale\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n");

    m.def("get_window_opacity",
        glfwGetWindowOpacity,
        py::arg("window"),
        "! @brief Returns the opacity of the whole window.\n *\n *  This function returns the opacity of the window, including any decorations.\n *\n *  The opacity (or alpha) value is a positive finite number between zero and\n *  one, where zero is fully transparent and one is fully opaque.  If the system\n *  does not support whole window transparency, this function always returns one.\n *\n *  The initial opacity value for newly created windows is one.\n *\n *  @param[in] window The window to query.\n *  @return The opacity value of the specified window.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_transparency\n *  @sa @ref glfwSetWindowOpacity\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n");

    m.def("set_window_opacity",
        glfwSetWindowOpacity,
        py::arg("window"), py::arg("opacity"),
        "! @brief Sets the opacity of the whole window.\n *\n *  This function sets the opacity of the window, including any decorations.\n *\n *  The opacity (or alpha) value is a positive finite number between zero and\n *  one, where zero is fully transparent and one is fully opaque.\n *\n *  The initial opacity value for newly created windows is one.\n *\n *  A window created with framebuffer transparency may not use whole window\n *  transparency.  The results of doing this are undefined.\n *\n *  @param[in] window The window to set the opacity for.\n *  @param[in] opacity The desired opacity of the specified window.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_PLATFORM_ERROR and @ref GLFW_FEATURE_UNAVAILABLE (see remarks).\n *\n *  @remark @wayland There is no way to set an opacity factor for a window.\n *  This function will emit @ref GLFW_FEATURE_UNAVAILABLE.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_transparency\n *  @sa @ref glfwGetWindowOpacity\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n");

    m.def("iconify_window",
        glfwIconifyWindow,
        py::arg("window"),
        "! @brief Iconifies the specified window.\n *\n *  This function iconifies (minimizes) the specified window if it was\n *  previously restored.  If the window is already iconified, this function does\n *  nothing.\n *\n *  If the specified window is a full screen window, the original monitor\n *  resolution is restored until the window is restored.\n *\n *  @param[in] window The window to iconify.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland Once a window is iconified, @ref glfwRestoreWindow wont\n *  be able to restore it.  This is a design decision of the xdg-shell\n *  protocol.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_iconify\n *  @sa @ref glfwRestoreWindow\n *  @sa @ref glfwMaximizeWindow\n *\n *  @since Added in version 2.1.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n");

    m.def("restore_window",
        glfwRestoreWindow,
        py::arg("window"),
        "! @brief Restores the specified window.\n *\n *  This function restores the specified window if it was previously iconified\n *  (minimized) or maximized.  If the window is already restored, this function\n *  does nothing.\n *\n *  If the specified window is a full screen window, the resolution chosen for\n *  the window is restored on the selected monitor.\n *\n *  @param[in] window The window to restore.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_iconify\n *  @sa @ref glfwIconifyWindow\n *  @sa @ref glfwMaximizeWindow\n *\n *  @since Added in version 2.1.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n");

    m.def("maximize_window",
        glfwMaximizeWindow,
        py::arg("window"),
        "! @brief Maximizes the specified window.\n *\n *  This function maximizes the specified window if it was previously not\n *  maximized.  If the window is already maximized, this function does nothing.\n *\n *  If the specified window is a full screen window, this function does nothing.\n *\n *  @param[in] window The window to maximize.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @par Thread Safety\n *  This function may only be called from the main thread.\n *\n *  @sa @ref window_iconify\n *  @sa @ref glfwIconifyWindow\n *  @sa @ref glfwRestoreWindow\n *\n *  @since Added in GLFW 3.2.\n *\n *  @ingroup window\n");

    m.def("show_window",
        glfwShowWindow,
        py::arg("window"),
        "! @brief Makes the specified window visible.\n *\n *  This function makes the specified window visible if it was previously\n *  hidden.  If the window is already visible or is in full screen mode, this\n *  function does nothing.\n *\n *  By default, windowed mode windows are focused when shown\n *  Set the [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) window hint\n *  to change this behavior for all newly created windows, or change the\n *  behavior for an existing window with @ref glfwSetWindowAttrib.\n *\n *  @param[in] window The window to make visible.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland Because Wayland wants every frame of the desktop to be\n *  complete, this function does not immediately make the window visible.\n *  Instead it will become visible the next time the window framebuffer is\n *  updated after this call.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hide\n *  @sa @ref glfwHideWindow\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("hide_window",
        glfwHideWindow,
        py::arg("window"),
        "! @brief Hides the specified window.\n *\n *  This function hides the specified window if it was previously visible.  If\n *  the window is already hidden or is in full screen mode, this function does\n *  nothing.\n *\n *  @param[in] window The window to hide.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_hide\n *  @sa @ref glfwShowWindow\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("focus_window",
        glfwFocusWindow,
        py::arg("window"),
        "! @brief Brings the specified window to front and sets input focus.\n *\n *  This function brings the specified window to front and sets input focus.\n *  The window should already be visible and not iconified.\n *\n *  By default, both windowed and full screen mode windows are focused when\n *  initially created.  Set the [GLFW_FOCUSED](@ref GLFW_FOCUSED_hint) to\n *  disable this behavior.\n *\n *  Also by default, windowed mode windows are focused when shown\n *  with @ref glfwShowWindow. Set the\n *  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) to disable this behavior.\n *\n *  __Do not use this function__ to steal focus from other applications unless\n *  you are certain that is what the user wants.  Focus stealing can be\n *  extremely disruptive.\n *\n *  For a less disruptive way of getting the user's attention, see\n *  [attention requests](@ref window_attention).\n *\n *  @param[in] window The window to give input focus.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_PLATFORM_ERROR and @ref GLFW_FEATURE_UNAVAILABLE (see remarks).\n *\n *  @remark @wayland It is not possible for an application to set the input\n *  focus.  This function will emit @ref GLFW_FEATURE_UNAVAILABLE.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_focus\n *  @sa @ref window_attention\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n");

    m.def("request_window_attention",
        glfwRequestWindowAttention,
        py::arg("window"),
        "! @brief Requests user attention to the specified window.\n *\n *  This function requests user attention to the specified window.  On\n *  platforms where this is not supported, attention is requested to the\n *  application as a whole.\n *\n *  Once the user has given attention, usually by focusing the window or\n *  application, the system will end the request automatically.\n *\n *  @param[in] window The window to request attention to.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @macos Attention is requested to the application as a whole, not the\n *  specific window.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_attention\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n");

    m.def("get_window_monitor",
        glfwGetWindowMonitor,
        py::arg("window"),
        "! @brief Returns the monitor that the window uses for full screen mode.\n *\n *  This function returns the handle of the monitor that the specified window is\n *  in full screen on.\n *\n *  @param[in] window The window to query.\n *  @return The monitor, or `None` if the window is in windowed mode or an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_monitor\n *  @sa @ref glfwSetWindowMonitor\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("set_window_monitor",
        glfwSetWindowMonitor,
        py::arg("window"), py::arg("monitor"), py::arg("xpos"), py::arg("ypos"), py::arg("width"), py::arg("height"), py::arg("refresh_rate"),
        "! @brief Sets the mode, monitor, video mode and placement of a window.\n *\n *  This function sets the monitor that the window uses for full screen mode or,\n *  if the monitor is `None`, makes it windowed mode.\n *\n *  When setting a monitor, this function updates the width, height and refresh\n *  rate of the desired video mode and switches to the video mode closest to it.\n *  The window position is ignored when setting a monitor.\n *\n *  When the monitor is `None`, the position, width and height are used to\n *  place the window content area.  The refresh rate is ignored when no monitor\n *  is specified.\n *\n *  If you only wish to update the resolution of a full screen window or the\n *  size of a windowed mode window, see @ref glfwSetWindowSize.\n *\n *  When a window transitions from full screen to windowed mode, this function\n *  restores any previous window settings such as whether it is decorated,\n *  floating, resizable, has size or aspect ratio limits, etc.\n *\n *  @param[in] window The window whose monitor, size or video mode to set.\n *  @param[in] monitor The desired monitor, or `None` to set windowed mode.\n *  @param[in] xpos The desired x-coordinate of the upper-left corner of the\n *  content area.\n *  @param[in] ypos The desired y-coordinate of the upper-left corner of the\n *  content area.\n *  @param[in] width The desired with, in screen coordinates, of the content\n *  area or video mode.\n *  @param[in] height The desired height, in screen coordinates, of the content\n *  area or video mode.\n *  @param[in] refreshRate The desired refresh rate, in Hz, of the video mode,\n *  or `GLFW_DONT_CARE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark The OpenGL or OpenGL ES context will not be destroyed or otherwise\n *  affected by any resizing or mode switching, although you may need to update\n *  your viewport if the framebuffer size has changed.\n *\n *  @remark @wayland The desired window position is ignored, as there is no way\n *  for an application to set this property.\n *\n *  @remark @wayland Setting the window to full screen will not attempt to\n *  change the mode, no matter what the requested size or refresh rate.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_monitor\n *  @sa @ref window_full_screen\n *  @sa @ref glfwGetWindowMonitor\n *  @sa @ref glfwSetWindowSize\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n");

    m.def("get_window_attrib",
        glfwGetWindowAttrib,
        py::arg("window"), py::arg("attrib"),
        "! @brief Returns an attribute of the specified window.\n *\n *  This function returns the value of an attribute of the specified window or\n *  its OpenGL or OpenGL ES context.\n *\n *  @param[in] window The window to query.\n *  @param[in] attrib The [window attribute](@ref window_attribs) whose value to\n *  return.\n *  @return The value of the attribute, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark Framebuffer related hints are not window attributes.  See @ref\n *  window_attribs_fb for more information.\n *\n *  @remark Zero is a valid value for many window and context related\n *  attributes so you cannot use a return value of zero as an indication of\n *  errors.  However, this function should not fail as long as it is passed\n *  valid arguments and the library has been [initialized](@ref intro_init).\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_attribs\n *  @sa @ref glfwSetWindowAttrib\n *\n *  @since Added in version 3.0.  Replaces `glfwGetWindowParam` and\n *  `glfwGetGLVersion`.\n *\n *  @ingroup window\n");

    m.def("set_window_attrib",
        glfwSetWindowAttrib,
        py::arg("window"), py::arg("attrib"), py::arg("value"),
        "! @brief Sets an attribute of the specified window.\n *\n *  This function sets the value of an attribute of the specified window.\n *\n *  The supported attributes are [GLFW_DECORATED](@ref GLFW_DECORATED_attrib),\n *  [GLFW_RESIZABLE](@ref GLFW_RESIZABLE_attrib),\n *  [GLFW_FLOATING](@ref GLFW_FLOATING_attrib),\n *  [GLFW_AUTO_ICONIFY](@ref GLFW_AUTO_ICONIFY_attrib) and\n *  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_attrib).\n *  [GLFW_MOUSE_PASSTHROUGH](@ref GLFW_MOUSE_PASSTHROUGH_attrib)\n *\n *  Some of these attributes are ignored for full screen windows.  The new\n *  value will take effect if the window is later made windowed.\n *\n *  Some of these attributes are ignored for windowed mode windows.  The new\n *  value will take effect if the window is later made full screen.\n *\n *  @param[in] window The window to set the attribute for.\n *  @param[in] attrib A supported window attribute.\n *  @param[in] value `GLFW_TRUE` or `GLFW_FALSE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark Calling @ref glfwGetWindowAttrib will always return the latest\n *  value, even if that value is ignored by the current mode of the window.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref window_attribs\n *  @sa @ref glfwGetWindowAttrib\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup window\n");

    m.def("set_window_user_pointer",
        glfwSetWindowUserPointer,
        py::arg("window"), py::arg("pointer"),
        "! @brief Sets the user pointer of the specified window.\n *\n *  This function sets the user-defined pointer of the specified window.  The\n *  current value is retained until the window is destroyed.  The initial value\n *  is `None`.\n *\n *  @param[in] window The window whose pointer to set.\n *  @param[in] pointer The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_userptr\n *  @sa @ref glfwGetWindowUserPointer\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("get_window_user_pointer",
        glfwGetWindowUserPointer,
        py::arg("window"),
        "! @brief Returns the user pointer of the specified window.\n *\n *  This function returns the current value of the user-defined pointer of the\n *  specified window.  The initial value is `None`.\n *\n *  @param[in] window The window whose pointer to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref window_userptr\n *  @sa @ref glfwSetWindowUserPointer\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup window\n");

    m.def("poll_events",
        glfwPollEvents, "! @brief Processes all pending events.\n *\n *  This function processes only those events that are already in the event\n *  queue and then returns immediately.  Processing events will cause the window\n *  and input callbacks associated with those events to be called.\n *\n *  On some platforms, a window move, resize or menu operation will cause event\n *  processing to block.  This is due to how event processing is designed on\n *  those platforms.  You can use the\n *  [window refresh callback](@ref window_refresh) to redraw the contents of\n *  your window when necessary during such operations.\n *\n *  Do not assume that callbacks you set will _only_ be called in response to\n *  event processing functions like this one.  While it is necessary to poll for\n *  events, window systems that require GLFW to register callbacks of its own\n *  can pass events to GLFW in response to many window system function calls.\n *  GLFW will pass those events on to the application callbacks before\n *  returning.\n *\n *  Event processing is not required for joystick input to work.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwWaitEvents\n *  @sa @ref glfwWaitEventsTimeout\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup window\n");

    m.def("wait_events",
        glfwWaitEvents, "! @brief Waits until events are queued and processes them.\n *\n *  This function puts the calling thread to sleep until at least one event is\n *  available in the event queue.  Once one or more events are available,\n *  it behaves exactly like @ref glfwPollEvents, i.e. the events in the queue\n *  are processed and the function then returns immediately.  Processing events\n *  will cause the window and input callbacks associated with those events to be\n *  called.\n *\n *  Since not all events are associated with callbacks, this function may return\n *  without a callback having been called even if you are monitoring all\n *  callbacks.\n *\n *  On some platforms, a window move, resize or menu operation will cause event\n *  processing to block.  This is due to how event processing is designed on\n *  those platforms.  You can use the\n *  [window refresh callback](@ref window_refresh) to redraw the contents of\n *  your window when necessary during such operations.\n *\n *  Do not assume that callbacks you set will _only_ be called in response to\n *  event processing functions like this one.  While it is necessary to poll for\n *  events, window systems that require GLFW to register callbacks of its own\n *  can pass events to GLFW in response to many window system function calls.\n *  GLFW will pass those events on to the application callbacks before\n *  returning.\n *\n *  Event processing is not required for joystick input to work.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwPollEvents\n *  @sa @ref glfwWaitEventsTimeout\n *\n *  @since Added in version 2.5.\n *\n *  @ingroup window\n");

    m.def("wait_events_timeout",
        glfwWaitEventsTimeout,
        py::arg("timeout"),
        "! @brief Waits with timeout until events are queued and processes them.\n *\n *  This function puts the calling thread to sleep until at least one event is\n *  available in the event queue, or until the specified timeout is reached.  If\n *  one or more events are available, it behaves exactly like @ref\n *  glfwPollEvents, i.e. the events in the queue are processed and the function\n *  then returns immediately.  Processing events will cause the window and input\n *  callbacks associated with those events to be called.\n *\n *  The timeout value must be a positive finite number.\n *\n *  Since not all events are associated with callbacks, this function may return\n *  without a callback having been called even if you are monitoring all\n *  callbacks.\n *\n *  On some platforms, a window move, resize or menu operation will cause event\n *  processing to block.  This is due to how event processing is designed on\n *  those platforms.  You can use the\n *  [window refresh callback](@ref window_refresh) to redraw the contents of\n *  your window when necessary during such operations.\n *\n *  Do not assume that callbacks you set will _only_ be called in response to\n *  event processing functions like this one.  While it is necessary to poll for\n *  events, window systems that require GLFW to register callbacks of its own\n *  can pass events to GLFW in response to many window system function calls.\n *  GLFW will pass those events on to the application callbacks before\n *  returning.\n *\n *  Event processing is not required for joystick input to work.\n *\n *  @param[in] timeout The maximum amount of time, in seconds, to wait.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwPollEvents\n *  @sa @ref glfwWaitEvents\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup window\n");

    m.def("post_empty_event",
        glfwPostEmptyEvent, "! @brief Posts an empty event to the event queue.\n *\n *  This function posts an empty event from the current thread to the event\n *  queue, causing @ref glfwWaitEvents or @ref glfwWaitEventsTimeout to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref events\n *  @sa @ref glfwWaitEvents\n *  @sa @ref glfwWaitEventsTimeout\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup window\n");

    m.def("get_input_mode",
        glfwGetInputMode,
        py::arg("window"), py::arg("mode"),
        "! @brief Returns the value of an input option for the specified window.\n *\n *  This function returns the value of an input option for the specified window.\n *  The mode must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,\n *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or\n *  @ref GLFW_RAW_MOUSE_MOTION.\n *\n *  @param[in] window The window to query.\n *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,\n *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or\n *  `GLFW_RAW_MOUSE_MOTION`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref glfwSetInputMode\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n");

    m.def("set_input_mode",
        glfwSetInputMode,
        py::arg("window"), py::arg("mode"), py::arg("value"),
        "! @brief Sets an input option for the specified window.\n *\n *  This function sets an input mode option for the specified window.  The mode\n *  must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,\n *  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or\n *  @ref GLFW_RAW_MOUSE_MOTION.\n *\n *  If the mode is `GLFW_CURSOR`, the value must be one of the following cursor\n *  modes:\n *  - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.\n *  - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the\n *    content area of the window but does not restrict the cursor from leaving.\n *  - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual\n *    and unlimited cursor movement.  This is useful for implementing for\n *    example 3D camera controls.\n *\n *  If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to\n *  enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are\n *  enabled, a key press will ensure that @ref glfwGetKey returns `GLFW_PRESS`\n *  the next time it is called even if the key had been released before the\n *  call.  This is useful when you are only interested in whether keys have been\n *  pressed but not when or in which order.\n *\n *  If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either\n *  `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.\n *  If sticky mouse buttons are enabled, a mouse button press will ensure that\n *  @ref glfwGetMouseButton returns `GLFW_PRESS` the next time it is called even\n *  if the mouse button had been released before the call.  This is useful when\n *  you are only interested in whether mouse buttons have been pressed but not\n *  when or in which order.\n *\n *  If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to\n *  enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,\n *  callbacks that receive modifier bits will also have the @ref\n *  GLFW_MOD_CAPS_LOCK bit set when the event was generated with Caps Lock on,\n *  and the @ref GLFW_MOD_NUM_LOCK bit when Num Lock was on.\n *\n *  If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`\n *  to enable raw (unscaled and unaccelerated) mouse motion when the cursor is\n *  disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,\n *  attempting to set this will emit @ref GLFW_FEATURE_UNAVAILABLE.  Call @ref\n *  glfwRawMouseMotionSupported to check for support.\n *\n *  @param[in] window The window whose input mode to set.\n *  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,\n *  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or\n *  `GLFW_RAW_MOUSE_MOTION`.\n *  @param[in] value The new value of the specified input mode.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM, @ref GLFW_PLATFORM_ERROR and @ref\n *  GLFW_FEATURE_UNAVAILABLE (see above).\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref glfwGetInputMode\n *\n *  @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.\n *\n *  @ingroup input\n");

    m.def("raw_mouse_motion_supported",
        glfwRawMouseMotionSupported, "! @brief Returns whether raw mouse motion is supported.\n *\n *  This function returns whether raw mouse motion is supported on the current\n *  system.  This status does not change after GLFW has been initialized so you\n *  only need to check this once.  If you attempt to enable raw motion on\n *  a system that does not support it, @ref GLFW_PLATFORM_ERROR will be emitted.\n *\n *  Raw mouse motion is closer to the actual motion of the mouse across\n *  a surface.  It is not affected by the scaling and acceleration applied to\n *  the motion of the desktop cursor.  That processing is suitable for a cursor\n *  while raw motion is better for controlling for example a 3D camera.  Because\n *  of this, raw mouse motion is only provided when the cursor is disabled.\n *\n *  @return `GLFW_TRUE` if raw mouse motion is supported on the current machine,\n *  or `GLFW_FALSE` otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref raw_mouse_motion\n *  @sa @ref glfwSetInputMode\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("get_key_name",
        glfwGetKeyName,
        py::arg("key"), py::arg("scancode"),
        "! @brief Returns the layout-specific name of the specified printable key.\n *\n *  This function returns the name of the specified printable key, encoded as\n *  UTF-8.  This is typically the character that key would produce without any\n *  modifier keys, intended for displaying key bindings to the user.  For dead\n *  keys, it is typically the diacritic it would add to a character.\n *\n *  __Do not use this function__ for [text input](@ref input_char).  You will\n *  break text input for many languages even if it happens to work for yours.\n *\n *  If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,\n *  otherwise the scancode is ignored.  If you specify a non-printable key, or\n *  `GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this\n *  function returns `None` but does not emit an error.\n *\n *  This behavior allows you to always pass in the arguments in the\n *  [key callback](@ref input_key) without modification.\n *\n *  The printable keys are:\n *  - `GLFW_KEY_APOSTROPHE`\n *  - `GLFW_KEY_COMMA`\n *  - `GLFW_KEY_MINUS`\n *  - `GLFW_KEY_PERIOD`\n *  - `GLFW_KEY_SLASH`\n *  - `GLFW_KEY_SEMICOLON`\n *  - `GLFW_KEY_EQUAL`\n *  - `GLFW_KEY_LEFT_BRACKET`\n *  - `GLFW_KEY_RIGHT_BRACKET`\n *  - `GLFW_KEY_BACKSLASH`\n *  - `GLFW_KEY_WORLD_1`\n *  - `GLFW_KEY_WORLD_2`\n *  - `GLFW_KEY_0` to `GLFW_KEY_9`\n *  - `GLFW_KEY_A` to `GLFW_KEY_Z`\n *  - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`\n *  - `GLFW_KEY_KP_DECIMAL`\n *  - `GLFW_KEY_KP_DIVIDE`\n *  - `GLFW_KEY_KP_MULTIPLY`\n *  - `GLFW_KEY_KP_SUBTRACT`\n *  - `GLFW_KEY_KP_ADD`\n *  - `GLFW_KEY_KP_EQUAL`\n *\n *  Names for printable keys depend on keyboard layout, while names for\n *  non-printable keys are the same across layouts but depend on the application\n *  language and should be localized along with other user interface text.\n *\n *  @param[in] key The key to query, or `GLFW_KEY_UNKNOWN`.\n *  @param[in] scancode The scancode of the key to query.\n *  @return The UTF-8 encoded, layout-specific name of the key, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark The contents of the returned string may change when a keyboard\n *  layout change event is received.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_key_name\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup input\n");

    m.def("get_key_scancode",
        glfwGetKeyScancode,
        py::arg("key"),
        "! @brief Returns the platform-specific scancode of the specified key.\n *\n *  This function returns the platform-specific scancode of the specified key.\n *\n *  If the key is `GLFW_KEY_UNKNOWN` or does not exist on the keyboard this\n *  method will return `-1`.\n *\n *  @param[in] key Any [named key](@ref keys).\n *  @return The platform-specific scancode for the key, or `-1` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref input_key\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("get_key",
        glfwGetKey,
        py::arg("window"), py::arg("key"),
        "! @brief Returns the last reported state of a keyboard key for the specified\n *  window.\n *\n *  This function returns the last state reported for the specified key to the\n *  specified window.  The returned state is one of `GLFW_PRESS` or\n *  `GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to\n *  the key callback.\n *\n *  If the @ref GLFW_STICKY_KEYS input mode is enabled, this function returns\n *  `GLFW_PRESS` the first time you call it for a key that was pressed, even if\n *  that key has already been released.\n *\n *  The key functions deal with physical keys, with [key tokens](@ref keys)\n *  named after their use on the standard US keyboard layout.  If you want to\n *  input text, use the Unicode character callback instead.\n *\n *  The [modifier key bit masks](@ref mods) are not key tokens and cannot be\n *  used with this function.\n *\n *  __Do not use this function__ to implement [text input](@ref input_char).\n *\n *  @param[in] window The desired window.\n *  @param[in] key The desired [keyboard key](@ref keys).  `GLFW_KEY_UNKNOWN` is\n *  not a valid key for this function.\n *  @return One of `GLFW_PRESS` or `GLFW_RELEASE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_key\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup input\n");

    m.def("get_mouse_button",
        glfwGetMouseButton,
        py::arg("window"), py::arg("button"),
        "! @brief Returns the last reported state of a mouse button for the specified\n *  window.\n *\n *  This function returns the last state reported for the specified mouse button\n *  to the specified window.  The returned state is one of `GLFW_PRESS` or\n *  `GLFW_RELEASE`.\n *\n *  If the @ref GLFW_STICKY_MOUSE_BUTTONS input mode is enabled, this function\n *  returns `GLFW_PRESS` the first time you call it for a mouse button that was\n *  pressed, even if that mouse button has already been released.\n *\n *  @param[in] window The desired window.\n *  @param[in] button The desired [mouse button](@ref buttons).\n *  @return One of `GLFW_PRESS` or `GLFW_RELEASE`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref input_mouse_button\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup input\n");

    m.def("get_cursor_pos",
        [](GLFWwindow * window, BoxedDouble & xpos, BoxedDouble & ypos)
        {
            auto glfwGetCursorPos_adapt_modifiable_immutable = [](GLFWwindow * window, BoxedDouble & xpos, BoxedDouble & ypos)
            {
                double * xpos_boxed_value = & (xpos.value);
                double * ypos_boxed_value = & (ypos.value);

                glfwGetCursorPos(window, xpos_boxed_value, ypos_boxed_value);
            };

            glfwGetCursorPos_adapt_modifiable_immutable(window, xpos, ypos);
        },
        py::arg("window"), py::arg("xpos"), py::arg("ypos"),
        "! @brief Retrieves the position of the cursor relative to the content area of\n *  the window.\n *\n *  This function returns the position of the cursor, in screen coordinates,\n *  relative to the upper-left corner of the content area of the specified\n *  window.\n *\n *  If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor\n *  position is unbounded and limited only by the minimum and maximum values of\n *  a `double`.\n *\n *  The coordinate can be converted to their integer equivalents with the\n *  `floor` function.  Casting directly to an integer type works for positive\n *  coordinates, but fails for negative ones.\n *\n *  Any or all of the position arguments may be `None`.  If an error occurs, all\n *  non-`None` position arguments will be set to zero.\n *\n *  @param[in] window The desired window.\n *  @param[out] xpos Where to store the cursor x-coordinate, relative to the\n *  left edge of the content area, or `None`.\n *  @param[out] ypos Where to store the cursor y-coordinate, relative to the to\n *  top edge of the content area, or `None`.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_pos\n *  @sa @ref glfwSetCursorPos\n *\n *  @since Added in version 3.0.  Replaces `glfwGetMousePos`.\n *\n *  @ingroup input\n");

    m.def("set_cursor_pos",
        glfwSetCursorPos,
        py::arg("window"), py::arg("xpos"), py::arg("ypos"),
        "! @brief Sets the position of the cursor, relative to the content area of the\n *  window.\n *\n *  This function sets the position, in screen coordinates, of the cursor\n *  relative to the upper-left corner of the content area of the specified\n *  window.  The window must have input focus.  If the window does not have\n *  input focus when this function is called, it fails silently.\n *\n *  __Do not use this function__ to implement things like camera controls.  GLFW\n *  already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the\n *  cursor, transparently re-centers it and provides unconstrained cursor\n *  motion.  See @ref glfwSetInputMode for more information.\n *\n *  If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is\n *  unconstrained and limited only by the minimum and maximum values of\n *  a `double`.\n *\n *  @param[in] window The desired window.\n *  @param[in] xpos The desired x-coordinate, relative to the left edge of the\n *  content area.\n *  @param[in] ypos The desired y-coordinate, relative to the top edge of the\n *  content area.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @remark @wayland This function will only work when the cursor mode is\n *  `GLFW_CURSOR_DISABLED`, otherwise it will do nothing.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_pos\n *  @sa @ref glfwGetCursorPos\n *\n *  @since Added in version 3.0.  Replaces `glfwSetMousePos`.\n *\n *  @ingroup input\n");

    m.def("create_cursor",
        glfwCreateCursor,
        py::arg("image"), py::arg("xhot"), py::arg("yhot"),
        "! @brief Creates a custom cursor.\n *\n *  Creates a new custom cursor image that can be set for a window with @ref\n *  glfwSetCursor.  The cursor can be destroyed with @ref glfwDestroyCursor.\n *  Any remaining cursors are destroyed by @ref glfwTerminate.\n *\n *  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight\n *  bits per channel with the red channel first.  They are arranged canonically\n *  as packed sequential rows, starting from the top-left corner.\n *\n *  The cursor hotspot is specified in pixels, relative to the upper-left corner\n *  of the cursor image.  Like all other coordinate systems in GLFW, the X-axis\n *  points to the right and the Y-axis points down.\n *\n *  @param[in] image The desired cursor image.\n *  @param[in] xhot The desired x-coordinate, in pixels, of the cursor hotspot.\n *  @param[in] yhot The desired y-coordinate, in pixels, of the cursor hotspot.\n *  @return The handle of the created cursor, or `None` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The specified image data is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_object\n *  @sa @ref glfwDestroyCursor\n *  @sa @ref glfwCreateStandardCursor\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n");

    m.def("create_standard_cursor",
        glfwCreateStandardCursor,
        py::arg("shape"),
        "! @brief Creates a cursor with a standard shape.\n *\n *  Returns a cursor with a standard shape, that can be set for a window with\n *  @ref glfwSetCursor.  The images for these cursors come from the system\n *  cursor theme and their exact appearance will vary between platforms.\n *\n *  Most of these shapes are guaranteed to exist on every supported platform but\n *  a few may not be present.  See the table below for details.\n *\n *  Cursor shape                   | Windows | macOS | X11    | Wayland\n *  ------------------------------ | ------- | ----- | ------ | -------\n *  @ref GLFW_ARROW_CURSOR         | Yes     | Yes   | Yes    | Yes\n *  @ref GLFW_IBEAM_CURSOR         | Yes     | Yes   | Yes    | Yes\n *  @ref GLFW_CROSSHAIR_CURSOR     | Yes     | Yes   | Yes    | Yes\n *  @ref GLFW_POINTING_HAND_CURSOR | Yes     | Yes   | Yes    | Yes\n *  @ref GLFW_RESIZE_EW_CURSOR     | Yes     | Yes   | Yes    | Yes\n *  @ref GLFW_RESIZE_NS_CURSOR     | Yes     | Yes   | Yes    | Yes\n *  @ref GLFW_RESIZE_NWSE_CURSOR   | Yes     | Yes<sup>1</sup> | Maybe<sup>2</sup> | Maybe<sup>2</sup>\n *  @ref GLFW_RESIZE_NESW_CURSOR   | Yes     | Yes<sup>1</sup> | Maybe<sup>2</sup> | Maybe<sup>2</sup>\n *  @ref GLFW_RESIZE_ALL_CURSOR    | Yes     | Yes   | Yes    | Yes\n *  @ref GLFW_NOT_ALLOWED_CURSOR   | Yes     | Yes   | Maybe<sup>2</sup> | Maybe<sup>2</sup>\n *\n *  1) This uses a private system API and may fail in the future.\n *\n *  2) This uses a newer standard that not all cursor themes support.\n *\n *  If the requested shape is not available, this function emits a @ref\n *  GLFW_CURSOR_UNAVAILABLE error and returns `None`.\n *\n *  @param[in] shape One of the [standard shapes](@ref shapes).\n *  @return A new cursor ready to use or `None` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM, @ref GLFW_CURSOR_UNAVAILABLE and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_standard\n *  @sa @ref glfwCreateCursor\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n");

    m.def("destroy_cursor",
        glfwDestroyCursor,
        py::arg("cursor"),
        "! @brief Destroys a cursor.\n *\n *  This function destroys a cursor previously created with @ref\n *  glfwCreateCursor.  Any remaining cursors will be destroyed by @ref\n *  glfwTerminate.\n *\n *  If the specified cursor is current for any window, that window will be\n *  reverted to the default cursor.  This does not affect the cursor mode.\n *\n *  @param[in] cursor The cursor object to destroy.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @reentrancy This function must not be called from a callback.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_object\n *  @sa @ref glfwCreateCursor\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n");

    m.def("set_cursor",
        glfwSetCursor,
        py::arg("window"), py::arg("cursor"),
        "! @brief Sets the cursor for the window.\n *\n *  This function sets the cursor image to be used when the cursor is over the\n *  content area of the specified window.  The set cursor will only be visible\n *  when the [cursor mode](@ref cursor_mode) of the window is\n *  `GLFW_CURSOR_NORMAL`.\n *\n *  On some platforms, the set cursor may not be visible unless the window also\n *  has input focus.\n *\n *  @param[in] window The window to set the cursor for.\n *  @param[in] cursor The cursor to set, or `None` to switch back to the default\n *  arrow cursor.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref cursor_object\n *\n *  @since Added in version 3.1.\n *\n *  @ingroup input\n");

    m.def("joystick_present",
        glfwJoystickPresent,
        py::arg("jid"),
        "! @brief Returns whether the specified joystick is present.\n *\n *  This function returns whether the specified joystick is present.\n *\n *  There is no need to call this function before other functions that accept\n *  a joystick ID, as they all check for presence before performing any other\n *  work.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick\n *\n *  @since Added in version 3.0.  Replaces `glfwGetJoystickParam`.\n *\n *  @ingroup input\n");

    m.def("get_joystick_axes",
        [](int jid, BoxedInt & count) -> const float *
        {
            auto glfwGetJoystickAxes_adapt_modifiable_immutable = [](int jid, BoxedInt & count) -> const float *
            {
                int * count_boxed_value = & (count.value);

                auto r = glfwGetJoystickAxes(jid, count_boxed_value);
                return r;
            };

            return glfwGetJoystickAxes_adapt_modifiable_immutable(jid, count);
        },
        py::arg("jid"), py::arg("count"),
        "! @brief Returns the values of all axes of the specified joystick.\n *\n *  This function returns the values of all axes of the specified joystick.\n *  Each element in the array is a value between -1.0 and 1.0.\n *\n *  If the specified joystick is not present this function will return `None`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] count Where to store the number of axis values in the returned\n *  array.  This is set to zero if the joystick is not present or an error\n *  occurred.\n *  @return An array of axis values, or `None` if the joystick is not present or\n *  an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_axis\n *\n *  @since Added in version 3.0.  Replaces `glfwGetJoystickPos`.\n *\n *  @ingroup input\n");

    m.def("get_joystick_buttons",
        [](int jid, BoxedInt & count) -> const unsigned char *
        {
            auto glfwGetJoystickButtons_adapt_modifiable_immutable = [](int jid, BoxedInt & count) -> const unsigned char *
            {
                int * count_boxed_value = & (count.value);

                auto r = glfwGetJoystickButtons(jid, count_boxed_value);
                return r;
            };

            return glfwGetJoystickButtons_adapt_modifiable_immutable(jid, count);
        },
        py::arg("jid"), py::arg("count"),
        "! @brief Returns the state of all buttons of the specified joystick.\n *\n *  This function returns the state of all buttons of the specified joystick.\n *  Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.\n *\n *  For backward compatibility with earlier versions that did not have @ref\n *  glfwGetJoystickHats, the button array also includes all hats, each\n *  represented as four buttons.  The hats are in the same order as returned by\n *  __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and\n *  _left_.  To disable these extra buttons, set the @ref\n *  GLFW_JOYSTICK_HAT_BUTTONS init hint before initialization.\n *\n *  If the specified joystick is not present this function will return `None`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] count Where to store the number of button states in the returned\n *  array.  This is set to zero if the joystick is not present or an error\n *  occurred.\n *  @return An array of button states, or `None` if the joystick is not present\n *  or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_button\n *\n *  @since Added in version 2.2.\n *  @glfw3 Changed to return a dynamic array.\n *\n *  @ingroup input\n");

    m.def("get_joystick_hats",
        [](int jid, BoxedInt & count) -> const unsigned char *
        {
            auto glfwGetJoystickHats_adapt_modifiable_immutable = [](int jid, BoxedInt & count) -> const unsigned char *
            {
                int * count_boxed_value = & (count.value);

                auto r = glfwGetJoystickHats(jid, count_boxed_value);
                return r;
            };

            return glfwGetJoystickHats_adapt_modifiable_immutable(jid, count);
        },
        py::arg("jid"), py::arg("count"),
        "! @brief Returns the state of all hats of the specified joystick.\n *\n *  This function returns the state of all hats of the specified joystick.\n *  Each element in the array is one of the following values:\n *\n *  Name                  | Value\n *  ----                  | -----\n *  `GLFW_HAT_CENTERED`   | 0\n *  `GLFW_HAT_UP`         | 1\n *  `GLFW_HAT_RIGHT`      | 2\n *  `GLFW_HAT_DOWN`       | 4\n *  `GLFW_HAT_LEFT`       | 8\n *  `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` \\| `GLFW_HAT_UP`\n *  `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` \\| `GLFW_HAT_DOWN`\n *  `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` \\| `GLFW_HAT_UP`\n *  `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` \\| `GLFW_HAT_DOWN`\n *\n *  The diagonal directions are bitwise combinations of the primary (up, right,\n *  down and left) directions and you can test for these individually by ANDing\n *  it with the corresponding direction.\n *\n *  @code\n *  if (hats[2] & GLFW_HAT_RIGHT)\n *  {\n *      // State of hat 2 could be right-up, right or right-down\n *  }\n *  @endcode\n *\n *  If the specified joystick is not present this function will return `None`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] count Where to store the number of hat states in the returned\n *  array.  This is set to zero if the joystick is not present or an error\n *  occurred.\n *  @return An array of hat states, or `None` if the joystick is not present\n *  or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned array is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected, this function is called again for that joystick or the library\n *  is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_hat\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("get_joystick_name",
        glfwGetJoystickName,
        py::arg("jid"),
        "! @brief Returns the name of the specified joystick.\n *\n *  This function returns the name, encoded as UTF-8, of the specified joystick.\n *  The returned string is allocated and freed by GLFW.  You should not free it\n *  yourself.\n *\n *  If the specified joystick is not present this function will return `None`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return The UTF-8 encoded name of the joystick, or `None` if the joystick\n *  is not present or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref joystick_name\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n");

    m.def("get_joystick_guid",
        glfwGetJoystickGUID,
        py::arg("jid"),
        "! @brief Returns the SDL compatible GUID of the specified joystick.\n *\n *  This function returns the SDL compatible GUID, as a UTF-8 encoded\n *  hexadecimal string, of the specified joystick.  The returned string is\n *  allocated and freed by GLFW.  You should not free it yourself.\n *\n *  The GUID is what connects a joystick to a gamepad mapping.  A connected\n *  joystick will always have a GUID even if there is no gamepad mapping\n *  assigned to it.\n *\n *  If the specified joystick is not present this function will return `None`\n *  but will not generate an error.  This can be used instead of first calling\n *  @ref glfwJoystickPresent.\n *\n *  The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to\n *  uniquely identify the make and model of a joystick but does not identify\n *  a specific unit, e.g. all wired Xbox 360 controllers will have the same\n *  GUID on that platform.  The GUID for a unit may vary between platforms\n *  depending on what hardware information the platform specific APIs provide.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return The UTF-8 encoded GUID of the joystick, or `None` if the joystick\n *  is not present or an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("set_joystick_user_pointer",
        glfwSetJoystickUserPointer,
        py::arg("jid"), py::arg("pointer"),
        "! @brief Sets the user pointer of the specified joystick.\n *\n *  This function sets the user-defined pointer of the specified joystick.  The\n *  current value is retained until the joystick is disconnected.  The initial\n *  value is `None`.\n *\n *  This function may be called from the joystick callback, even for a joystick\n *  that is being disconnected.\n *\n *  @param[in] jid The joystick whose pointer to set.\n *  @param[in] pointer The new value.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref joystick_userptr\n *  @sa @ref glfwGetJoystickUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("get_joystick_user_pointer",
        glfwGetJoystickUserPointer,
        py::arg("jid"),
        "! @brief Returns the user pointer of the specified joystick.\n *\n *  This function returns the current value of the user-defined pointer of the\n *  specified joystick.  The initial value is `None`.\n *\n *  This function may be called from the joystick callback, even for a joystick\n *  that is being disconnected.\n *\n *  @param[in] jid The joystick whose pointer to return.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Access is not\n *  synchronized.\n *\n *  @sa @ref joystick_userptr\n *  @sa @ref glfwSetJoystickUserPointer\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("joystick_is_gamepad",
        glfwJoystickIsGamepad,
        py::arg("jid"),
        "! @brief Returns whether the specified joystick has a gamepad mapping.\n *\n *  This function returns whether the specified joystick is both present and has\n *  a gamepad mapping.\n *\n *  If the specified joystick is present but does not have a gamepad mapping\n *  this function will return `GLFW_FALSE` but will not generate an error.  Call\n *  @ref glfwJoystickPresent to check if a joystick is present regardless of\n *  whether it has a mapping.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return `GLFW_TRUE` if a joystick is both present and has a gamepad mapping,\n *  or `GLFW_FALSE` otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwGetGamepadState\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("update_gamepad_mappings",
        glfwUpdateGamepadMappings,
        py::arg("string"),
        "! @brief Adds the specified SDL_GameControllerDB gamepad mappings.\n *\n *  This function parses the specified ASCII encoded string and updates the\n *  internal list with any gamepad mappings it finds.  This string may\n *  contain either a single gamepad mapping or many mappings separated by\n *  newlines.  The parser supports the full format of the `gamecontrollerdb.txt`\n *  source file including empty lines and comments.\n *\n *  See @ref gamepad_mapping for a description of the format.\n *\n *  If there is already a gamepad mapping for a given GUID in the internal list,\n *  it will be replaced by the one passed to this function.  If the library is\n *  terminated and re-initialized the internal list will revert to the built-in\n *  default.\n *\n *  @param[in] string The string containing the gamepad mappings.\n *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_VALUE.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwJoystickIsGamepad\n *  @sa @ref glfwGetGamepadName\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("get_gamepad_name",
        glfwGetGamepadName,
        py::arg("jid"),
        "! @brief Returns the human-readable gamepad name for the specified joystick.\n *\n *  This function returns the human-readable name of the gamepad from the\n *  gamepad mapping assigned to the specified joystick.\n *\n *  If the specified joystick is not present or does not have a gamepad mapping\n *  this function will return `None` but will not generate an error.  Call\n *  @ref glfwJoystickPresent to check whether it is present regardless of\n *  whether it has a mapping.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @return The UTF-8 encoded name of the gamepad, or `None` if the\n *  joystick is not present, does not have a mapping or an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref GLFW_INVALID_ENUM.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the specified joystick is\n *  disconnected, the gamepad mappings are updated or the library is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwJoystickIsGamepad\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("get_gamepad_state",
        glfwGetGamepadState,
        py::arg("jid"), py::arg("state"),
        "! @brief Retrieves the state of the specified joystick remapped as a gamepad.\n *\n *  This function retrieves the state of the specified joystick remapped to\n *  an Xbox-like gamepad.\n *\n *  If the specified joystick is not present or does not have a gamepad mapping\n *  this function will return `GLFW_FALSE` but will not generate an error.  Call\n *  @ref glfwJoystickPresent to check whether it is present regardless of\n *  whether it has a mapping.\n *\n *  The Guide button may not be available for input as it is often hooked by the\n *  system or the Steam client.\n *\n *  Not all devices have all the buttons or axes provided by @ref\n *  GLFWgamepadstate.  Unavailable buttons and axes will always report\n *  `GLFW_RELEASE` and 0.0 respectively.\n *\n *  @param[in] jid The [joystick](@ref joysticks) to query.\n *  @param[out] state The gamepad input state of the joystick.\n *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is\n *  connected, it has no gamepad mapping or an [error](@ref error_handling)\n *  occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_ENUM.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref gamepad\n *  @sa @ref glfwUpdateGamepadMappings\n *  @sa @ref glfwJoystickIsGamepad\n *\n *  @since Added in version 3.3.\n *\n *  @ingroup input\n");

    m.def("set_clipboard_string",
        glfwSetClipboardString,
        py::arg("window"), py::arg("string"),
        "! @brief Sets the clipboard to the specified string.\n *\n *  This function sets the system clipboard to the specified, UTF-8 encoded\n *  string.\n *\n *  @param[in] window Deprecated.  Any valid window or `None`.\n *  @param[in] string A UTF-8 encoded string.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The specified string is copied before this function\n *  returns.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref clipboard\n *  @sa @ref glfwGetClipboardString\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n");

    m.def("get_clipboard_string",
        glfwGetClipboardString,
        py::arg("window"),
        "! @brief Returns the contents of the clipboard as a string.\n *\n *  This function returns the contents of the system clipboard, if it contains\n *  or is convertible to a UTF-8 encoded string.  If the clipboard is empty or\n *  if its contents cannot be converted, `None` is returned and a @ref\n *  GLFW_FORMAT_UNAVAILABLE error is generated.\n *\n *  @param[in] window Deprecated.  Any valid window or `None`.\n *  @return The contents of the clipboard as a UTF-8 encoded string, or `None`\n *  if an [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_FORMAT_UNAVAILABLE and @ref GLFW_PLATFORM_ERROR.\n *\n *  @pointer_lifetime The returned string is allocated and freed by GLFW.  You\n *  should not free it yourself.  It is valid until the next call to @ref\n *  glfwGetClipboardString or @ref glfwSetClipboardString, or until the library\n *  is terminated.\n *\n *  @thread_safety This function must only be called from the main thread.\n *\n *  @sa @ref clipboard\n *  @sa @ref glfwSetClipboardString\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup input\n");

    m.def("get_time",
        glfwGetTime, "! @brief Returns the GLFW time.\n *\n *  This function returns the current GLFW time, in seconds.  Unless the time\n *  has been set using @ref glfwSetTime it measures time elapsed since GLFW was\n *  initialized.\n *\n *  This function and @ref glfwSetTime are helper functions on top of @ref\n *  glfwGetTimerFrequency and @ref glfwGetTimerValue.\n *\n *  The resolution of the timer is system dependent, but is usually on the order\n *  of a few micro- or nanoseconds.  It uses the highest-resolution monotonic\n *  time source on each operating system.\n *\n *  @return The current time, in seconds, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.  Reading and\n *  writing of the internal base time is not atomic, so it needs to be\n *  externally synchronized with calls to @ref glfwSetTime.\n *\n *  @sa @ref time\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup input\n");

    m.def("set_time",
        glfwSetTime,
        py::arg("time"),
        "! @brief Sets the GLFW time.\n *\n *  This function sets the current GLFW time, in seconds.  The value must be\n *  a positive finite number less than or equal to 18446744073.0, which is\n *  approximately 584.5 years.\n *\n *  This function and @ref glfwGetTime are helper functions on top of @ref\n *  glfwGetTimerFrequency and @ref glfwGetTimerValue.\n *\n *  @param[in] time The new value, in seconds.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref\n *  GLFW_INVALID_VALUE.\n *\n *  @remark The upper limit of GLFW time is calculated as\n *  floor((2<sup>64</sup> - 1) / 10<sup>9</sup>) and is due to implementations\n *  storing nanoseconds in 64 bits.  The limit may be increased in the future.\n *\n *  @thread_safety This function may be called from any thread.  Reading and\n *  writing of the internal base time is not atomic, so it needs to be\n *  externally synchronized with calls to @ref glfwGetTime.\n *\n *  @sa @ref time\n *\n *  @since Added in version 2.2.\n *\n *  @ingroup input\n");

    m.def("get_timer_value",
        glfwGetTimerValue, "! @brief Returns the current value of the raw timer.\n *\n *  This function returns the current value of the raw timer, measured in\n *  1&nbsp;/&nbsp;frequency seconds.  To get the frequency, call @ref\n *  glfwGetTimerFrequency.\n *\n *  @return The value of the timer, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref time\n *  @sa @ref glfwGetTimerFrequency\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup input\n");

    m.def("get_timer_frequency",
        glfwGetTimerFrequency, "! @brief Returns the frequency, in Hz, of the raw timer.\n *\n *  This function returns the frequency, in Hz, of the raw timer.\n *\n *  @return The frequency of the timer, in Hz, or zero if an\n *  [error](@ref error_handling) occurred.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref time\n *  @sa @ref glfwGetTimerValue\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup input\n");

    m.def("make_context_current",
        glfwMakeContextCurrent,
        py::arg("window"),
        "! @brief Makes the context of the specified window current for the calling\n *  thread.\n *\n *  This function makes the OpenGL or OpenGL ES context of the specified window\n *  current on the calling thread.  A context must only be made current on\n *  a single thread at a time and each thread can have only a single current\n *  context at a time.\n *\n *  When moving a context between threads, you must make it non-current on the\n *  old thread before making it current on the new one.\n *\n *  By default, making a context non-current implicitly forces a pipeline flush.\n *  On machines that support `GL_KHR_context_flush_control`, you can control\n *  whether a context performs this flush by setting the\n *  [GLFW_CONTEXT_RELEASE_BEHAVIOR](@ref GLFW_CONTEXT_RELEASE_BEHAVIOR_hint)\n *  hint.\n *\n *  The specified window must have an OpenGL or OpenGL ES context.  Specifying\n *  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT\n *  error.\n *\n *  @param[in] window The window whose context to make current, or `None` to\n *  detach the current context.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref context_current\n *  @sa @ref glfwGetCurrentContext\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup context\n");

    m.def("get_current_context",
        glfwGetCurrentContext, "! @brief Returns the window whose context is current on the calling thread.\n *\n *  This function returns the window whose OpenGL or OpenGL ES context is\n *  current on the calling thread.\n *\n *  @return The window whose context is current, or `None` if no window's\n *  context is current.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref context_current\n *  @sa @ref glfwMakeContextCurrent\n *\n *  @since Added in version 3.0.\n *\n *  @ingroup context\n");

    m.def("swap_buffers",
        glfwSwapBuffers,
        py::arg("window"),
        "! @brief Swaps the front and back buffers of the specified window.\n *\n *  This function swaps the front and back buffers of the specified window when\n *  rendering with OpenGL or OpenGL ES.  If the swap interval is greater than\n *  zero, the GPU driver waits the specified number of screen updates before\n *  swapping the buffers.\n *\n *  The specified window must have an OpenGL or OpenGL ES context.  Specifying\n *  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT\n *  error.\n *\n *  This function does not apply to Vulkan.  If you are rendering with Vulkan,\n *  see `vkQueuePresentKHR` instead.\n *\n *  @param[in] window The window whose buffers to swap.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark __EGL:__ The context of the specified window must be current on the\n *  calling thread.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref buffer_swap\n *  @sa @ref glfwSwapInterval\n *\n *  @since Added in version 1.0.\n *  @glfw3 Added window handle parameter.\n *\n *  @ingroup window\n");

    m.def("swap_interval",
        glfwSwapInterval,
        py::arg("interval"),
        "! @brief Sets the swap interval for the current context.\n *\n *  This function sets the swap interval for the current OpenGL or OpenGL ES\n *  context, i.e. the number of screen updates to wait from the time @ref\n *  glfwSwapBuffers was called before swapping the buffers and returning.  This\n *  is sometimes called _vertical synchronization_, _vertical retrace\n *  synchronization_ or just _vsync_.\n *\n *  A context that supports either of the `WGL_EXT_swap_control_tear` and\n *  `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap\n *  intervals, which allows the driver to swap immediately even if a frame\n *  arrives a little bit late.  You can check for these extensions with @ref\n *  glfwExtensionSupported.\n *\n *  A context must be current on the calling thread.  Calling this function\n *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.\n *\n *  This function does not apply to Vulkan.  If you are rendering with Vulkan,\n *  see the present mode of your swapchain instead.\n *\n *  @param[in] interval The minimum number of screen updates to wait for\n *  until the buffers are swapped by @ref glfwSwapBuffers.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.\n *\n *  @remark This function is not called during context creation, leaving the\n *  swap interval set to whatever is the default for that API.  This is done\n *  because some swap interval extensions used by GLFW do not allow the swap\n *  interval to be reset to zero once it has been set to a non-zero value.\n *\n *  @remark Some GPU drivers do not honor the requested swap interval, either\n *  because of a user setting that overrides the application's request or due to\n *  bugs in the driver.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref buffer_swap\n *  @sa @ref glfwSwapBuffers\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup context\n");

    m.def("extension_supported",
        glfwExtensionSupported,
        py::arg("extension"),
        "! @brief Returns whether the specified extension is available.\n *\n *  This function returns whether the specified\n *  [API extension](@ref context_glext) is supported by the current OpenGL or\n *  OpenGL ES context.  It searches both for client API extension and context\n *  creation API extensions.\n *\n *  A context must be current on the calling thread.  Calling this function\n *  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error.\n *\n *  As this functions retrieves and searches one or more extension strings each\n *  call, it is recommended that you cache its results if it is going to be used\n *  frequently.  The extension strings will not change during the lifetime of\n *  a context, so there is no danger in doing this.\n *\n *  This function does not apply to Vulkan.  If you are using Vulkan, see @ref\n *  glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`\n *  and `vkEnumerateDeviceExtensionProperties` instead.\n *\n *  @param[in] extension The ASCII encoded name of the extension.\n *  @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`\n *  otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref\n *  GLFW_NO_CURRENT_CONTEXT, @ref GLFW_INVALID_VALUE and @ref\n *  GLFW_PLATFORM_ERROR.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref context_glext\n *  @sa @ref glfwGetProcAddress\n *\n *  @since Added in version 1.0.\n *\n *  @ingroup context\n");

    m.def("vulkan_supported",
        glfwVulkanSupported, "! @brief Returns whether the Vulkan loader and an ICD have been found.\n *\n *  This function returns whether the Vulkan loader and any minimally functional\n *  ICD have been found.\n *\n *  The availability of a Vulkan loader and even an ICD does not by itself guarantee that\n *  surface creation or even instance creation is possible.  Call @ref\n *  glfwGetRequiredInstanceExtensions to check whether the extensions necessary for Vulkan\n *  surface creation are available and @ref glfwGetPhysicalDevicePresentationSupport to\n *  check whether a queue family of a physical device supports image presentation.\n *\n *  @return `GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`\n *  otherwise.\n *\n *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.\n *\n *  @thread_safety This function may be called from any thread.\n *\n *  @sa @ref vulkan_support\n *\n *  @since Added in version 3.2.\n *\n *  @ingroup vulkan\n");
    ////////////////////    </generated_from:glfw3.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
