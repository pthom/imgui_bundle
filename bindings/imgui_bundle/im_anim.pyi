"""ImAnim: Animation Engine for Dear ImGui
Python bindings for https://github.com/soufianekhiat/ImAnim

ImAnim provides smooth animations with 30+ easing functions, keyframe clips,
motion paths, and more. Core functions:
- iam_tween_float/vec2/vec4/color: Animate values with easing
- iam_update_begin_frame: Call after ImGui::NewFrame()
- iam_clip_update: Update timeline animations (delta time)
"""
# ruff: noqa: B008
from typing import Optional, Callable, Any, overload
from imgui_bundle.imgui import ImVec2, ImVec2Like, ImVec4, ImVec4Like, ImU32, ImFont, Style, ImVector_float, ImVector_ImVec4
import enum

ImGuiID = int
ImGuiStyle = Style

# Callback type aliases
ease_fn = Callable[[float], float]

# Variation callbacks (index is the loop iteration)
variation_float_fn = Callable[[int], float]
variation_int_fn = Callable[[int], int]
variation_vec2_fn = Callable[[int], ImVec2]
variation_vec4_fn = Callable[[int], ImVec4]

# Resolver callbacks (return dynamic target value)
float_resolver = Callable[[], float]
vec2_resolver = Callable[[], ImVec2]
vec4_resolver = Callable[[], ImVec4]
color_resolver = Callable[[], ImVec4]
int_resolver = Callable[[], int]

# Clip callbacks
clip_callback = Callable[[int], None]  # inst_id
marker_callback = Callable[[int, int, float], None]  # inst_id, marker_id, marker_time


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:im_anim.h>    ####################
# im_anim.h â€” Dear ImGui animation helpers.
# Author: Soufiane KHIAT
# License: MIT
# Version: 1.0.0
#
# - Channels: float, vec2, vec4, int, color (sRGB/Linear/HSV/OKLAB/OKLCH blending).
# - Easing: presets + cubicBezier/steps/back/elastic/bounce/spring.
# - Caching: ImPool + ImGuiStorage keyed by (ImGuiID, channel_id) via ImHashData.
# - Resize helpers: relative targets, resolver callback, explicit rebase.


# Version information


# PI constants

class ease_type(enum.IntEnum):
    """ ----------------------------------------------------
     Public enums & descriptors (C-style)
     ----------------------------------------------------
    """
    ease_linear = enum.auto()         # (= 0)
    ease_in_quad = enum.auto()        # (= 1)
    ease_out_quad = enum.auto()       # (= 2)
    ease_in_out_quad = enum.auto()    # (= 3)
    ease_in_cubic = enum.auto()       # (= 4)
    ease_out_cubic = enum.auto()      # (= 5)
    ease_in_out_cubic = enum.auto()   # (= 6)
    ease_in_quart = enum.auto()       # (= 7)
    ease_out_quart = enum.auto()      # (= 8)
    ease_in_out_quart = enum.auto()   # (= 9)
    ease_in_quint = enum.auto()       # (= 10)
    ease_out_quint = enum.auto()      # (= 11)
    ease_in_out_quint = enum.auto()   # (= 12)
    ease_in_sine = enum.auto()        # (= 13)
    ease_out_sine = enum.auto()       # (= 14)
    ease_in_out_sine = enum.auto()    # (= 15)
    ease_in_expo = enum.auto()        # (= 16)
    ease_out_expo = enum.auto()       # (= 17)
    ease_in_out_expo = enum.auto()    # (= 18)
    ease_in_circ = enum.auto()        # (= 19)
    ease_out_circ = enum.auto()       # (= 20)
    ease_in_out_circ = enum.auto()    # (= 21)
    ease_in_back = enum.auto()        # (= 22)
    ease_out_back = enum.auto()       # (= 23)
    ease_in_out_back = enum.auto()    # (= 24)  # p0 = overshoot
    ease_in_elastic = enum.auto()     # (= 25)
    ease_out_elastic = enum.auto()    # (= 26)
    ease_in_out_elastic = enum.auto() # (= 27)  # p0 = amplitude, p1 = period
    ease_in_bounce = enum.auto()      # (= 28)
    ease_out_bounce = enum.auto()     # (= 29)
    ease_in_out_bounce = enum.auto()  # (= 30)
    ease_steps = enum.auto()          # (= 31)  # p0 = steps (>=1), p1 = 0:end 1:start 2:both
    ease_cubic_bezier = enum.auto()   # (= 32)  # p0=x1 p1=y1 p2=x2 p3=y2
    ease_spring = enum.auto()         # (= 33)  # p0=mass p1=stiffness p2=damping p3=v0
    ease_custom = enum.auto()         # (= 34)  # User-defined easing function (use ease_custom_fn)

class policy(enum.IntEnum):
    crossfade = enum.auto() # (= 0)  # smooth into new target
    cut = enum.auto()       # (= 1)  # snap to target
    queue = enum.auto()     # (= 2)  # queue one pending target

class color_space(enum.IntEnum):
    col_srgb = enum.auto()        # (= 0)  # blend in sRGB (not physically linear)
    col_srgb_linear = enum.auto() # (= 1)  # sRGB<->linear, blend in linear, back to sRGB
    col_hsv = enum.auto()         # (= 2)  # blend H/S/V (hue shortest arc), keep A linear
    col_oklab = enum.auto()       # (= 3)  # sRGB<->OKLAB, blend in OKLAB, back to sRGB
    col_oklch = enum.auto()       # (= 4)  # sRGB<->OKLCH (cylindrical OKLAB), blend in OKLCH, back to sRGB

class anchor_space(enum.IntEnum):
    anchor_window_content = enum.auto() # (= 0)  # ImGui::GetContentRegionAvail()
    anchor_window = enum.auto()         # (= 1)  # ImGui::GetWindowSize()
    anchor_viewport = enum.auto()       # (= 2)  # ImGui::GetWindowViewport()->Size
    anchor_last_item = enum.auto()      # (= 3)  # ImGui::GetItemRectSize()

class ease_desc:
    """ Descriptor for any easing (preset or parametric)"""
    type: int  # ease_type
    p0: float
    p1: float
    p2: float
    p3: float
    def __init__(
        self,
        type: int = int(),
        p0: float = float(),
        p1: float = float(),
        p2: float = float(),
        p3: float = float()
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# Custom easing function callback (t in [0,1], returns eased value)
# [ADAPT_IMGUI_BUNDLE] - use ImAnimHybridCallback to switch between function pointer and std::function
# [/ADAPT_IMGUI_BUNDLE]

# ----------------------------------------------------
# Public API declarations
# ----------------------------------------------------

# Frame management
def update_begin_frame() -> None:
    """ Call once per frame before any tweens."""
    pass
def gc(max_age_frames: int = 600) -> None:
    """ Remove stale tween entries older than max_age_frames."""
    pass
def pool_clear() -> None:
    """ Manually clean up pools."""
    pass
def reserve(
    cap_float: int,
    cap_vec2: int,
    cap_vec4: int,
    cap_int: int,
    cap_color: int
    ) -> None:
    """ Pre-allocate pool capacity."""
    pass
def set_ease_lut_samples(count: int) -> None:
    """ Set LUT resolution for parametric easings (default: 256)."""
    pass

# Global time scale (for slow-motion / fast-forward debugging)
def set_global_time_scale(scale: float) -> None:
    """ Set global time multiplier (1.0 = normal, 0.5 = half speed, 2.0 = double)."""
    pass
def get_global_time_scale() -> float:
    """ Get current global time scale."""
    pass

# Lazy Initialization - defer channel creation until animation is needed
def set_lazy_init(enable: bool) -> None:
    """ Enable/disable lazy initialization (default: True)."""
    pass
def is_lazy_init_enabled() -> bool:
    """ Check if lazy init is enabled."""
    pass

# Custom easing functions
def register_custom_ease(slot: int, fn: ease_fn) -> None:
    """ Register custom easing in slot 0-15. Use with ease_custom_fn(slot)."""
    pass
def get_custom_ease(slot: int) -> ease_fn:
    """ Get registered custom easing function."""
    pass

# Debug UI
def show_unified_inspector(p_open: Optional[bool] = None) -> None:
    """ Show unified inspector (merges debug window + animation inspector)."""
    pass
def show_debug_timeline(instance_id: int) -> None:
    """ Show debug timeline for a clip instance."""
    pass

# Performance Profiler
def profiler_enable(enable: bool) -> None:
    """ Enable/disable the performance profiler."""
    pass
def profiler_is_enabled() -> bool:
    """ Check if profiler is enabled."""
    pass
def profiler_begin_frame() -> None:
    """ Call at frame start when profiler is enabled."""
    pass
def profiler_end_frame() -> None:
    """ Call at frame end when profiler is enabled."""
    pass
def profiler_begin(name: str) -> None:
    """ Begin a named profiler section."""
    pass
def profiler_end() -> None:
    """ End the current profiler section."""
    pass

class drag_opts:
    """ Drag Feedback - animated feedback for drag operations"""
    snap_grid: ImVec2       # Grid size for snapping (0,0 = no grid)
    snap_points: ImVec2     # Array of custom snap points
    snap_points_count: int  # Number of snap points
    snap_duration: float    # Duration of snap animation
    overshoot: float        # Overshoot amount (0 = none, 1 = normal)
    ease_type: int          # Easing type for snap animation

    def __init__(self) -> None:
        pass

class drag_feedback:
    position: ImVec2      # Current animated position
    offset: ImVec2        # Offset from drag start
    velocity: ImVec2      # Current velocity estimate
    is_dragging: bool     # Currently being dragged
    is_snapping: bool     # Currently snapping to target
    snap_progress: float  # Snap animation progress (0-1)
    def __init__(
        self,
        position: Optional[ImVec2Like] = None,
        offset: Optional[ImVec2Like] = None,
        velocity: Optional[ImVec2Like] = None,
        is_dragging: bool = bool(),
        is_snapping: bool = bool(),
        snap_progress: float = float()
        ) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * position: ImVec2()
                * offset: ImVec2()
                * velocity: ImVec2()
        """
        pass

def drag_begin(id: int, pos: ImVec2Like) -> drag_feedback:
    """ Start tracking drag at position."""
    pass
def drag_update(id: int, pos: ImVec2Like, dt: float) -> drag_feedback:
    """ Update drag position during drag."""
    pass
def drag_release(
    id: int,
    pos: ImVec2Like,
    opts: drag_opts,
    dt: float
    ) -> drag_feedback:
    """ Release drag with animated feedback."""
    pass
def drag_cancel(id: int) -> None:
    """ Cancel drag tracking."""
    pass

class wave_type(enum.IntEnum):
    """ Oscillators - continuous periodic animations"""
    wave_sine = enum.auto()     # (= 0)  # Smooth sine wave
    wave_triangle = enum.auto() # (= 1)  # Triangle wave (linear up/down)
    wave_sawtooth = enum.auto() # (= 2)  # Sawtooth wave (linear up, instant reset)
    wave_square = enum.auto()   # (= 3)  # Square wave (on/off pulse)
def oscillate(
    id: int,
    amplitude: float,
    frequency: float,
    wave_type: int,
    phase: float,
    dt: float
    ) -> float:
    """ Returns oscillating value [-amplitude, +amplitude]."""
    pass
def oscillate_int(
    id: int,
    amplitude: int,
    frequency: float,
    wave_type: int,
    phase: float,
    dt: float
    ) -> int:
    """ Returns oscillating integer value [-amplitude, +amplitude]."""
    pass
def oscillate_vec2(
    id: int,
    amplitude: ImVec2Like,
    frequency: ImVec2Like,
    wave_type: int,
    phase: ImVec2Like,
    dt: float
    ) -> ImVec2:
    """ 2D oscillation."""
    pass
def oscillate_vec4(
    id: int,
    amplitude: ImVec4Like,
    frequency: ImVec4Like,
    wave_type: int,
    phase: ImVec4Like,
    dt: float
    ) -> ImVec4:
    """ 4D oscillation."""
    pass
def oscillate_color(
    id: int,
    base_color: ImVec4Like,
    amplitude: ImVec4Like,
    frequency: float,
    wave_type: int,
    phase: float,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Color oscillation in specified color space."""
    pass

# Shake/Wiggle - procedural noise animations
def shake(
    id: int,
    intensity: float,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> float:
    """ Decaying random shake. Returns offset that decays to 0."""
    pass
def shake_int(
    id: int,
    intensity: int,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> int:
    """ Decaying random shake for integers."""
    pass
def shake_vec2(
    id: int,
    intensity: ImVec2Like,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> ImVec2:
    """ 2D decaying shake."""
    pass
def shake_vec4(
    id: int,
    intensity: ImVec4Like,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> ImVec4:
    """ 4D decaying shake."""
    pass
def shake_color(
    id: int,
    base_color: ImVec4Like,
    intensity: ImVec4Like,
    frequency: float,
    decay_time: float,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Color shake in specified color space."""
    pass
def wiggle(id: int, amplitude: float, frequency: float, dt: float) -> float:
    """ Continuous smooth random movement."""
    pass
def wiggle_int(id: int, amplitude: int, frequency: float, dt: float) -> int:
    """ Continuous smooth random movement for integers."""
    pass
def wiggle_vec2(id: int, amplitude: ImVec2Like, frequency: float, dt: float) -> ImVec2:
    """ 2D continuous wiggle."""
    pass
def wiggle_vec4(id: int, amplitude: ImVec4Like, frequency: float, dt: float) -> ImVec4:
    """ 4D continuous wiggle."""
    pass
def wiggle_color(
    id: int,
    base_color: ImVec4Like,
    amplitude: ImVec4Like,
    frequency: float,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Color wiggle in specified color space."""
    pass
def trigger_shake(id: int) -> None:
    """ Trigger/restart a shake animation."""
    pass

# Easing evaluation
def eval_preset(type: int, t: float) -> float:
    """ Evaluate a preset easing function at time t (0-1)."""
    pass

# Tween API - smoothly interpolate values over time
# init_value: Initial value when channel is first created. Defaults to 0 (or white for color).
#             Use this to avoid unwanted animations when the first target differs from the default.
def tween_float(
    id: int,
    channel_id: int,
    target: float,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: float = 0.0
    ) -> float:
    """ Animate a float value."""
    pass
def tween_vec2(
    id: int,
    channel_id: int,
    target: ImVec2Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: Optional[ImVec2Like] = None
    ) -> ImVec2:
    """Python bindings defaults:
        If init_value is None, then its default value will be: ImVec2(0, 0)

     Animate a 2D vector.
    """
    pass
def tween_vec4(
    id: int,
    channel_id: int,
    target: ImVec4Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: Optional[ImVec4Like] = None
    ) -> ImVec4:
    """Python bindings defaults:
        If init_value is None, then its default value will be: ImVec4(0, 0, 0, 0)

     Animate a 4D vector.
    """
    pass
def tween_int(
    id: int,
    channel_id: int,
    target: int,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: int = 0
    ) -> int:
    """ Animate an integer value."""
    pass
def tween_color(
    id: int,
    channel_id: int,
    target_srgb: ImVec4Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    color_space: int,
    dt: float,
    init_value: Optional[ImVec4Like] = None
    ) -> ImVec4:
    """Python bindings defaults:
        If init_value is None, then its default value will be: ImVec4(1, 1, 1, 1)

     Animate a color in specified color space.
    """
    pass

# Resize-friendly helpers
def anchor_size(space: int) -> ImVec2:
    """ Get dimensions of anchor space (window, viewport, etc.)."""
    pass

# Relative target tweens (percent of anchor + pixel offset) - survive window resizes
def tween_float_rel(
    id: int,
    channel_id: int,
    percent: float,
    px_bias: float,
    dur: float,
    ez: ease_desc,
    policy: int,
    anchor_space: int,
    axis: int,
    dt: float
    ) -> float:
    """ Float relative to anchor (axis: 0=x, 1=y)."""
    pass
def tween_vec2_rel(
    id: int,
    channel_id: int,
    percent: ImVec2Like,
    px_bias: ImVec2Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    anchor_space: int,
    dt: float
    ) -> ImVec2:
    """ Vec2 relative to anchor."""
    pass
def tween_vec4_rel(
    id: int,
    channel_id: int,
    percent: ImVec4Like,
    px_bias: ImVec4Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    anchor_space: int,
    dt: float
    ) -> ImVec4:
    """ Vec4 with x,y relative to anchor."""
    pass
def tween_color_rel(
    id: int,
    channel_id: int,
    percent: ImVec4Like,
    px_bias: ImVec4Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    color_space: int,
    anchor_space: int,
    dt: float
    ) -> ImVec4:
    """ Color with component offsets."""
    pass

# Resolver callbacks for dynamic target computation

# Resolved tweens - target computed dynamically by callback each frame
def tween_float_resolved(
    id: int,
    channel_id: int,
    fn: float_resolver,
    user: Any,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float
    ) -> float:
    """ Float with dynamic target."""
    pass
def tween_vec2_resolved(
    id: int,
    channel_id: int,
    fn: vec2_resolver,
    user: Any,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float
    ) -> ImVec2:
    """ Vec2 with dynamic target."""
    pass
def tween_vec4_resolved(
    id: int,
    channel_id: int,
    fn: vec4_resolver,
    user: Any,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float
    ) -> ImVec4:
    """ Vec4 with dynamic target."""
    pass
def tween_color_resolved(
    id: int,
    channel_id: int,
    fn: color_resolver,
    user: Any,
    dur: float,
    ez: ease_desc,
    policy: int,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Color with dynamic target."""
    pass
def tween_int_resolved(
    id: int,
    channel_id: int,
    fn: int_resolver,
    user: Any,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float
    ) -> int:
    """ Int with dynamic target."""
    pass

# Rebase functions - change target of in-progress animation without restarting
def rebase_float(id: int, channel_id: int, new_target: float, dt: float) -> None:
    """ Smoothly redirect float animation to new target."""
    pass
def rebase_vec2(id: int, channel_id: int, new_target: ImVec2Like, dt: float) -> None:
    """ Smoothly redirect vec2 animation to new target."""
    pass
def rebase_vec4(id: int, channel_id: int, new_target: ImVec4Like, dt: float) -> None:
    """ Smoothly redirect vec4 animation to new target."""
    pass
def rebase_color(id: int, channel_id: int, new_target: ImVec4Like, dt: float) -> None:
    """ Smoothly redirect color animation to new target."""
    pass
def rebase_int(id: int, channel_id: int, new_target: int, dt: float) -> None:
    """ Smoothly redirect int animation to new target."""
    pass

# Color blending utility
def get_blended_color(
    a_srgb: ImVec4Like,
    b_srgb: ImVec4Like,
    t: float,
    color_space: int
    ) -> ImVec4:
    """ Blend two sRGB colors in specified color space."""
    pass

# ----------------------------------------------------
# Convenience shorthands for common easings
# ----------------------------------------------------
def ease_preset(type: int) -> ease_desc:
    """ Create descriptor from preset enum."""
    pass
def ease_bezier(x1: float, y1: float, x2: float, y2: float) -> ease_desc:
    """ Create cubic bezier easing."""
    pass
def ease_steps_desc(steps: int, mode: int) -> ease_desc:
    """ Create step function easing."""
    pass
def ease_back(overshoot: float) -> ease_desc:
    """ Create back easing with overshoot."""
    pass
def ease_elastic(amplitude: float, period: float) -> ease_desc:
    """ Create elastic easing."""
    pass
def ease_spring_desc(
    mass: float,
    stiffness: float,
    damping: float,
    v0: float
    ) -> ease_desc:
    """ Create physics spring."""
    pass
def ease_custom_fn(slot: int) -> ease_desc:
    """ Use registered custom easing (slot 0-15)."""
    pass

# Scroll animation - smooth scrolling for ImGui windows
def scroll_to_y(
    target_y: float,
    duration: float,
    ez: Optional[ease_desc] = None
    ) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll current window to Y position.
    """
    pass
def scroll_to_x(
    target_x: float,
    duration: float,
    ez: Optional[ease_desc] = None
    ) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll current window to X position.
    """
    pass
def scroll_to_top(duration: float = 0.3, ez: Optional[ease_desc] = None) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll to top of window.
    """
    pass
def scroll_to_bottom(
    duration: float = 0.3,
    ez: Optional[ease_desc] = None
    ) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll to bottom of window.
    """
    pass

# ----------------------------------------------------
# Per-axis easing - different easing per component
# ----------------------------------------------------

class ease_per_axis:
    """ Per-axis easing descriptor (for vec2/vec4/color)"""
    x: ease_desc  # Easing for X component
    y: ease_desc  # Easing for Y component
    z: ease_desc  # Easing for Z component (vec4/color only)
    w: ease_desc  # Easing for W/alpha component (vec4/color only)

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, all: ease_desc) -> None:
        pass

    @overload
    def __init__(self, ex: ease_desc, ey: ease_desc) -> None:
        pass

    @overload
    def __init__(self, ex: ease_desc, ey: ease_desc, ez: ease_desc, ew: ease_desc) -> None:
        pass

# Tween with per-axis easing - each component uses its own easing curve
def tween_vec2_per_axis(
    id: int,
    channel_id: int,
    target: ImVec2Like,
    dur: float,
    ez: ease_per_axis,
    policy: int,
    dt: float
    ) -> ImVec2:
    pass
def tween_vec4_per_axis(
    id: int,
    channel_id: int,
    target: ImVec4Like,
    dur: float,
    ez: ease_per_axis,
    policy: int,
    dt: float
    ) -> ImVec4:
    pass
def tween_color_per_axis(
    id: int,
    channel_id: int,
    target_srgb: ImVec4Like,
    dur: float,
    ez: ease_per_axis,
    policy: int,
    color_space: int,
    dt: float
    ) -> ImVec4:
    pass

# ----------------------------------------------------
# Motion Paths - animate along curves and splines
# ----------------------------------------------------

class path_segment_type(enum.IntEnum):
    """ Path segment types"""
    seg_line = enum.auto()             # (= 0)  # Linear segment to endpoint
    seg_quadratic_bezier = enum.auto() # (= 1)  # Quadratic bezier (1 control point)
    seg_cubic_bezier = enum.auto()     # (= 2)  # Cubic bezier (2 control points)
    seg_catmull_rom = enum.auto()      # (= 3)  # Catmull-rom spline segment

# Single-curve evaluation functions (stateless, for direct use)
def bezier_quadratic(
    p0: ImVec2Like,
    p1: ImVec2Like,
    p2: ImVec2Like,
    t: float
    ) -> ImVec2:
    """ Evaluate quadratic bezier at t [0,1]."""
    pass
def bezier_cubic(
    p0: ImVec2Like,
    p1: ImVec2Like,
    p2: ImVec2Like,
    p3: ImVec2Like,
    t: float
    ) -> ImVec2:
    """ Evaluate cubic bezier at t [0,1]."""
    pass
def catmull_rom(
    p0: ImVec2Like,
    p1: ImVec2Like,
    p2: ImVec2Like,
    p3: ImVec2Like,
    t: float,
    tension: float = 0.5
    ) -> ImVec2:
    """ Evaluate Catmull-Rom spline at t [0,1]. Points go through p1 and p2."""
    pass

# Derivatives (for tangent/velocity)
def bezier_quadratic_deriv(
    p0: ImVec2Like,
    p1: ImVec2Like,
    p2: ImVec2Like,
    t: float
    ) -> ImVec2:
    """ Derivative of quadratic bezier."""
    pass
def bezier_cubic_deriv(
    p0: ImVec2Like,
    p1: ImVec2Like,
    p2: ImVec2Like,
    p3: ImVec2Like,
    t: float
    ) -> ImVec2:
    """ Derivative of cubic bezier."""
    pass
def catmull_rom_deriv(
    p0: ImVec2Like,
    p1: ImVec2Like,
    p2: ImVec2Like,
    p3: ImVec2Like,
    t: float,
    tension: float = 0.5
    ) -> ImVec2:
    """ Derivative of Catmull-Rom."""
    pass


class path:
    """ path - fluent API for building multi-segment motion paths"""
    @staticmethod
    def begin(path_id: int, start: ImVec2Like) -> path:
        """ Start building a path at position."""
        pass

    def line_to(self, end: ImVec2Like) -> path:
        """ Add linear segment to endpoint."""
        pass
    def quadratic_to(self, ctrl: ImVec2Like, end: ImVec2Like) -> path:
        """ Add quadratic bezier segment."""
        pass
    def cubic_to(self, ctrl1: ImVec2Like, ctrl2: ImVec2Like, end: ImVec2Like) -> path:
        """ Add cubic bezier segment."""
        pass
    def catmull_to(self, end: ImVec2Like, tension: float = 0.5) -> path:
        """ Add Catmull-Rom segment to endpoint."""
        pass
    def close(self) -> path:
        """ Close path back to start point."""
        pass

    def end(self) -> None:
        """ Finalize and register path."""
        pass

    def id(self) -> int:
        pass


# Query path info
def path_exists(path_id: int) -> bool:
    """ Check if path exists."""
    pass
def path_length(path_id: int) -> float:
    """ Get approximate path length."""
    pass
def path_evaluate(path_id: int, t: float) -> ImVec2:
    """ Sample path at t [0,1]."""
    pass
def path_tangent(path_id: int, t: float) -> ImVec2:
    """ Get tangent (normalized direction) at t."""
    pass
def path_angle(path_id: int, t: float) -> float:
    """ Get rotation angle (radians) at t."""
    pass

# Tween along a path
def tween_path(
    id: int,
    channel_id: int,
    path_id: int,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float
    ) -> ImVec2:
    """ Animate position along path."""
    pass
def tween_path_angle(
    id: int,
    channel_id: int,
    path_id: int,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float
    ) -> float:
    """ Animate rotation angle along path."""
    pass

# ----------------------------------------------------
# Arc-length parameterization (for constant-speed animation)
# ----------------------------------------------------

# Build arc-length lookup table for a path (call once per path, improves accuracy)
def path_build_arc_lut(path_id: int, subdivisions: int = 64) -> None:
    """ Build LUT with specified resolution."""
    pass
def path_has_arc_lut(path_id: int) -> bool:
    """ Check if path has precomputed LUT."""
    pass

# Distance-based path evaluation (uses arc-length LUT for constant speed)
def path_distance_to_t(path_id: int, distance: float) -> float:
    """ Convert arc-length distance to t parameter."""
    pass
def path_evaluate_at_distance(path_id: int, distance: float) -> ImVec2:
    """ Get position at arc-length distance."""
    pass
def path_angle_at_distance(path_id: int, distance: float) -> float:
    """ Get rotation angle at arc-length distance."""
    pass
def path_tangent_at_distance(path_id: int, distance: float) -> ImVec2:
    """ Get tangent at arc-length distance."""
    pass

# ----------------------------------------------------
# Path Morphing - interpolate between two paths
# ----------------------------------------------------

class morph_opts:
    """ Morph options for path interpolation"""
    samples: int           # Number of sample points for resampling (default: 64)
    match_endpoints: bool  # Force endpoints to match exactly (default: True)
    use_arc_length: bool   # Use arc-length parameterization for smoother morphing (default: True)

    def __init__(self) -> None:
        pass

def path_morph(
    path_a: int,
    path_b: int,
    t: float,
    blend: float,
    opts: Optional[morph_opts] = None
    ) -> ImVec2:
    """ Evaluate morphed path at parameter t [0,1] with blend factor [0,1]
     path_a at blend=0, path_b at blend=1
     Paths can have different numbers of segments - they are resampled to match


    Python bindings defaults:
        If opts is None, then its default value will be: morph_opts()
    """
    pass

def path_morph_tangent(
    path_a: int,
    path_b: int,
    t: float,
    blend: float,
    opts: Optional[morph_opts] = None
    ) -> ImVec2:
    """ Get tangent of morphed path


    Python bindings defaults:
        If opts is None, then its default value will be: morph_opts()
    """
    pass

def path_morph_angle(
    path_a: int,
    path_b: int,
    t: float,
    blend: float,
    opts: Optional[morph_opts] = None
    ) -> float:
    """ Get angle (radians) of morphed path


    Python bindings defaults:
        If opts is None, then its default value will be: morph_opts()
    """
    pass

def tween_path_morph(
    id: int,
    channel_id: int,
    path_a: int,
    path_b: int,
    target_blend: float,
    dur: float,
    path_ease: ease_desc,
    morph_ease: ease_desc,
    policy: int,
    dt: float,
    opts: Optional[morph_opts] = None
    ) -> ImVec2:
    """ Tween along a morphing path - animates both position along path AND the morph blend


    Python bindings defaults:
        If opts is None, then its default value will be: morph_opts()
    """
    pass

def get_morph_blend(id: int, channel_id: int) -> float:
    """ Get current morph blend value from a tween (for querying state)"""
    pass

# ----------------------------------------------------
# Text along motion paths
# ----------------------------------------------------

class text_path_align(enum.IntEnum):
    """ Text alignment along path"""
    text_align_start = enum.auto()  # (= 0)  # Text starts at path start (or offset)
    text_align_center = enum.auto() # (= 1)  # Text centered on path
    text_align_end = enum.auto()    # (= 2)  # Text ends at path end

class text_path_opts:
    """ Text path options"""
    origin: ImVec2         # Screen-space origin for rendering (path coords are offset by this)
    offset: float          # Starting offset along path (pixels)
    letter_spacing: float  # Extra spacing between characters (pixels)
    align: int             # text_path_align value
    flip_y: bool           # Flip text vertically (for paths going right-to-left)
    color: ImU32           # Text color (default: white)
    font: ImFont           # Font to use (None = current font)
    font_scale: float      # Additional font scale (1.0 = normal)

    def __init__(self) -> None:
        pass

def text_path(
    path_id: int,
    text: str,
    opts: Optional[text_path_opts] = None
    ) -> None:
    """ Render text along a path (static - no animation)


    Python bindings defaults:
        If opts is None, then its default value will be: text_path_opts()
    """
    pass

def text_path_animated(
    path_id: int,
    text: str,
    progress: float,
    opts: Optional[text_path_opts] = None
    ) -> None:
    """ Animated text along path (characters appear progressively)


    Python bindings defaults:
        If opts is None, then its default value will be: text_path_opts()
    """
    pass

def text_path_width(text: str, opts: Optional[text_path_opts] = None) -> float:
    """ Helper: Get text width for path layout calculations


    Python bindings defaults:
        If opts is None, then its default value will be: text_path_opts()
    """
    pass

# ----------------------------------------------------
# Quad transform helpers (for advanced custom rendering)
# ----------------------------------------------------

def transform_quad(
    quad: ImVec2Like,
    center: ImVec2Like,
    angle_rad: float,
    translation: ImVec2Like
    ) -> None:
    """ Transform a quad (4 vertices) by rotation and translation"""
    pass

def make_glyph_quad(
    quad: ImVec2Like,
    pos: ImVec2Like,
    angle_rad: float,
    glyph_width: float,
    glyph_height: float,
    baseline_offset: float = 0.0
    ) -> None:
    """ Create a rotated quad for a glyph at a position on the path"""
    pass

# ----------------------------------------------------
# Text Stagger - per-character animation effects
# ----------------------------------------------------

class text_stagger_effect(enum.IntEnum):
    """ Text stagger effect types"""
    text_fx_none = enum.auto()        # (= 0)  # No effect (instant appear)
    text_fx_fade = enum.auto()        # (= 1)  # Fade in alpha
    text_fx_scale = enum.auto()       # (= 2)  # Scale from center
    text_fx_slide_up = enum.auto()    # (= 3)  # Slide up from below
    text_fx_slide_down = enum.auto()  # (= 4)  # Slide down from above
    text_fx_slide_left = enum.auto()  # (= 5)  # Slide in from right
    text_fx_slide_right = enum.auto() # (= 6)  # Slide in from left
    text_fx_rotate = enum.auto()      # (= 7)  # Rotate in
    text_fx_bounce = enum.auto()      # (= 8)  # Bounce in with overshoot
    text_fx_wave = enum.auto()        # (= 9)  # Wave motion (continuous)
    text_fx_typewriter = enum.auto()  # (= 10)  # Typewriter style (instant per char)

class text_stagger_opts:
    """ Text stagger options"""
    pos: ImVec2              # Base position for text
    effect: int              # text_stagger_effect
    char_delay: float        # Delay between each character (seconds)
    char_duration: float     # Duration of each character's animation (seconds)
    effect_intensity: float  # Intensity of effect (pixels for slide, degrees for rotate, scale factor)
    ease: ease_desc          # Easing for character animation
    color: ImU32             # Text color
    font: ImFont             # Font to use (None = current)
    font_scale: float        # Font scale multiplier
    letter_spacing: float    # Extra spacing between characters

    def __init__(self) -> None:
        pass

def text_stagger(
    id: int,
    text: str,
    progress: float,
    opts: Optional[text_stagger_opts] = None
    ) -> None:
    """ Render text with per-character stagger animation


    Python bindings defaults:
        If opts is None, then its default value will be: text_stagger_opts()
    """
    pass

def text_stagger_width(
    text: str,
    opts: Optional[text_stagger_opts] = None
    ) -> float:
    """ Get text width for layout calculations


    Python bindings defaults:
        If opts is None, then its default value will be: text_stagger_opts()
    """
    pass

def text_stagger_duration(
    text: str,
    opts: Optional[text_stagger_opts] = None
    ) -> float:
    """ Get total animation duration for text (accounts for stagger delays)


    Python bindings defaults:
        If opts is None, then its default value will be: text_stagger_opts()
    """
    pass

# ----------------------------------------------------
# Noise Channels - Perlin/Simplex noise for organic movement
# ----------------------------------------------------

class noise_type(enum.IntEnum):
    """ Noise types"""
    noise_perlin = enum.auto()  # (= 0)  # Classic Perlin noise
    noise_simplex = enum.auto() # (= 1)  # Simplex noise (faster, fewer artifacts)
    noise_value = enum.auto()   # (= 2)  # Value noise (blocky)
    noise_worley = enum.auto()  # (= 3)  # Worley/cellular noise

class noise_opts:
    """ Noise options"""
    type: int           # noise_type
    octaves: int        # Number of octaves for fractal noise (1-8)
    persistence: float  # Amplitude multiplier per octave (0.0-1.0)
    lacunarity: float   # Frequency multiplier per octave (typically 2.0)
    seed: int           # Random seed for noise generation

    def __init__(self) -> None:
        pass

# Sample noise at a point (returns value in [-1, 1])
def noise_2d(x: float, y: float, opts: Optional[noise_opts] = None) -> float:
    """Python bindings defaults:
        If opts is None, then its default value will be: noise_opts()

     2D noise
    """
    pass
def noise_3d(
    x: float,
    y: float,
    z: float,
    opts: Optional[noise_opts] = None
    ) -> float:
    """Python bindings defaults:
        If opts is None, then its default value will be: noise_opts()

     3D noise
    """
    pass

# Animated noise channels - continuous noise that evolves over time
def noise_channel_float(
    id: int,
    frequency: float,
    amplitude: float,
    opts: noise_opts,
    dt: float
    ) -> float:
    """ 1D animated noise"""
    pass
def noise_channel_vec2(
    id: int,
    frequency: ImVec2Like,
    amplitude: ImVec2Like,
    opts: noise_opts,
    dt: float
    ) -> ImVec2:
    """ 2D animated noise"""
    pass
def noise_channel_vec4(
    id: int,
    frequency: ImVec4Like,
    amplitude: ImVec4Like,
    opts: noise_opts,
    dt: float
    ) -> ImVec4:
    """ 4D animated noise"""
    pass
def noise_channel_color(
    id: int,
    base_color: ImVec4Like,
    amplitude: ImVec4Like,
    frequency: float,
    opts: noise_opts,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Animated color noise in specified color space"""
    pass

# Convenience: smooth random movement (like wiggle but using noise)
def smooth_noise_float(id: int, amplitude: float, speed: float, dt: float) -> float:
    """ Simple 1D smooth noise"""
    pass
def smooth_noise_vec2(
    id: int,
    amplitude: ImVec2Like,
    speed: float,
    dt: float
    ) -> ImVec2:
    """ Simple 2D smooth noise"""
    pass
def smooth_noise_vec4(
    id: int,
    amplitude: ImVec4Like,
    speed: float,
    dt: float
    ) -> ImVec4:
    """ Simple 4D smooth noise"""
    pass
def smooth_noise_color(
    id: int,
    base_color: ImVec4Like,
    amplitude: ImVec4Like,
    speed: float,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Smooth noise for colors in specified color space"""
    pass

# ----------------------------------------------------
# Style Interpolation - animate between ImGuiStyle themes
# ----------------------------------------------------

# Register a named style for interpolation
def style_register(style_id: int, style: ImGuiStyle) -> None:
    """ Register a style snapshot"""
    pass
def style_register_current(style_id: int) -> None:
    """ Register current ImGui style"""
    pass

def style_blend(
    style_a: int,
    style_b: int,
    t: float,
    color_space: int = color_space.col_oklab
    ) -> None:
    """ Blend between two registered styles (result applied to ImGui::GetStyle())
     Uses color_space for color blending mode (col_oklab recommended)
    """
    pass

def style_tween(
    id: int,
    target_style: int,
    duration: float,
    ease: ease_desc,
    color_space: int,
    dt: float
    ) -> None:
    """ Tween between styles over time"""
    pass

def style_blend_to(
    style_a: int,
    style_b: int,
    t: float,
    out_style: ImGuiStyle,
    color_space: int = color_space.col_oklab
    ) -> None:
    """ Get interpolated style without applying"""
    pass

def style_exists(style_id: int) -> bool:
    """ Check if a style is registered"""
    pass

def style_unregister(style_id: int) -> None:
    """ Remove a registered style"""
    pass

# ----------------------------------------------------
# Gradient Interpolation - animate between color gradients
# ----------------------------------------------------

class gradient:
    """ Color gradient with any number of stops (sorted by position)"""
    positions: ImVector_float  # Positions along gradient [0,1], kept sorted
    colors: ImVector_ImVec4    # Colors at each position (sRGB)

    def __init__(self) -> None:
        pass

    @overload
    def add(self, position: float, color: ImVec4Like) -> gradient:
        """ Add a stop to the gradient (automatically sorted by position)"""
        pass
    @overload
    def add(self, position: float, color: ImU32) -> gradient:
        pass

    def stop_count(self) -> int:
        """ Get stop count"""
        pass

    def sample(self, t: float, color_space: int = color_space.col_oklab) -> ImVec4:
        """ Sample the gradient at position t [0,1]"""
        pass

    # Create common gradients
    @staticmethod
    def solid(color: ImVec4Like) -> gradient:
        pass
    @staticmethod
    def two_color(start: ImVec4Like, end: ImVec4Like) -> gradient:
        pass
    @staticmethod
    def three_color(start: ImVec4Like, mid: ImVec4Like, end: ImVec4Like) -> gradient:
        pass

def gradient_lerp(
    a: gradient,
    b: gradient,
    t: float,
    color_space: int = color_space.col_oklab
    ) -> gradient:
    """ Blend between two gradients"""
    pass

def tween_gradient(
    id: int,
    channel_id: int,
    target: gradient,
    dur: float,
    ez: ease_desc,
    policy: int,
    color_space: int,
    dt: float
    ) -> gradient:
    """ Tween between gradients over time"""
    pass

# ----------------------------------------------------
# Transform Interpolation - animate 2D transforms
# ----------------------------------------------------

class rotation_mode(enum.IntEnum):
    """ Rotation interpolation modes"""
    rotation_shortest = enum.auto() # (= 0)  # Shortest path (default) - never rotates more than 180 degrees
    rotation_longest = enum.auto()  # (= 1)  # Longest path - always takes the long way around
    rotation_cw = enum.auto()       # (= 2)  # Clockwise - always rotates clockwise (positive direction)
    rotation_ccw = enum.auto()      # (= 3)  # Counter-clockwise - always rotates counter-clockwise
    rotation_direct = enum.auto()   # (= 4)  # Direct lerp - no angle unwrapping, can cause spinning for large deltas

class transform:
    """ 2D transform (position, rotation, scale)"""
    position: ImVec2  # Translation
    scale: ImVec2     # Scale (1,1 = identity)
    rotation: float   # Rotation in radians

    @overload
    def __init__(self) -> None:
        pass
    @overload
    def __init__(
        self,
        pos: ImVec2Like,
        rot: float = 0,
        scl: Optional[ImVec2Like] = None
        ) -> None:
        """Python bindings defaults:
            If scl is None, then its default value will be: ImVec2(1, 1)
        """
        pass

    @staticmethod
    def identity() -> transform:
        """ Create identity transform"""
        pass

    def __mul__(self, other: transform) -> transform:
        """ Combine transforms (this * other)"""
        pass

    def apply(self, point: ImVec2Like) -> ImVec2:
        """ Apply transform to a point"""
        pass

    def inverse(self) -> transform:
        """ Get inverse transform"""
        pass

def transform_lerp(
    a: transform,
    b: transform,
    t: float,
    rotation_mode: int = rotation_mode.rotation_shortest
    ) -> transform:
    """ Blend between two transforms with rotation interpolation"""
    pass

def tween_transform(
    id: int,
    channel_id: int,
    target: transform,
    dur: float,
    ez: ease_desc,
    policy: int,
    rotation_mode: int,
    dt: float
    ) -> transform:
    """ Tween between transforms over time"""
    pass

def transform_from_matrix(
    m00: float,
    m01: float,
    m10: float,
    m11: float,
    tx: float,
    ty: float
    ) -> transform:
    """ Decompose a 3x2 matrix into transform components"""
    pass

def transform_to_matrix(t: transform, out_matrix: float) -> None:
    """ Convert transform to 3x2 matrix (row-major: [m00 m01 tx; m10 m11 ty])"""
    pass

# ============================================================
# CLIP-BASED ANIMATION SYSTEM
# ============================================================

class direction(enum.IntEnum):
    """ Direction for looping animations"""
    dir_normal = enum.auto()    # (= 0)  # play forward
    dir_reverse = enum.auto()   # (= 1)  # play backward
    dir_alternate = enum.auto() # (= 2)  # ping-pong

class channel_type(enum.IntEnum):
    """ Channel types for keyframes"""
    chan_float = enum.auto()     # (= 0)
    chan_vec2 = enum.auto()      # (= 1)
    chan_vec4 = enum.auto()      # (= 2)
    chan_int = enum.auto()       # (= 3)
    chan_color = enum.auto()     # (= 4)  # Color with color space (stores in vec4 + color_space metadata)
    chan_float_rel = enum.auto() # (= 5)  # Float relative to anchor (percent + px_bias)
    chan_vec2_rel = enum.auto()  # (= 6)  # Vec2 relative to anchor (percent.xy + px_bias.xy)
    chan_vec4_rel = enum.auto()  # (= 7)  # Vec4 relative to anchor (percent.xy + px_bias.xy for x,y; z,w absolute)
    chan_color_rel = enum.auto() # (= 8)  # Color relative to anchor (for position-based color effects)

class result(enum.IntEnum):
    """ Result codes"""
    ok = enum.auto()            # (= 0)
    err_not_found = enum.auto() # (= 1)
    err_bad_arg = enum.auto()   # (= 2)
    err_no_mem = enum.auto()    # (= 3)

class spring_params:
    """ Spring parameters for physics-based animation"""
    mass: float
    stiffness: float
    damping: float
    initial_velocity: float
    def __init__(
        self,
        mass: float = float(),
        stiffness: float = float(),
        damping: float = float(),
        initial_velocity: float = float()
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# ----------------------------------------------------
# Repeat with Variation - per-loop parameter changes
# ----------------------------------------------------

class variation_mode(enum.IntEnum):
    """ Variation modes for repeat animations"""
    var_none = enum.auto()       # (= 0)  # No variation
    var_increment = enum.auto()  # (= 1)  # Add amount each iteration
    var_decrement = enum.auto()  # (= 2)  # Subtract amount each iteration
    var_multiply = enum.auto()   # (= 3)  # Multiply by factor each iteration
    var_random = enum.auto()     # (= 4)  # Random in range [-amount, +amount]
    var_random_abs = enum.auto() # (= 5)  # Random in range [0, amount]
    var_pingpong = enum.auto()   # (= 6)  # Alternate +/- each iteration
    var_callback = enum.auto()   # (= 7)  # Use custom callback

# Callback types for custom variation logic

class variation_float:
    """ Float variation"""
    mode: int
    amount: float
    min_clamp: float
    max_clamp: float
    seed: int  # 0 = global random, non-zero = deterministic
    callback: variation_float_fn
    user: Any
    def __init__(
        self,
        mode: int = int(),
        amount: float = float(),
        min_clamp: float = float(),
        max_clamp: float = float(),
        callback: Optional[variation_float_fn] = None
        ) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If callback is None, then its default value will be: variation_float_fn()
        """
        pass

class variation_int:
    """ Int variation"""
    mode: int
    amount: int
    min_clamp: int
    max_clamp: int
    seed: int
    callback: variation_int_fn
    user: Any
    def __init__(
        self,
        mode: int = int(),
        amount: int = int(),
        min_clamp: int = int(),
        max_clamp: int = int(),
        callback: Optional[variation_int_fn] = None
        ) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If callback is None, then its default value will be: variation_int_fn()
        """
        pass

class variation_vec2:
    """ Vec2 variation (global mode or per-axis)"""
    mode: int           # Global mode (var_none = use per-axis)
    amount: ImVec2
    min_clamp: ImVec2
    max_clamp: ImVec2
    seed: int
    callback: variation_vec2_fn
    user: Any
    x: variation_float  # Per-axis (used when mode == var_none)
    y: variation_float  # Per-axis (used when mode == var_none)
    def __init__(
        self,
        mode: int = int(),
        amount: Optional[ImVec2Like] = None,
        min_clamp: Optional[ImVec2Like] = None,
        max_clamp: Optional[ImVec2Like] = None,
        callback: Optional[variation_vec2_fn] = None,
        x: Optional[variation_float] = None,
        y: Optional[variation_float] = None
        ) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * amount: ImVec2()
                * min_clamp: ImVec2()
                * max_clamp: ImVec2()
                * callback: variation_vec2_fn()
                * x: variation_float()
                * y: variation_float()
        """
        pass

class variation_vec4:
    """ Vec4 variation (global mode or per-axis)"""
    mode: int
    amount: ImVec4
    min_clamp: ImVec4
    max_clamp: ImVec4
    seed: int
    callback: variation_vec4_fn
    user: Any
    x: variation_float  # Per-axis
    y: variation_float  # Per-axis
    z: variation_float  # Per-axis
    w: variation_float  # Per-axis
    def __init__(
        self,
        mode: int = int(),
        amount: Optional[ImVec4Like] = None,
        min_clamp: Optional[ImVec4Like] = None,
        max_clamp: Optional[ImVec4Like] = None,
        callback: Optional[variation_vec4_fn] = None,
        x: Optional[variation_float] = None,
        y: Optional[variation_float] = None,
        z: Optional[variation_float] = None,
        w: Optional[variation_float] = None
        ) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * amount: ImVec4()
                * min_clamp: ImVec4()
                * max_clamp: ImVec4()
                * callback: variation_vec4_fn()
                * x: variation_float()
                * y: variation_float()
                * z: variation_float()
                * w: variation_float()
        """
        pass

class variation_color:
    """ Color variation (global mode or per-channel)"""
    mode: int
    amount: ImVec4
    min_clamp: ImVec4
    max_clamp: ImVec4
    color_space: int             # col_oklab, etc.
    seed: int
    callback: variation_vec4_fn  # Returns ImVec4 color delta
    user: Any
    r: variation_float           # Per-channel
    g: variation_float           # Per-channel
    b: variation_float           # Per-channel
    a: variation_float           # Per-channel
    def __init__(
        self,
        mode: int = int(),
        amount: Optional[ImVec4Like] = None,
        min_clamp: Optional[ImVec4Like] = None,
        max_clamp: Optional[ImVec4Like] = None,
        color_space: int = int(),
        callback: Optional[variation_vec4_fn] = None,
        r: Optional[variation_float] = None,
        g: Optional[variation_float] = None,
        b: Optional[variation_float] = None,
        a: Optional[variation_float] = None
        ) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * amount: ImVec4()
                * min_clamp: ImVec4()
                * max_clamp: ImVec4()
                * callback: variation_vec4_fn()
                * r: variation_float()
                * g: variation_float()
                * b: variation_float()
                * a: variation_float()
        """
        pass

# ----------------------------------------------------
# Variation helper functions (C11-style inline)
# ----------------------------------------------------

# Float variation helpers
def varf_none() -> variation_float:
    pass
def varf_inc(amt: float) -> variation_float:
    pass
def varf_dec(amt: float) -> variation_float:
    pass
def varf_mul(f: float) -> variation_float:
    pass
def varf_rand(r: float) -> variation_float:
    pass
def varf_rand_abs(r: float) -> variation_float:
    pass
def varf_pingpong(amt: float) -> variation_float:
    pass
def varf_fn(fn: variation_float_fn, user: Any) -> variation_float:
    pass
def varf_clamp(v: variation_float, mn: float, mx: float) -> variation_float:
    pass
def varf_seed(v: variation_float, s: int) -> variation_float:
    pass

# Int variation helpers
def vari_none() -> variation_int:
    pass
def vari_inc(amt: int) -> variation_int:
    pass
def vari_dec(amt: int) -> variation_int:
    pass
def vari_rand(r: int) -> variation_int:
    pass
def vari_fn(fn: variation_int_fn, user: Any) -> variation_int:
    pass
def vari_clamp(v: variation_int, mn: int, mx: int) -> variation_int:
    pass
def vari_seed(v: variation_int, s: int) -> variation_int:
    pass

# Vec2 variation helpers (global)
def varv2_none() -> variation_vec2:
    pass
def varv2_inc(x: float, y: float) -> variation_vec2:
    pass
def varv2_dec(x: float, y: float) -> variation_vec2:
    pass
def varv2_mul(f: float) -> variation_vec2:
    pass
def varv2_rand(x: float, y: float) -> variation_vec2:
    pass
def varv2_fn(fn: variation_vec2_fn, user: Any) -> variation_vec2:
    pass
# Vec2 per-axis helper
def varv2_axis(vx: variation_float, vy: variation_float) -> variation_vec2:
    pass
def varv2_clamp(v: variation_vec2, mn: ImVec2Like, mx: ImVec2Like) -> variation_vec2:
    pass
def varv2_seed(v: variation_vec2, s: int) -> variation_vec2:
    pass

# Vec4 variation helpers (global)
def varv4_none() -> variation_vec4:
    pass
def varv4_inc(x: float, y: float, z: float, w: float) -> variation_vec4:
    pass
def varv4_dec(x: float, y: float, z: float, w: float) -> variation_vec4:
    pass
def varv4_mul(f: float) -> variation_vec4:
    pass
def varv4_rand(x: float, y: float, z: float, w: float) -> variation_vec4:
    pass
def varv4_fn(fn: variation_vec4_fn, user: Any) -> variation_vec4:
    pass
# Vec4 per-axis helper
def varv4_axis(
    vx: variation_float,
    vy: variation_float,
    vz: variation_float,
    vw: variation_float
    ) -> variation_vec4:
    pass
def varv4_clamp(v: variation_vec4, mn: ImVec4Like, mx: ImVec4Like) -> variation_vec4:
    pass
def varv4_seed(v: variation_vec4, s: int) -> variation_vec4:
    pass

# Color variation helpers (global)
def varc_none() -> variation_color:
    pass
def varc_inc(r: float, g: float, b: float, a: float) -> variation_color:
    pass
def varc_dec(r: float, g: float, b: float, a: float) -> variation_color:
    pass
def varc_mul(f: float) -> variation_color:
    pass
def varc_rand(r: float, g: float, b: float, a: float) -> variation_color:
    pass
def varc_fn(fn: variation_vec4_fn, user: Any) -> variation_color:
    pass
# Color per-channel helper
def varc_channel(
    vr: variation_float,
    vg: variation_float,
    vb: variation_float,
    va: variation_float
    ) -> variation_color:
    pass
def varc_space(v: variation_color, space: int) -> variation_color:
    pass
def varc_clamp(v: variation_color, mn: ImVec4Like, mx: ImVec4Like) -> variation_color:
    pass
def varc_seed(v: variation_color, s: int) -> variation_color:
    pass

# Forward declarations


class clip:
    """ ----------------------------------------------------
     clip - fluent API for authoring animations
     ----------------------------------------------------
    """
    @staticmethod
    def begin(clip_id: int) -> clip:
        """ Start building a new clip with the given ID"""
        pass

    # Add keyframes for different channel types
    def key_float(
        self,
        channel: int,
        time: float,
        value: float,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_vec2(
        self,
        channel: int,
        time: float,
        value: ImVec2Like,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_vec4(
        self,
        channel: int,
        time: float,
        value: ImVec4Like,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_int(
        self,
        channel: int,
        time: float,
        value: int,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_color(
        self,
        channel: int,
        time: float,
        value: ImVec4Like,
        color_space: int = color_space.col_oklab,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass

    # Keyframes with repeat variation (value changes per loop iteration)
    def key_float_var(
        self,
        channel: int,
        time: float,
        value: float,
        var: variation_float,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_vec2_var(
        self,
        channel: int,
        time: float,
        value: ImVec2Like,
        var: variation_vec2,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_vec4_var(
        self,
        channel: int,
        time: float,
        value: ImVec4Like,
        var: variation_vec4,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_int_var(
        self,
        channel: int,
        time: float,
        value: int,
        var: variation_int,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_color_var(
        self,
        channel: int,
        time: float,
        value: ImVec4Like,
        var: variation_color,
        color_space: int = color_space.col_oklab,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass

    def key_float_spring(
        self,
        channel: int,
        time: float,
        target: float,
        spring: spring_params
        ) -> clip:
        """ Spring-based keyframe (float only)"""
        pass

    # Anchor-relative keyframes (values resolved relative to window/viewport at get time)
    def key_float_rel(
        self,
        channel: int,
        time: float,
        percent: float,
        px_bias: float,
        anchor_space: int,
        axis: int,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_vec2_rel(
        self,
        channel: int,
        time: float,
        percent: ImVec2Like,
        px_bias: ImVec2Like,
        anchor_space: int,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_vec4_rel(
        self,
        channel: int,
        time: float,
        percent: ImVec4Like,
        px_bias: ImVec4Like,
        anchor_space: int,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    def key_color_rel(
        self,
        channel: int,
        time: float,
        percent: ImVec4Like,
        px_bias: ImVec4Like,
        color_space: int,
        anchor_space: int,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass

    # Timeline grouping - sequential and parallel keyframe blocks
    def seq_begin(self) -> clip:
        """ Start sequential block (keyframes after seq_end start after this block)"""
        pass
    def seq_end(self) -> clip:
        pass
    def par_begin(self) -> clip:
        """ Start parallel block (keyframes play at same time offset)"""
        pass
    def par_end(self) -> clip:
        pass

    # Timeline markers - callbacks at specific times during playback
    @overload
    def marker(self, time: float, marker_id: int, cb: marker_callback) -> clip:
        """ Add marker at specific time."""
        pass
    @overload
    def marker(self, time: float, cb: marker_callback) -> clip:
        """ Add marker (auto-generated ID)."""
        pass

    # Clip options
    def set_loop(
        self,
        loop: bool,
        direction: int = direction.dir_normal,
        loop_count: int = -1
        ) -> clip:
        pass
    def set_delay(self, delay_seconds: float) -> clip:
        pass
    def set_stagger(
        self,
        count: int,
        each_delay: float,
        from_center_bias: float = 0.0
        ) -> clip:
        pass

    # Timing variation per loop iteration
    def set_duration_var(self, var: variation_float) -> clip:
        """ Vary clip duration per loop"""
        pass
    def set_delay_var(self, var: variation_float) -> clip:
        """ Vary delay between loops"""
        pass
    def set_timescale_var(self, var: variation_float) -> clip:
        """ Vary playback speed per loop"""
        pass

    # Callbacks
    def on_begin(self, cb: clip_callback) -> clip:
        pass
    def on_update(self, cb: clip_callback) -> clip:
        pass
    def on_complete(self, cb: clip_callback) -> clip:
        pass

    def end(self) -> None:
        """ Finalize the clip"""
        pass

    def id(self) -> int:
        """ Get the clip ID"""
        pass


class instance:
    """ ----------------------------------------------------
     instance - playback control for a clip
     ----------------------------------------------------
    """
    @overload
    def __init__(self) -> None:
        pass
    @overload
    def __init__(self, inst_id: int) -> None:
        pass

    # Playback control
    def pause(self) -> None:
        pass
    def resume(self) -> None:
        pass
    def stop(self) -> None:
        pass
    def destroy(self) -> None:
        """ Remove instance from system (valid() will return False after this)"""
        pass
    def seek(self, time: float) -> None:
        pass
    def set_time_scale(self, scale: float) -> None:
        pass
    def set_weight(self, weight: float) -> None:
        """ for layering/blending"""
        pass

    # Animation chaining - play another clip when this one completes
    @overload
    def then(self, next_clip_id: int) -> instance:
        """ Chain another clip to play after this one."""
        pass
    @overload
    def then(self, next_clip_id: int, next_instance_id: int) -> instance:
        """ Chain with specific instance ID."""
        pass
    def then_delay(self, delay: float) -> instance:
        """ Set delay before chained clip starts."""
        pass

    # Query state
    def time(self) -> float:
        pass
    def duration(self) -> float:
        pass
    def is_playing(self) -> bool:
        pass
    def is_paused(self) -> bool:
        pass

    # Get animated values
    def get_float(self, channel: int, out: float) -> bool:
        pass
    def get_vec2(self, channel: int, out: ImVec2Like) -> bool:
        pass
    def get_vec4(self, channel: int, out: ImVec4Like) -> bool:
        pass
    def get_int(self, channel: int, out: int) -> bool:
        pass
    def get_color(
        self,
        channel: int,
        out: ImVec4Like,
        color_space: int = color_space.col_oklab
        ) -> bool:
        """ Color blended in specified color space."""
        pass

    def valid(self) -> bool:
        """ Check validity"""
        pass
    def __bool__(self) -> bool:
        pass

    def id(self) -> int:
        pass


# ----------------------------------------------------
# Clip System API
# ----------------------------------------------------

# Initialize/shutdown (optional - auto-init on first use)
def clip_init(initial_clip_cap: int = 256, initial_inst_cap: int = 4096) -> None:
    pass
def clip_shutdown() -> None:
    pass

def clip_update(dt: float) -> None:
    """ Per-frame update (call after update_begin_frame)"""
    pass

def clip_gc(max_age_frames: int = 600) -> None:
    """ Garbage collection for instances"""
    pass

def play(clip_id: int, instance_id: int) -> instance:
    """ Play a clip on an instance (creates or reuses instance)"""
    pass

def get_instance(instance_id: int) -> instance:
    """ Get an existing instance (returns invalid instance if not found)"""
    pass

# Query clip info
def clip_duration(clip_id: int) -> float:
    """ Get clip duration in seconds."""
    pass
def clip_exists(clip_id: int) -> bool:
    """ Check if clip exists."""
    pass

# Stagger helpers - compute delay for indexed instances
def stagger_delay(clip_id: int, index: int) -> float:
    """ Get stagger delay for element at index."""
    pass
def play_stagger(clip_id: int, instance_id: int, index: int) -> instance:
    """ Play with stagger delay applied."""
    pass

# Layering support - blend multiple animation instances
def layer_begin(instance_id: int) -> None:
    """ Start blending into target instance."""
    pass
def layer_add(inst: instance, weight: float) -> None:
    """ Add source instance with weight."""
    pass
def layer_end(instance_id: int) -> None:
    """ Finalize blending and normalize weights."""
    pass
def get_blended_float(instance_id: int, channel: int, out: float) -> bool:
    """ Get blended float value."""
    pass
def get_blended_vec2(instance_id: int, channel: int, out: ImVec2Like) -> bool:
    """ Get blended vec2 value."""
    pass
def get_blended_vec4(instance_id: int, channel: int, out: ImVec4Like) -> bool:
    """ Get blended vec4 value."""
    pass
def get_blended_int(instance_id: int, channel: int, out: int) -> bool:
    """ Get blended int value."""
    pass

# Persistence (optional)
def clip_save(clip_id: int, path: str) -> result:
    pass
def clip_load(path: str, out_clip_id: ImGuiID) -> result:
    pass

# ----------------------------------------------------
# Usage notes (summary)
# ----------------------------------------------------
# TWEEN API:
# 1) Call update_begin_frame() once per frame; use ImGui::GetIO().DeltaTime as dt.
# 2) For each widget/object, pick a stable ImGuiID (e.g. ImGui::GetItemID()) and a channel_id (ImHashStr("alpha")).
# 3) Call tween_* to get the animated value, then apply it (PushStyleVar, etc).
# 4) Optionally call gc(600) every second to bound memory.
# 5) Use tween_vec2_rel / tween_vec2_resolved / rebase_vec2 to keep animations smooth on window/dock/viewport changes.
#
# CLIP API:
# 1) Author clips once at startup using clip::begin(id).key_*(...).end()
# 2) Call clip_update(dt) each frame after update_begin_frame()
# 3) Use play(clip_id, instance_id) to start playback; returns instance for queries
# 4) Call inst.get_float/vec2/vec4/int() to sample animated values
# 5) Optionally call clip_gc(600) to bound instance memory

# ----------------------------------------------------
# Demo and doc launchers (see im_anim_demo.cpp, im_anim_docs.cpp, im_anim_usecase.cpp)
# ----------------------------------------------------
def demo_window(create_window: bool = True) -> None:
    pass
def doc_window(create_window: bool = True) -> None:
    pass
def usecase_window(create_window: bool = True) -> None:
    pass
####################    </generated_from:im_anim.h>    ####################

# </litgen_stub> // Autogenerated code end!
