###############################################################################
# This file is a part of Dear ImGui Bundle, NOT a part of ImAnim
# -----------------------------------------------------------------------------
# im_anim.pyi is the equivalent of im_anim.h, using the bindings provided
# by Dear ImGui Bundle.
#
# It is automatically generated (using https://pthom.github.io/litgen/),
# and is generally very close to the C++ version. Comments, docs are identical.
###############################################################################
# ruff: noqa: B008
from typing import Optional, Callable, Any, overload, Tuple
from imgui_bundle.imgui import ImVec2, ImVec2Like, ImVec4, ImVec4Like, ImU32, ImFont, Style, ImVector_float, ImVector_ImVec4
import enum

ImGuiID = int
ImGuiStyle = Style

# Callback type aliases
ease_fn = Callable[[float], float]

# Variation callbacks (index is the loop iteration)
variation_float_fn = Callable[[int], float]
variation_int_fn = Callable[[int], int]
variation_vec2_fn = Callable[[int], ImVec2]
variation_vec4_fn = Callable[[int], ImVec4]

# Resolver callbacks (return dynamic target value)
float_resolver = Callable[[], float]
vec2_resolver = Callable[[], ImVec2]
vec4_resolver = Callable[[], ImVec4]
color_resolver = Callable[[], ImVec4]
int_resolver = Callable[[], int]

# Clip callbacks
clip_callback = Callable[[int], None]  # inst_id
marker_callback = Callable[[int, int, float], None]  # inst_id, marker_id, marker_time


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:im_anim.h>    ####################
# im_anim.h â€” Dear ImGui animation helpers.
# Author: Soufiane KHIAT
# License: MIT
# Version: 1.0.0
#
# - Channels: float, vec2, vec4, int, color (sRGB/Linear/HSV/OKLAB/OKLCH blending).
# - Easing: presets + cubicBezier/steps/back/elastic/bounce/spring.
# - Caching: ImPool + ImGuiStorage keyed by (ImGuiID, channel_id) via ImHashData.
# - Resize helpers: relative targets, resolver callback, explicit rebase.


# Version information

# #ifdef IMGUI_BUNDLE_PYTHON_API
#
# #endif
#


# ----------------------------------------------------
# Python Bindings Status (Dear ImGui Bundle)
# ----------------------------------------------------
# The following features are bound to Python via Dear ImGui Bundle:
#   - Easing presets and descriptors (ease_type, ease_desc, shorthands)
#   - Frame management (update_begin_frame, gc, etc.)
#   - Tween API (tween_float/vec2/vec4/int/color)
#   - Rebase functions (rebase_*)
#   - Oscillators (oscillate_*)
#   - Shake and wiggle (shake_*, wiggle_*)
#   - Scroll animation (scroll_to_*)
#   - Clip system (clip, instance, play, etc.)
#   - Color blending (get_blended_color)
#   - Debug UI (show_unified_inspector, show_debug_timeline)
#
# Sections marked [C++ only] below are not available in
# the Python bindings.
# ----------------------------------------------------

# PI constants

class ease_type(enum.IntEnum):
    """ ----------------------------------------------------
     Public enums & descriptors (C-style)
     ----------------------------------------------------
    """
    # ease_linear = 0,    /* original C++ signature */
    ease_linear = enum.auto()         # (= 0)
    # ease_in_quad,      /* original C++ signature */
    ease_in_quad = enum.auto()        # (= 1)
    # ease_out_quad,      /* original C++ signature */
    ease_out_quad = enum.auto()       # (= 2)
    # ease_in_out_quad,    /* original C++ signature */
    ease_in_out_quad = enum.auto()    # (= 3)
    # ease_in_cubic,     /* original C++ signature */
    ease_in_cubic = enum.auto()       # (= 4)
    # ease_out_cubic,     /* original C++ signature */
    ease_out_cubic = enum.auto()      # (= 5)
    # ease_in_out_cubic,    /* original C++ signature */
    ease_in_out_cubic = enum.auto()   # (= 6)
    # ease_in_quart,     /* original C++ signature */
    ease_in_quart = enum.auto()       # (= 7)
    # ease_out_quart,     /* original C++ signature */
    ease_out_quart = enum.auto()      # (= 8)
    # ease_in_out_quart,    /* original C++ signature */
    ease_in_out_quart = enum.auto()   # (= 9)
    # ease_in_quint,     /* original C++ signature */
    ease_in_quint = enum.auto()       # (= 10)
    # ease_out_quint,     /* original C++ signature */
    ease_out_quint = enum.auto()      # (= 11)
    # ease_in_out_quint,    /* original C++ signature */
    ease_in_out_quint = enum.auto()   # (= 12)
    # ease_in_sine,      /* original C++ signature */
    ease_in_sine = enum.auto()        # (= 13)
    # ease_out_sine,      /* original C++ signature */
    ease_out_sine = enum.auto()       # (= 14)
    # ease_in_out_sine,    /* original C++ signature */
    ease_in_out_sine = enum.auto()    # (= 15)
    # ease_in_expo,      /* original C++ signature */
    ease_in_expo = enum.auto()        # (= 16)
    # ease_out_expo,      /* original C++ signature */
    ease_out_expo = enum.auto()       # (= 17)
    # ease_in_out_expo,    /* original C++ signature */
    ease_in_out_expo = enum.auto()    # (= 18)
    # ease_in_circ,      /* original C++ signature */
    ease_in_circ = enum.auto()        # (= 19)
    # ease_out_circ,      /* original C++ signature */
    ease_out_circ = enum.auto()       # (= 20)
    # ease_in_out_circ,    /* original C++ signature */
    ease_in_out_circ = enum.auto()    # (= 21)
    # ease_in_back,      /* original C++ signature */
    ease_in_back = enum.auto()        # (= 22)
    # ease_out_back,      /* original C++ signature */
    ease_out_back = enum.auto()       # (= 23)
    # ease_in_out_back,            /* original C++ signature */
    ease_in_out_back = enum.auto()    # (= 24)  # p0 = overshoot
    # ease_in_elastic,     /* original C++ signature */
    ease_in_elastic = enum.auto()     # (= 25)
    # ease_out_elastic,     /* original C++ signature */
    ease_out_elastic = enum.auto()    # (= 26)
    # ease_in_out_elastic,      /* original C++ signature */
    ease_in_out_elastic = enum.auto() # (= 27)  # p0 = amplitude, p1 = period
    # ease_in_bounce,      /* original C++ signature */
    ease_in_bounce = enum.auto()      # (= 28)
    # ease_out_bounce,      /* original C++ signature */
    ease_out_bounce = enum.auto()     # (= 29)
    # ease_in_out_bounce,    /* original C++ signature */
    ease_in_out_bounce = enum.auto()  # (= 30)
    # ease_steps,             /* original C++ signature */
    ease_steps = enum.auto()          # (= 31)  # p0 = steps (>=1), p1 = 0:end 1:start 2:both
    # ease_cubic_bezier,      /* original C++ signature */
    ease_cubic_bezier = enum.auto()   # (= 32)  # p0=x1 p1=y1 p2=x2 p3=y2
    # ease_spring,            /* original C++ signature */
    ease_spring = enum.auto()         # (= 33)  # p0=mass p1=stiffness p2=damping p3=v0
    # ease_custom             /* original C++ signature */
    ease_custom = enum.auto()         # (= 34)  # User-defined easing function (use ease_custom_fn)

class policy(enum.IntEnum):
    # policy_crossfade = 0,	    /* original C++ signature */
    crossfade = enum.auto() # (= 0)  # smooth into new target
    # policy_cut,				    /* original C++ signature */
    cut = enum.auto()       # (= 1)  # snap to target
    # policy_queue			    /* original C++ signature */
    queue = enum.auto()     # (= 2)  # queue one pending target

class color_space(enum.IntEnum):
    # col_srgb = 0,			    /* original C++ signature */
    col_srgb = enum.auto()        # (= 0)  # blend in sRGB (not physically linear)
    # col_srgb_linear,		    /* original C++ signature */
    col_srgb_linear = enum.auto() # (= 1)  # sRGB<->linear, blend in linear, back to sRGB
    # col_hsv,				    /* original C++ signature */
    col_hsv = enum.auto()         # (= 2)  # blend H/S/V (hue shortest arc), keep A linear
    # col_oklab,				    /* original C++ signature */
    col_oklab = enum.auto()       # (= 3)  # sRGB<->OKLAB, blend in OKLAB, back to sRGB
    # col_oklch				    /* original C++ signature */
    col_oklch = enum.auto()       # (= 4)  # sRGB<->OKLCH (cylindrical OKLAB), blend in OKLCH, back to sRGB


class ease_desc:
    """ Descriptor for any easing (preset or parametric)"""
    # int		type;    /* original C++ signature */
    type: int  # ease_type
    # float	p0,     /* original C++ signature */
    p0: float
    # p1,     /* original C++ signature */
    p1: float
    # p2,     /* original C++ signature */
    p2: float
    # p3;    /* original C++ signature */
    p3: float
    # ease_desc(int type = int(), float p0 = float(), float p1 = float(), float p2 = float(), float p3 = float());    /* original C++ signature */
    def __init__(
        self,
        type: int = int(),
        p0: float = float(),
        p1: float = float(),
        p2: float = float(),
        p3: float = float()
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# Custom easing function callback (t in [0,1], returns eased value)
# [ADAPT_IMGUI_BUNDLE] - use ImAnimHybridCallback to switch between function pointer and std::function
# #ifdef IMGUI_BUNDLE_PYTHON_API
#
# #else
#
# #endif
#
# [/ADAPT_IMGUI_BUNDLE]

# ----------------------------------------------------
# Public API declarations
# ----------------------------------------------------

# Frame management
# void update_begin_frame();                                                          /* original C++ signature */
def update_begin_frame() -> None:
    """ Call once per frame before any tweens."""
    pass
# void gc(unsigned int max_age_frames = 600);                                         /* original C++ signature */
def gc(max_age_frames: int = 600) -> None:
    """ Remove stale tween entries older than max_age_frames."""
    pass
# void pool_clear();																	    /* original C++ signature */
def pool_clear() -> None:
    """ Manually clean up pools."""
    pass
# void reserve(int cap_float, int cap_vec2, int cap_vec4, int cap_int, int cap_color);     /* original C++ signature */
def reserve(
    cap_float: int,
    cap_vec2: int,
    cap_vec4: int,
    cap_int: int,
    cap_color: int
    ) -> None:
    """ Pre-allocate pool capacity."""
    pass
# void set_ease_lut_samples(int count);                                               /* original C++ signature */
def set_ease_lut_samples(count: int) -> None:
    """ Set LUT resolution for parametric easings (default: 256)."""
    pass

# Global time scale (for slow-motion / fast-forward debugging)
# void  set_global_time_scale(float scale);                                           /* original C++ signature */
def set_global_time_scale(scale: float) -> None:
    """ Set global time multiplier (1.0 = normal, 0.5 = half speed, 2.0 = double)."""
    pass
# float get_global_time_scale();                                                      /* original C++ signature */
def get_global_time_scale() -> float:
    """ Get current global time scale."""
    pass

# Lazy Initialization - defer channel creation until animation is needed
# void set_lazy_init(bool enable);                                                    /* original C++ signature */
def set_lazy_init(enable: bool) -> None:
    """ Enable/disable lazy initialization (default: True)."""
    pass
# bool is_lazy_init_enabled();                                                        /* original C++ signature */
def is_lazy_init_enabled() -> bool:
    """ Check if lazy init is enabled."""
    pass

# Custom easing functions
# void register_custom_ease(int slot, ease_fn fn);                                /* original C++ signature */
def register_custom_ease(slot: int, fn: ease_fn) -> None:
    """ Register custom easing in slot 0-15. Use with ease_custom_fn(slot)."""
    pass
# ease_fn get_custom_ease(int slot);                                              /* original C++ signature */
def get_custom_ease(slot: int) -> ease_fn:
    """ Get registered custom easing function."""
    pass

# Debug UI
# void show_unified_inspector(bool* p_open = nullptr);                                /* original C++ signature */
def show_unified_inspector(p_open: Optional[bool] = None) -> Optional[bool]:
    """ Show unified inspector (merges debug window + animation inspector)."""
    pass
# void show_debug_timeline(ImGuiID instance_id);                                      /* original C++ signature */
def show_debug_timeline(instance_id: int) -> None:
    """ Show debug timeline for a clip instance."""
    pass

# Performance Profiler [C++ only]




class wave_type(enum.IntEnum):
    """ Oscillators - continuous periodic animations"""
    # wave_sine = 0,          /* original C++ signature */
    wave_sine = enum.auto()     # (= 0)  # Smooth sine wave
    # wave_triangle,          /* original C++ signature */
    wave_triangle = enum.auto() # (= 1)  # Triangle wave (linear up/down)
    # wave_sawtooth,          /* original C++ signature */
    wave_sawtooth = enum.auto() # (= 2)  # Sawtooth wave (linear up, instant reset)
    # wave_square             /* original C++ signature */
    wave_square = enum.auto()   # (= 3)  # Square wave (on/off pulse)
# float  oscillate(ImGuiID id, float amplitude, float frequency, int wave_type, float phase, float dt);           /* original C++ signature */
def oscillate(
    id: int,
    amplitude: float,
    frequency: float,
    wave_type: int,
    phase: float,
    dt: float
    ) -> float:
    """ Returns oscillating value [-amplitude, +amplitude]."""
    pass
# int    oscillate_int(ImGuiID id, int amplitude, float frequency, int wave_type, float phase, float dt);          /* original C++ signature */
def oscillate_int(
    id: int,
    amplitude: int,
    frequency: float,
    wave_type: int,
    phase: float,
    dt: float
    ) -> int:
    """ Returns oscillating integer value [-amplitude, +amplitude]."""
    pass
# ImVec2 oscillate_vec2(ImGuiID id, ImVec2 amplitude, ImVec2 frequency, int wave_type, ImVec2 phase, float dt);     /* original C++ signature */
def oscillate_vec2(
    id: int,
    amplitude: ImVec2Like,
    frequency: ImVec2Like,
    wave_type: int,
    phase: ImVec2Like,
    dt: float
    ) -> ImVec2:
    """ 2D oscillation."""
    pass
# ImVec4 oscillate_vec4(ImGuiID id, ImVec4 amplitude, ImVec4 frequency, int wave_type, ImVec4 phase, float dt);     /* original C++ signature */
def oscillate_vec4(
    id: int,
    amplitude: ImVec4Like,
    frequency: ImVec4Like,
    wave_type: int,
    phase: ImVec4Like,
    dt: float
    ) -> ImVec4:
    """ 4D oscillation."""
    pass
# ImVec4 oscillate_color(ImGuiID id, ImVec4 base_color, ImVec4 amplitude, float frequency, int wave_type, float phase, int color_space, float dt);     /* original C++ signature */
def oscillate_color(
    id: int,
    base_color: ImVec4Like,
    amplitude: ImVec4Like,
    frequency: float,
    wave_type: int,
    phase: float,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Color oscillation in specified color space."""
    pass

# Shake/Wiggle - procedural noise animations
# float  shake(ImGuiID id, float intensity, float frequency, float decay_time, float dt);           /* original C++ signature */
def shake(
    id: int,
    intensity: float,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> float:
    """ Decaying random shake. Returns offset that decays to 0."""
    pass
# int    shake_int(ImGuiID id, int intensity, float frequency, float decay_time, float dt);         /* original C++ signature */
def shake_int(
    id: int,
    intensity: int,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> int:
    """ Decaying random shake for integers."""
    pass
# ImVec2 shake_vec2(ImGuiID id, ImVec2 intensity, float frequency, float decay_time, float dt);     /* original C++ signature */
def shake_vec2(
    id: int,
    intensity: ImVec2Like,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> ImVec2:
    """ 2D decaying shake."""
    pass
# ImVec4 shake_vec4(ImGuiID id, ImVec4 intensity, float frequency, float decay_time, float dt);     /* original C++ signature */
def shake_vec4(
    id: int,
    intensity: ImVec4Like,
    frequency: float,
    decay_time: float,
    dt: float
    ) -> ImVec4:
    """ 4D decaying shake."""
    pass
# ImVec4 shake_color(ImGuiID id, ImVec4 base_color, ImVec4 intensity, float frequency, float decay_time, int color_space, float dt);     /* original C++ signature */
def shake_color(
    id: int,
    base_color: ImVec4Like,
    intensity: ImVec4Like,
    frequency: float,
    decay_time: float,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Color shake in specified color space."""
    pass
# float  wiggle(ImGuiID id, float amplitude, float frequency, float dt);                            /* original C++ signature */
def wiggle(id: int, amplitude: float, frequency: float, dt: float) -> float:
    """ Continuous smooth random movement."""
    pass
# int    wiggle_int(ImGuiID id, int amplitude, float frequency, float dt);                          /* original C++ signature */
def wiggle_int(id: int, amplitude: int, frequency: float, dt: float) -> int:
    """ Continuous smooth random movement for integers."""
    pass
# ImVec2 wiggle_vec2(ImGuiID id, ImVec2 amplitude, float frequency, float dt);                      /* original C++ signature */
def wiggle_vec2(id: int, amplitude: ImVec2Like, frequency: float, dt: float) -> ImVec2:
    """ 2D continuous wiggle."""
    pass
# ImVec4 wiggle_vec4(ImGuiID id, ImVec4 amplitude, float frequency, float dt);                      /* original C++ signature */
def wiggle_vec4(id: int, amplitude: ImVec4Like, frequency: float, dt: float) -> ImVec4:
    """ 4D continuous wiggle."""
    pass
# ImVec4 wiggle_color(ImGuiID id, ImVec4 base_color, ImVec4 amplitude, float frequency, int color_space, float dt);     /* original C++ signature */
def wiggle_color(
    id: int,
    base_color: ImVec4Like,
    amplitude: ImVec4Like,
    frequency: float,
    color_space: int,
    dt: float
    ) -> ImVec4:
    """ Color wiggle in specified color space."""
    pass
# void   trigger_shake(ImGuiID id);                                                                 /* original C++ signature */
def trigger_shake(id: int) -> None:
    """ Trigger/restart a shake animation."""
    pass

# Easing evaluation
# float eval_preset(int type, float t);                                               /* original C++ signature */
def eval_preset(type: int, t: float) -> float:
    """ Evaluate a preset easing function at time t (0-1)."""
    pass

# Tween API - smoothly interpolate values over time
# init_value: Initial value when channel is first created. Defaults to 0 (or white for color).
#             Use this to avoid unwanted animations when the first target differs from the default.
# float  tween_float(ImGuiID id, ImGuiID channel_id, float target, float dur, ease_desc const& ez, int policy, float dt, float init_value = 0.0f);       /* original C++ signature */
def tween_float(
    id: int,
    channel_id: int,
    target: float,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: float = 0.0
    ) -> float:
    """ Animate a float value."""
    pass
# ImVec2 tween_vec2(ImGuiID id, ImGuiID channel_id, ImVec2 target, float dur, ease_desc const& ez, int policy, float dt, ImVec2 init_value = ImVec2(0, 0));       /* original C++ signature */
def tween_vec2(
    id: int,
    channel_id: int,
    target: ImVec2Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: Optional[ImVec2Like] = None
    ) -> ImVec2:
    """Python bindings defaults:
        If init_value is None, then its default value will be: ImVec2(0, 0)

     Animate a 2D vector.
    """
    pass
# ImVec4 tween_vec4(ImGuiID id, ImGuiID channel_id, ImVec4 target, float dur, ease_desc const& ez, int policy, float dt, ImVec4 init_value = ImVec4(0, 0, 0, 0));       /* original C++ signature */
def tween_vec4(
    id: int,
    channel_id: int,
    target: ImVec4Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: Optional[ImVec4Like] = None
    ) -> ImVec4:
    """Python bindings defaults:
        If init_value is None, then its default value will be: ImVec4(0, 0, 0, 0)

     Animate a 4D vector.
    """
    pass
# int    tween_int(ImGuiID id, ImGuiID channel_id, int target, float dur, ease_desc const& ez, int policy, float dt, int init_value = 0);           /* original C++ signature */
def tween_int(
    id: int,
    channel_id: int,
    target: int,
    dur: float,
    ez: ease_desc,
    policy: int,
    dt: float,
    init_value: int = 0
    ) -> int:
    """ Animate an integer value."""
    pass
# ImVec4 tween_color(ImGuiID id, ImGuiID channel_id, ImVec4 target_srgb, float dur, ease_desc const& ez, int policy, int color_space, float dt, ImVec4 init_value = ImVec4(1, 1, 1, 1));     /* original C++ signature */
def tween_color(
    id: int,
    channel_id: int,
    target_srgb: ImVec4Like,
    dur: float,
    ez: ease_desc,
    policy: int,
    color_space: int,
    dt: float,
    init_value: Optional[ImVec4Like] = None
    ) -> ImVec4:
    """Python bindings defaults:
        If init_value is None, then its default value will be: ImVec4(1, 1, 1, 1)

     Animate a color in specified color space.
    """
    pass

# Resize-friendly helpers [C++ only]

# Relative target tweens (percent of anchor + pixel offset) - survive window resizes [C++ only]

# Resolver callbacks for dynamic target computation [C++ only]

# Resolved tweens - target computed dynamically by callback each frame [C++ only]

# Rebase functions - change target of in-progress animation without restarting
# void rebase_float(ImGuiID id, ImGuiID channel_id, float new_target, float dt);      /* original C++ signature */
def rebase_float(id: int, channel_id: int, new_target: float, dt: float) -> None:
    """ Smoothly redirect float animation to new target."""
    pass
# void rebase_vec2(ImGuiID id, ImGuiID channel_id, ImVec2 new_target, float dt);      /* original C++ signature */
def rebase_vec2(id: int, channel_id: int, new_target: ImVec2Like, dt: float) -> None:
    """ Smoothly redirect vec2 animation to new target."""
    pass
# void rebase_vec4(ImGuiID id, ImGuiID channel_id, ImVec4 new_target, float dt);      /* original C++ signature */
def rebase_vec4(id: int, channel_id: int, new_target: ImVec4Like, dt: float) -> None:
    """ Smoothly redirect vec4 animation to new target."""
    pass
# void rebase_color(ImGuiID id, ImGuiID channel_id, ImVec4 new_target, float dt);     /* original C++ signature */
def rebase_color(id: int, channel_id: int, new_target: ImVec4Like, dt: float) -> None:
    """ Smoothly redirect color animation to new target."""
    pass
# void rebase_int(ImGuiID id, ImGuiID channel_id, int new_target, float dt);          /* original C++ signature */
def rebase_int(id: int, channel_id: int, new_target: int, dt: float) -> None:
    """ Smoothly redirect int animation to new target."""
    pass

# Color blending utility
# ImVec4 get_blended_color(ImVec4 a_srgb, ImVec4 b_srgb, float t, int color_space);      /* original C++ signature */
def get_blended_color(
    a_srgb: ImVec4Like,
    b_srgb: ImVec4Like,
    t: float,
    color_space: int
    ) -> ImVec4:
    """ Blend two sRGB colors in specified color space."""
    pass

# ----------------------------------------------------
# Convenience shorthands for common easings
# ----------------------------------------------------
# inline ease_desc ease_preset(int type) { ease_desc e = { type, 0,0,0,0 }; return e; }                                                   /* original C++ signature */
def ease_preset(type: int) -> ease_desc:
    """ Create descriptor from preset enum."""
    pass
# inline ease_desc ease_bezier(float x1, float y1, float x2, float y2) { ease_desc e = { ease_cubic_bezier, x1,y1,x2,y2 }; return e; }     /* original C++ signature */
def ease_bezier(x1: float, y1: float, x2: float, y2: float) -> ease_desc:
    """ Create cubic bezier easing."""
    pass
# inline ease_desc ease_steps_desc(int steps, int mode) { ease_desc e = { ease_steps, (float)steps,(float)mode,0,0 }; return e; }         /* original C++ signature */
def ease_steps_desc(steps: int, mode: int) -> ease_desc:
    """ Create step function easing."""
    pass
# inline ease_desc ease_back(float overshoot) { ease_desc e = { ease_out_back, overshoot,0,0,0 }; return e; }                             /* original C++ signature */
def ease_back(overshoot: float) -> ease_desc:
    """ Create back easing with overshoot."""
    pass
# inline ease_desc ease_elastic(float amplitude, float period) { ease_desc e = { ease_out_elastic, amplitude, period,0,0 }; return e; }     /* original C++ signature */
def ease_elastic(amplitude: float, period: float) -> ease_desc:
    """ Create elastic easing."""
    pass
# inline ease_desc ease_spring_desc(float mass, float stiffness, float damping, float v0) { ease_desc e = { ease_spring, mass, stiffness, damping, v0 }; return e; }     /* original C++ signature */
def ease_spring_desc(
    mass: float,
    stiffness: float,
    damping: float,
    v0: float
    ) -> ease_desc:
    """ Create physics spring."""
    pass
# inline ease_desc ease_custom_fn(int slot) { ease_desc e = { ease_custom, (float)slot,0,0,0 }; return e; }                                                             /* original C++ signature */
def ease_custom_fn(slot: int) -> ease_desc:
    """ Use registered custom easing (slot 0-15)."""
    pass

# Scroll animation - smooth scrolling for ImGui windows
# void scroll_to_y(float target_y, float duration, ease_desc const& ez = ease_preset(ease_out_cubic));               /* original C++ signature */
def scroll_to_y(
    target_y: float,
    duration: float,
    ez: Optional[ease_desc] = None
    ) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll current window to Y position.
    """
    pass
# void scroll_to_x(float target_x, float duration, ease_desc const& ez = ease_preset(ease_out_cubic));               /* original C++ signature */
def scroll_to_x(
    target_x: float,
    duration: float,
    ez: Optional[ease_desc] = None
    ) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll current window to X position.
    """
    pass
# void scroll_to_top(float duration = 0.3f, ease_desc const& ez = ease_preset(ease_out_cubic));                      /* original C++ signature */
def scroll_to_top(duration: float = 0.3, ez: Optional[ease_desc] = None) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll to top of window.
    """
    pass
# void scroll_to_bottom(float duration = 0.3f, ease_desc const& ez = ease_preset(ease_out_cubic));                   /* original C++ signature */
def scroll_to_bottom(
    duration: float = 0.3,
    ez: Optional[ease_desc] = None
    ) -> None:
    """Python bindings defaults:
        If ez is None, then its default value will be: ease_preset(ease_out_cubic)

     Scroll to bottom of window.
    """
    pass

# ----------------------------------------------------
# Per-axis easing - different easing per component [C++ only]
# ----------------------------------------------------


# Tween with per-axis easing - each component uses its own easing curve

# ----------------------------------------------------
# Motion Paths - animate along curves and splines [C++ only]
# ----------------------------------------------------


# Single-curve evaluation functions (stateless, for direct use)

# Derivatives (for tangent/velocity)



# Query path info

# Tween along a path

# ----------------------------------------------------
# Arc-length parameterization (for constant-speed animation) [C++ only]
# ----------------------------------------------------

# Build arc-length lookup table for a path (call once per path, improves accuracy)

# Distance-based path evaluation (uses arc-length LUT for constant speed)

# ----------------------------------------------------
# Path Morphing - interpolate between two paths [C++ only]
# ----------------------------------------------------







# ----------------------------------------------------
# Text along motion paths [C++ only]
# ----------------------------------------------------






# ----------------------------------------------------
# Quad transform helpers (for advanced custom rendering) [C++ only]
# ----------------------------------------------------



# ----------------------------------------------------
# Text Stagger - per-character animation effects [C++ only]
# ----------------------------------------------------






# ----------------------------------------------------
# Noise Channels - Perlin/Simplex noise for organic movement [C++ only]
# ----------------------------------------------------



# Sample noise at a point (returns value in [-1, 1])

# Animated noise channels - continuous noise that evolves over time

# Convenience: smooth random movement (like wiggle but using noise)

# ----------------------------------------------------
# Style Interpolation - animate between ImGuiStyle themes [C++ only]
# ----------------------------------------------------

# Register a named style for interpolation






# ----------------------------------------------------
# Gradient Interpolation - animate between color gradients [C++ only]
# ----------------------------------------------------




# ----------------------------------------------------
# Transform Interpolation - animate 2D transforms [C++ only]
# ----------------------------------------------------







# ============================================================
# CLIP-BASED ANIMATION SYSTEM
# ============================================================

class direction(enum.IntEnum):
    """ Direction for looping animations"""
    # dir_normal = 0,		    /* original C++ signature */
    dir_normal = enum.auto()    # (= 0)  # play forward
    # dir_reverse,		    /* original C++ signature */
    dir_reverse = enum.auto()   # (= 1)  # play backward
    # dir_alternate		    /* original C++ signature */
    dir_alternate = enum.auto() # (= 2)  # ping-pong

class channel_type(enum.IntEnum):
    """ Channel types for keyframes"""
    # chan_float = 0,    /* original C++ signature */
    chan_float = enum.auto()     # (= 0)
    # chan_vec2,    /* original C++ signature */
    chan_vec2 = enum.auto()      # (= 1)
    # chan_vec4,    /* original C++ signature */
    chan_vec4 = enum.auto()      # (= 2)
    # chan_int,    /* original C++ signature */
    chan_int = enum.auto()       # (= 3)
    # chan_color,         /* original C++ signature */
    chan_color = enum.auto()     # (= 4)  # Color with color space (stores in vec4 + color_space metadata)
    # chan_float_rel,     /* original C++ signature */
    chan_float_rel = enum.auto() # (= 5)  # Float relative to anchor (percent + px_bias)
    # chan_vec2_rel,      /* original C++ signature */
    chan_vec2_rel = enum.auto()  # (= 6)  # Vec2 relative to anchor (percent.xy + px_bias.xy)
    # chan_vec4_rel,      /* original C++ signature */
    chan_vec4_rel = enum.auto()  # (= 7)  # Vec4 relative to anchor (percent.xy + px_bias.xy for x,y; z,w absolute)
    # chan_color_rel      /* original C++ signature */
    chan_color_rel = enum.auto() # (= 8)  # Color relative to anchor (for position-based color effects)

class result(enum.IntEnum):
    """ Result codes"""
    # ok = 0,    /* original C++ signature */
    ok = enum.auto()            # (= 0)
    # err_not_found,    /* original C++ signature */
    err_not_found = enum.auto() # (= 1)
    # err_bad_arg,    /* original C++ signature */
    err_bad_arg = enum.auto()   # (= 2)
    # err_no_mem    /* original C++ signature */
    # }
    err_no_mem = enum.auto()    # (= 3)

class spring_params:
    """ Spring parameters for physics-based animation"""
    # float mass;    /* original C++ signature */
    mass: float
    # float stiffness;    /* original C++ signature */
    stiffness: float
    # float damping;    /* original C++ signature */
    damping: float
    # float initial_velocity;    /* original C++ signature */
    initial_velocity: float
    # spring_params(float mass = float(), float stiffness = float(), float damping = float(), float initial_velocity = float());    /* original C++ signature */
    def __init__(
        self,
        mass: float = float(),
        stiffness: float = float(),
        damping: float = float(),
        initial_velocity: float = float()
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# ----------------------------------------------------
# Repeat with Variation - per-loop parameter changes [C++ only]
# ----------------------------------------------------


# Callback types for custom variation logic






# ----------------------------------------------------
# Variation helper functions (C11-style inline) [C++ only]
# ----------------------------------------------------

# Float variation helpers

# Int variation helpers

# Vec2 variation helpers (global)
# Vec2 per-axis helper

# Vec4 variation helpers (global)
# Vec4 per-axis helper

# Color variation helpers (global)
# Color per-channel helper

# Forward declarations

# #ifdef IMGUI_BUNDLE_PYTHON_API
#

# #else
#

# #endif
#

class clip:
    """ ----------------------------------------------------
     clip - fluent API for authoring animations
     ----------------------------------------------------
    """
    # static clip begin(ImGuiID clip_id);    /* original C++ signature */
    @staticmethod
    def begin(clip_id: int) -> clip:
        """ Start building a new clip with the given ID"""
        pass

    # Add keyframes for different channel types
    # clip& key_float(ImGuiID channel, float time, float value, int ease_type = ease_type::ease_linear, float const* bezier4 = nullptr);    /* original C++ signature */
    def key_float(
        self,
        channel: int,
        time: float,
        value: float,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    # clip& key_vec2(ImGuiID channel, float time, ImVec2 value, int ease_type = ease_type::ease_linear, float const* bezier4 = nullptr);    /* original C++ signature */
    def key_vec2(
        self,
        channel: int,
        time: float,
        value: ImVec2Like,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    # clip& key_vec4(ImGuiID channel, float time, ImVec4 value, int ease_type = ease_type::ease_linear, float const* bezier4 = nullptr);    /* original C++ signature */
    def key_vec4(
        self,
        channel: int,
        time: float,
        value: ImVec4Like,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    # clip& key_int(ImGuiID channel, float time, int value, int ease_type = ease_type::ease_linear);    /* original C++ signature */
    def key_int(
        self,
        channel: int,
        time: float,
        value: int,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass
    # clip& key_color(ImGuiID channel, float time, ImVec4 value, int color_space = color_space::col_oklab, int ease_type = ease_type::ease_linear, float const* bezier4 = nullptr);    /* original C++ signature */
    def key_color(
        self,
        channel: int,
        time: float,
        value: ImVec4Like,
        color_space: int = color_space.col_oklab,
        ease_type: int = ease_type.ease_linear
        ) -> clip:
        pass

    # Keyframes with repeat variation (value changes per loop iteration)


    # Anchor-relative keyframes (values resolved relative to window/viewport at get time)

    # Timeline grouping - sequential and parallel keyframe blocks

    # Timeline markers - callbacks at specific times during playback
    # clip& marker(float time, ImGuiID marker_id, marker_callback cb, void* user = nullptr);      /* original C++ signature */
    @overload
    def marker(self, time: float, marker_id: int, cb: marker_callback) -> clip:
        """ Add marker at specific time."""
        pass
    # clip& marker(float time, marker_callback cb, void* user = nullptr);                         /* original C++ signature */
    @overload
    def marker(self, time: float, cb: marker_callback) -> clip:
        """ Add marker (auto-generated ID)."""
        pass

    # Clip options
    # clip& set_loop(bool loop, int direction = direction::dir_normal, int loop_count = -1);    /* original C++ signature */
    def set_loop(
        self,
        loop: bool,
        direction: int = direction.dir_normal,
        loop_count: int = -1
        ) -> clip:
        pass
    # clip& set_delay(float delay_seconds);    /* original C++ signature */
    def set_delay(self, delay_seconds: float) -> clip:
        pass
    # clip& set_stagger(int count, float each_delay, float from_center_bias = 0.0f);    /* original C++ signature */
    def set_stagger(
        self,
        count: int,
        each_delay: float,
        from_center_bias: float = 0.0
        ) -> clip:
        pass

    # Timing variation per loop iteration

    # Callbacks
    # clip& on_begin(clip_callback cb, void* user = nullptr);    /* original C++ signature */
    def on_begin(self, cb: clip_callback) -> clip:
        pass
    # clip& on_update(clip_callback cb, void* user = nullptr);    /* original C++ signature */
    def on_update(self, cb: clip_callback) -> clip:
        pass
    # clip& on_complete(clip_callback cb, void* user = nullptr);    /* original C++ signature */
    def on_complete(self, cb: clip_callback) -> clip:
        pass

    # void end();    /* original C++ signature */
    def end(self) -> None:
        """ Finalize the clip"""
        pass

    # ImGuiID id() const { return m_clip_id; }    /* original C++ signature */
    def id(self) -> int:
        """ Get the clip ID"""
        pass


class instance:
    """ ----------------------------------------------------
     instance - playback control for a clip
     ----------------------------------------------------
    """
    # instance() : m_inst_id(0) {}    /* original C++ signature */
    @overload
    def __init__(self) -> None:
        pass
    # instance(ImGuiID inst_id) : m_inst_id(inst_id) {}    /* original C++ signature */
    @overload
    def __init__(self, inst_id: int) -> None:
        pass

    # Playback control
    # void pause();    /* original C++ signature */
    def pause(self) -> None:
        pass
    # void resume();    /* original C++ signature */
    def resume(self) -> None:
        pass
    # void stop();    /* original C++ signature */
    def stop(self) -> None:
        pass
    # void destroy();      /* original C++ signature */
    def destroy(self) -> None:
        """ Remove instance from system (valid() will return False after this)"""
        pass
    # void seek(float time);    /* original C++ signature */
    def seek(self, time: float) -> None:
        pass
    # void set_time_scale(float scale);    /* original C++ signature */
    def set_time_scale(self, scale: float) -> None:
        pass
    # void set_weight(float weight);      /* original C++ signature */
    def set_weight(self, weight: float) -> None:
        """ for layering/blending"""
        pass

    # Animation chaining - play another clip when this one completes
    # instance& then(ImGuiID next_clip_id);                                            /* original C++ signature */
    @overload
    def then(self, next_clip_id: int) -> instance:
        """ Chain another clip to play after this one."""
        pass
    # instance& then(ImGuiID next_clip_id, ImGuiID next_instance_id);                  /* original C++ signature */
    @overload
    def then(self, next_clip_id: int, next_instance_id: int) -> instance:
        """ Chain with specific instance ID."""
        pass
    # instance& then_delay(float delay);                                               /* original C++ signature */
    def then_delay(self, delay: float) -> instance:
        """ Set delay before chained clip starts."""
        pass

    # Query state
    # float time() const;    /* original C++ signature */
    def time(self) -> float:
        pass
    # float duration() const;    /* original C++ signature */
    def duration(self) -> float:
        pass
    # bool is_playing() const;    /* original C++ signature */
    def is_playing(self) -> bool:
        pass
    # bool is_paused() const;    /* original C++ signature */
    def is_paused(self) -> bool:
        pass

    # #ifdef IMGUI_BUNDLE_PYTHON_API
    #
    # inline std::pair<bool, float> get_float(ImGuiID channel) const { float v = 0.f; bool ok = get_float(channel, &v); return {ok, v}; }    /* original C++ signature */
    def get_float(self, channel: int) -> Tuple[bool, float]:
        pass
    # inline std::pair<bool, ImVec2> get_vec2(ImGuiID channel) const { ImVec2 v; bool ok = get_vec2(channel, &v); return {ok, v}; }    /* original C++ signature */
    def get_vec2(self, channel: int) -> Tuple[bool, ImVec2]:
        pass
    # inline std::pair<bool, ImVec4> get_vec4(ImGuiID channel) const { ImVec4 v; bool ok = get_vec4(channel, &v); return {ok, v}; }    /* original C++ signature */
    def get_vec4(self, channel: int) -> Tuple[bool, ImVec4]:
        pass
    # inline std::pair<bool, int> get_int(ImGuiID channel) const { int v = 0; bool ok = get_int(channel, &v); return {ok, v}; }    /* original C++ signature */
    def get_int(self, channel: int) -> Tuple[bool, int]:
        pass
    # inline std::pair<bool, ImVec4> get_color(ImGuiID channel, int color_space = color_space::col_oklab) const { ImVec4 v; bool ok = get_color(channel, &v, color_space); return {ok, v}; }    /* original C++ signature */
    def get_color(
        self,
        channel: int,
        color_space: int = color_space.col_oklab
        ) -> Tuple[bool, ImVec4]:
        pass
    # #endif
    #


    # bool valid() const;    /* original C++ signature */
    def valid(self) -> bool:
        """ Check validity"""
        pass
    # operator bool() const { return valid(); }    /* original C++ signature */
    def __bool__(self) -> bool:
        pass

    # ImGuiID id() const { return m_inst_id; }    /* original C++ signature */
    def id(self) -> int:
        pass


# ----------------------------------------------------
# Clip System API
# ----------------------------------------------------

# Initialize/shutdown (optional - auto-init on first use)
# void clip_init(int initial_clip_cap = 256, int initial_inst_cap = 4096);    /* original C++ signature */
def clip_init(initial_clip_cap: int = 256, initial_inst_cap: int = 4096) -> None:
    pass
# void clip_shutdown();    /* original C++ signature */
def clip_shutdown() -> None:
    pass

# void clip_update(float dt);    /* original C++ signature */
def clip_update(dt: float) -> None:
    """ Per-frame update (call after update_begin_frame)"""
    pass

# void clip_gc(unsigned int max_age_frames = 600);    /* original C++ signature */
def clip_gc(max_age_frames: int = 600) -> None:
    """ Garbage collection for instances"""
    pass

# instance play(ImGuiID clip_id, ImGuiID instance_id);    /* original C++ signature */
def play(clip_id: int, instance_id: int) -> instance:
    """ Play a clip on an instance (creates or reuses instance)"""
    pass

# instance get_instance(ImGuiID instance_id);    /* original C++ signature */
def get_instance(instance_id: int) -> instance:
    """ Get an existing instance (returns invalid instance if not found)"""
    pass

# Query clip info
# float clip_duration(ImGuiID clip_id);                                           /* original C++ signature */
def clip_duration(clip_id: int) -> float:
    """ Get clip duration in seconds."""
    pass
# bool clip_exists(ImGuiID clip_id);                                              /* original C++ signature */
def clip_exists(clip_id: int) -> bool:
    """ Check if clip exists."""
    pass

# Stagger helpers - compute delay for indexed instances
# float stagger_delay(ImGuiID clip_id, int index);                                /* original C++ signature */
def stagger_delay(clip_id: int, index: int) -> float:
    """ Get stagger delay for element at index."""
    pass
# instance play_stagger(ImGuiID clip_id, ImGuiID instance_id, int index);     /* original C++ signature */
def play_stagger(clip_id: int, instance_id: int, index: int) -> instance:
    """ Play with stagger delay applied."""
    pass

# Layering support - blend multiple animation instances [C++ only]


# Persistence (optional) [C++ only]

# ----------------------------------------------------
# Usage notes (summary)
# ----------------------------------------------------
# TWEEN API:
# 1) Call update_begin_frame() once per frame; use ImGui::GetIO().DeltaTime as dt.
# 2) For each widget/object, pick a stable ImGuiID (e.g. ImGui::GetItemID()) and a channel_id (ImHashStr("alpha")).
# 3) Call tween_* to get the animated value, then apply it (PushStyleVar, etc).
# 4) Optionally call gc(600) every second to bound memory.
# 5) Use tween_vec2_rel / tween_vec2_resolved / rebase_vec2 to keep animations smooth on window/dock/viewport changes.
#
# CLIP API:
# 1) Author clips once at startup using clip::begin(id).key_*(...).end()
# 2) Call clip_update(dt) each frame after update_begin_frame()
# 3) Use play(clip_id, instance_id) to start playback; returns instance for queries
# 4) Call inst.get_float/vec2/vec4/int() to sample animated values
# 5) Optionally call clip_gc(600) to bound instance memory

# ----------------------------------------------------
# Demo and doc launchers (see im_anim_demo.cpp, im_anim_docs.cpp, im_anim_usecase.cpp)
# ----------------------------------------------------
# void ImAnimDemoBasicsWindow(bool create_window = true);    /* original C++ signature */
def demo_basics_window(create_window: bool = True) -> None:
    pass
####################    </generated_from:im_anim.h>    ####################

# </litgen_stub> // Autogenerated code end!
