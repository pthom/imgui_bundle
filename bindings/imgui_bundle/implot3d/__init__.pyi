"""ImPlot3D: Immediate Mode 3D Plotting for ImGui
Python bindings for https://github.com/brenocq/implot3d
"""

# ruff: noqa: B008, F821, F811
from typing import Any, Optional, List, overload
import numpy as np
import enum
from . import internal as internal

from imgui_bundle import imgui
from imgui_bundle.imgui import (
    ImVec2,
    ImVec2Like,
    ImVec4,
    ImVec4Like,
    ImU32,
    ImDrawList,
    ImTextureRef,
)

ImageFlags = int  # enum ImageFlags_

ImGui_Context = imgui.internal.Context

##################################################
#    Manually inserted code (typedefs, etc.)
##################################################
IMPLOT3D_AUTO = -1  # Deduce variable automatically
IMPLOT3D_AUTO_COL = ImVec4(0, 0, 0, -1)  # Deduce color automatically
AUTO = IMPLOT3D_AUTO
AUTO_COL = IMPLOT3D_AUTO_COL

VERSION: str

UInt = int
Context = Any
ImAxis3D = int  # enum ImAxis3D_

# // Flags
# typedef int ImPlot3DFlags;         // -> ImPlot3DFlags_         // Flags: for BeginPlot()
Flags = int  # enum Flags_ (ImPlot3DFlags)
#     typedef int ImPlot3DItemFlags;     // -> ImPlot3DItemFlags_     // Flags: Item flags
ItemFlags = int  # enum ItemFlags_
# typedef int ImPlot3DScatterFlags;  // -> ImPlot3DScatterFlags_  // Flags: Scatter plot flags
ScatterFlags = int  # enum ScatterFlags_
# typedef int ImPlot3DLineFlags;     // -> ImPlot3DLineFlags_     // Flags: Line plot flags
LineFlags = int  # enum LineFlags_
# typedef int ImPlot3DTriangleFlags; // -> ImPlot3DTriangleFlags_ // Flags: Triangle plot flags
TriangleFlags = int  # enum TriangleFlags_
# typedef int ImPlot3DQuadFlags;     // -> ImPlot3DQuadFlags_     // Flags: QuadFplot flags
QuadFlags = int  # enum QuadFlags_
# typedef int ImPlot3DSurfaceFlags;  // -> ImPlot3DSurfaceFlags_  // Flags: Surface plot flags
SurfaceFlags = int  # enum SurfaceFlags_
# typedef int ImPlot3DMeshFlags;     // -> ImPlot3DMeshFlags_     // Flags: Mesh plot flags
MeshFlags = int  # enum MeshFlags_
# typedef int ImPlot3DLegendFlags;   // -> ImPlot3DLegendFlags_   // Flags: Legend flags
LegendFlags = int  # enum LegendFlags_
# typedef int ImPlot3DAxisFlags;     // -> ImPlot3DAxisFlags_     // Flags: Axis flags

AxisFlags = int  # enum AxisFlags_

# typedef int ImPlot3DColormap; // -> ImPlot3DColormap_          // Enum: Colormaps
Colormap = int  # enum Colormap_

# // Enums
# typedef int ImPlot3DCond;     // -> ImPlot3DCond_              // Enum: Condition for flags
Cond = int  # enum Cond_
# typedef int ImPlot3DCol;      // -> ImPlot3DCol_               // Enum: Styling colors
Col = int  # enum Col_
# typedef int ImPlot3DStyleVar; // -> ImPlot3DStyleVar_          // Enum: Style variables
StyleVar = int  # enum StyleVar_
# typedef int ImPlot3DMarker;   // -> ImPlot3DMarker_            // Enum: Marker styles
Marker = int  # enum Marker_
# typedef int ImPlot3DLocation; // -> ImPlot3DLocation_          // Enum: Locations
Location = int  # enum Location_
# typedef int ImAxis3D;         // -> ImAxis3D_                  // Enum: Axis indices
# typedef int ImPlane3D;        // -> ImPlane3D_                  // Enum: Plane indices
ImPlane3D = int  # enum ImPlane3D_
# typedef int ImPlot3DColormap; // -> ImPlot3DColormap_          // Enum: Colormaps
#
ImAxis3D = int  # enum ImAxis3D_

Scale = int # enum Scale_

Marker_Auto = Marker_.auto
ItemFlags_None = ItemFlags_.none


"""
"""

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:implot3d.h>    ####################
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2026 Breno Cunha Queiroz

# ImPlot3D v0.4 WIP

# Acknowledgments:
#  ImPlot3D is heavily inspired by ImPlot
#  (https://github.com/epezent/implot) by Evan Pezent,
#  and follows a similar code style and structure to
#  maintain consistency with ImPlot's API.

# Table of Contents:
# [SECTION] Macros and Defines
# [SECTION] Forward declarations and basic types
# [SECTION] Flags & Enumerations
# [SECTION] Specs API
# [SECTION] Callbacks
# [SECTION] Context
# [SECTION] Begin/End Plot
# [SECTION] Setup
# [SECTION] Plot Items
# [SECTION] Plot Utils
# [SECTION] Miscellaneous
# [SECTION] Styles API (legacy)
# [SECTION] Demo
# [SECTION] Debugging
# [SECTION] ImPlot3DPoint
# [SECTION] ImPlot3DRay
# [SECTION] ImPlot3DPlane
# [SECTION] ImPlot3DBox
# [SECTION] ImPlot3DQuat
# [SECTION] ImPlot3DStyle
# [SECTION] Meshes
# [SECTION] Obsolete API

# #ifndef IMGUI_DISABLE
#

# [ADAPT_IMGUI_BUNDLE]
# #ifdef IMGUI_BUNDLE_PYTHON_API
#
# #endif
#
# [/ADAPT_IMGUI_BUNDLE]

# -----------------------------------------------------------------------------
# [SECTION] Macros and Defines
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# [SECTION] Forward declarations and basic types
# -----------------------------------------------------------------------------

# Forward declarations

# Enums

# Flags

# Fallback for ImGui versions before v1.92: define ImTextureRef as ImTextureID
# You can `#define IMPLOT3D_NO_IMTEXTUREREF` to avoid this fallback

# -----------------------------------------------------------------------------
# [SECTION] Flags & Enumerations
# -----------------------------------------------------------------------------

class Prop_(enum.IntFlag):
    """Plotting properties. These provide syntactic sugar for creating ImPlot3DSpec from (ImPlot3DProp,value) pairs"""

    # ImPlot3DProp_LineColor,           /* original C++ signature */
    line_color = enum.auto()  # (= 0)  # Line color; IMPLOT3D_AUTO_COL will use next Colormap color
    # ImPlot3DProp_LineWeight,          /* original C++ signature */
    line_weight = enum.auto()  # (= 1)  # Line weight in pixels
    # ImPlot3DProp_FillColor,           /* original C++ signature */
    fill_color = (
        enum.auto()
    )  # (= 2)  # Fill color (applies to shaded regions); IMPLOT3D_AUTO_COL will use next Colormap color
    # ImPlot3DProp_FillAlpha,           /* original C++ signature */
    fill_alpha = enum.auto()  # (= 3)  # Alpha multiplier (applies to FillColor and MarkerFillColor)
    # ImPlot3DProp_Marker,              /* original C++ signature */
    marker = enum.auto()  # (= 4)  # Marker type
    # ImPlot3DProp_MarkerSize,          /* original C++ signature */
    marker_size = enum.auto()  # (= 5)  # Size of markers (radius) *in pixels*
    # ImPlot3DProp_MarkerLineColor,     /* original C++ signature */
    marker_line_color = enum.auto()  # (= 6)  # Marker outline color; IMPLOT3D_AUTO_COL will use next LineColor
    # ImPlot3DProp_MarkerFillColor,     /* original C++ signature */
    marker_fill_color = enum.auto()  # (= 7)  # Marker fill color; IMPLOT3D_AUTO_COL will use LineColor
    # ImPlot3DProp_Offset,              /* original C++ signature */
    offset = enum.auto()  # (= 8)  # Data index offset
    # ImPlot3DProp_Stride,              /* original C++ signature */
    stride = (
        enum.auto()
    )  # (= 9)  # Data stride in bytes; IMPLOT3D_AUTO will result in sizeof(T) where T is the type passed to PlotX
    # ImPlot3DProp_Flags                /* original C++ signature */
    flags = (
        enum.auto()
    )  # (= 10)  # Optional item flags; can be composed from common ImPlot3DItemFlags and/or specialized ImPlot3DXFlags

class Flags_(enum.IntFlag):
    """Flags for ImPlot3D::BeginPlot()"""

    # ImPlot3DFlags_None = 0,                 /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DFlags_NoTitle = 1 << 0,         /* original C++ signature */
    no_title = enum.auto()  # (= 1 << 0)  # Hide plot title
    # ImPlot3DFlags_NoLegend = 1 << 1,        /* original C++ signature */
    no_legend = enum.auto()  # (= 1 << 1)  # Hide plot legend
    # ImPlot3DFlags_NoMouseText = 1 << 2,     /* original C++ signature */
    no_mouse_text = enum.auto()  # (= 1 << 2)  # Hide mouse position in plot coordinates
    # ImPlot3DFlags_NoClip = 1 << 3,          /* original C++ signature */
    no_clip = enum.auto()  # (= 1 << 3)  # Disable 3D box clipping
    # ImPlot3DFlags_NoMenus = 1 << 4,         /* original C++ signature */
    no_menus = enum.auto()  # (= 1 << 4)  # The user will not be able to open context menus
    # ImPlot3DFlags_Equal = 1 << 5,           /* original C++ signature */
    equal = enum.auto()  # (= 1 << 5)  # X, Y, and Z axes will be constrained to have the same units/pixel
    # ImPlot3DFlags_NoRotate = 1 << 6,        /* original C++ signature */
    no_rotate = enum.auto()  # (= 1 << 6)  # Lock rotation interaction
    # ImPlot3DFlags_NoPan = 1 << 7,           /* original C++ signature */
    no_pan = enum.auto()  # (= 1 << 7)  # Lock panning/translation interaction
    # ImPlot3DFlags_NoZoom = 1 << 8,          /* original C++ signature */
    no_zoom = enum.auto()  # (= 1 << 8)  # Lock zoom interaction
    # ImPlot3DFlags_NoInputs = 1 << 9,        /* original C++ signature */
    no_inputs = enum.auto()  # (= 1 << 9)  # Disable all user inputs
    # ImPlot3DFlags_CanvasOnly = ImPlot3DFlags_NoTitle | ImPlot3DFlags_NoLegend | ImPlot3DFlags_NoMouseText,    /* original C++ signature */
    # }
    canvas_only = enum.auto()  # (= Flags_NoTitle | Flags_NoLegend | Flags_NoMouseText)

class Cond_(enum.IntFlag):
    """Represents a condition for SetupAxisLimits etc. (same as ImGuiCond, but we only support a subset of those enums)"""

    # ImPlot3DCond_None = ImGuiCond_None,         /* original C++ signature */
    none = enum.auto()  # (= Cond_None)  # No condition (always set the variable), same as _Always
    # ImPlot3DCond_Always = ImGuiCond_Always,     /* original C++ signature */
    always = enum.auto()  # (= Cond_Always)  # No condition (always set the variable)
    # ImPlot3DCond_Once = ImGuiCond_Once,         /* original C++ signature */
    once = enum.auto()  # (= Cond_Once)  # Set the variable once per runtime session (only the first call will succeed)

class Col_(enum.IntFlag):
    # Plot colors
    # ImPlot3DCol_TitleText,      /* original C++ signature */
    title_text = enum.auto()  # (= 0)  # Title color
    # ImPlot3DCol_InlayText,      /* original C++ signature */
    inlay_text = enum.auto()  # (= 1)  # Color for texts appearing inside of plots
    # ImPlot3DCol_FrameBg,        /* original C++ signature */
    frame_bg = enum.auto()  # (= 2)  # Frame background color
    # ImPlot3DCol_PlotBg,         /* original C++ signature */
    plot_bg = enum.auto()  # (= 3)  # Plot area background color
    # ImPlot3DCol_PlotBorder,     /* original C++ signature */
    plot_border = enum.auto()  # (= 4)  # Plot area border color
    # Legend colors
    # ImPlot3DCol_LegendBg,         /* original C++ signature */
    legend_bg = enum.auto()  # (= 5)  # Legend background color
    # ImPlot3DCol_LegendBorder,     /* original C++ signature */
    legend_border = enum.auto()  # (= 6)  # Legend border color
    # ImPlot3DCol_LegendText,       /* original C++ signature */
    legend_text = enum.auto()  # (= 7)  # Legend text color
    # Axis colors
    # ImPlot3DCol_AxisText,     /* original C++ signature */
    axis_text = enum.auto()  # (= 8)  # Axis label and tick lables color
    # ImPlot3DCol_AxisGrid,     /* original C++ signature */
    axis_grid = enum.auto()  # (= 9)  # Axis grid color
    # ImPlot3DCol_AxisTick,     /* original C++ signature */
    axis_tick = enum.auto()  # (= 10)  # Axis tick color (defaults to AxisGrid)
    # ImPlot3DCol_COUNT,    /* original C++ signature */
    # }
    count = enum.auto()  # (= 11)

class StyleVar_(enum.IntFlag):
    """Plot styling variables"""

    # Item style
    # ImPlot3DStyleVar_LineWeight,     /* original C++ signature */
    line_weight = enum.auto()  # (= 0)  # float, plot item line weight in pixels
    # ImPlot3DStyleVar_Marker,         /* original C++ signature */
    marker = enum.auto()  # (= 1)  # int,   marker specification
    # ImPlot3DStyleVar_MarkerSize,     /* original C++ signature */
    marker_size = enum.auto()  # (= 2)  # float, marker size in pixels (roughly the marker's "radius")
    # ImPlot3DStyleVar_FillAlpha,      /* original C++ signature */
    fill_alpha = enum.auto()  # (= 3)  # float, alpha modifier applied to all plot item fills
    # Plot style
    # ImPlot3DStyleVar_PlotDefaultSize,     /* original C++ signature */
    plot_default_size = enum.auto()  # (= 4)  # ImVec2, default size used when ImVec2(0,0) is passed to BeginPlot
    # ImPlot3DStyleVar_PlotMinSize,         /* original C++ signature */
    plot_min_size = enum.auto()  # (= 5)  # ImVec2, minimum size plot frame can be when shrunk
    # ImPlot3DStyleVar_PlotPadding,         /* original C++ signature */
    plot_padding = (
        enum.auto()
    )  # (= 6)  # ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding)
    # ImPlot3DStyleVar_LabelPadding,        /* original C++ signature */
    label_padding = enum.auto()  # (= 7)  # ImVec2, padding between axes labels, tick labels, and plot edge
    # ImPlot3DStyleVar_ViewScaleFactor,     /* original C++ signature */
    view_scale_factor = (
        enum.auto()
    )  # (= 8)  # float, scale factor for 3D view, you can use it to make the whole plot larger or smaller
    # Legend style
    # ImPlot3DStyleVar_LegendPadding,          /* original C++ signature */
    legend_padding = enum.auto()  # (= 9)  # ImVec2, legend padding from plot edges
    # ImPlot3DStyleVar_LegendInnerPadding,     /* original C++ signature */
    legend_inner_padding = enum.auto()  # (= 10)  # ImVec2, legend inner padding from legend edges
    # ImPlot3DStyleVar_LegendSpacing,          /* original C++ signature */
    legend_spacing = enum.auto()  # (= 11)  # ImVec2, spacing between legend entries
    # ImPlot3DStyleVar_COUNT    /* original C++ signature */
    # }
    count = enum.auto()  # (= 12)

class Marker_(enum.IntFlag):
    # ImPlot3DMarker_None = -2,     /* original C++ signature */
    none = enum.auto()  # (= -2)  # No marker
    # ImPlot3DMarker_Auto = -1,     /* original C++ signature */
    auto = enum.auto()  # (= -1)  # Automatic marker selection
    # ImPlot3DMarker_Circle,        /* original C++ signature */
    circle = enum.auto()  # (= 0)  # Circle marker (default)
    # ImPlot3DMarker_Square,        /* original C++ signature */
    square = enum.auto()  # (= 1)  # Square maker
    # ImPlot3DMarker_Diamond,       /* original C++ signature */
    diamond = enum.auto()  # (= 2)  # Diamond marker
    # ImPlot3DMarker_Up,            /* original C++ signature */
    up = enum.auto()  # (= 3)  # Upward-pointing triangle marker
    # ImPlot3DMarker_Down,          /* original C++ signature */
    down = enum.auto()  # (= 4)  # Downward-pointing triangle marker
    # ImPlot3DMarker_Left,          /* original C++ signature */
    left = enum.auto()  # (= 5)  # Leftward-pointing triangle marker
    # ImPlot3DMarker_Right,         /* original C++ signature */
    right = enum.auto()  # (= 6)  # Rightward-pointing triangle marker
    # ImPlot3DMarker_Cross,         /* original C++ signature */
    cross = enum.auto()  # (= 7)  # Cross marker (not fillable)
    # ImPlot3DMarker_Plus,          /* original C++ signature */
    plus = enum.auto()  # (= 8)  # Plus marker (not fillable)
    # ImPlot3DMarker_Asterisk,      /* original C++ signature */
    asterisk = enum.auto()  # (= 9)  # Asterisk marker (not fillable)
    # ImPlot3DMarker_COUNT    /* original C++ signature */
    # }
    count = enum.auto()  # (= 10)

class ItemFlags_(enum.IntFlag):
    """Flags for items"""

    # ImPlot3DItemFlags_None = 0,              /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DItemFlags_NoLegend = 1 << 0,     /* original C++ signature */
    no_legend = enum.auto()  # (= 1 << 0)  # The item won't have a legend entry displayed
    # ImPlot3DItemFlags_NoFit = 1 << 1,        /* original C++ signature */
    no_fit = enum.auto()  # (= 1 << 1)  # The item won't be considered for plot fits

class ScatterFlags_(enum.IntFlag):
    """Flags for PlotScatter"""

    # ImPlot3DScatterFlags_None = 0,     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DScatterFlags_NoLegend = ImPlot3DItemFlags_NoLegend,    /* original C++ signature */
    no_legend = enum.auto()  # (= ItemFlags_NoLegend)
    # ImPlot3DScatterFlags_NoFit = ImPlot3DItemFlags_NoFit,    /* original C++ signature */
    # }
    no_fit = enum.auto()  # (= ItemFlags_NoFit)

class LineFlags_(enum.IntFlag):
    """Flags for PlotLine"""

    # ImPlot3DLineFlags_None = 0,     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DLineFlags_NoLegend = ImPlot3DItemFlags_NoLegend,    /* original C++ signature */
    no_legend = enum.auto()  # (= ItemFlags_NoLegend)
    # ImPlot3DLineFlags_NoFit = ImPlot3DItemFlags_NoFit,    /* original C++ signature */
    no_fit = enum.auto()  # (= ItemFlags_NoFit)
    # ImPlot3DLineFlags_Segments = 1 << 10,     /* original C++ signature */
    segments = enum.auto()  # (= 1 << 10)  # A line segment will be rendered from every two consecutive points
    # ImPlot3DLineFlags_Loop = 1 << 11,         /* original C++ signature */
    loop = enum.auto()  # (= 1 << 11)  # The last and first point will be connected to form a closed loop
    # ImPlot3DLineFlags_SkipNaN = 1 << 12,      /* original C++ signature */
    skip_nan = enum.auto()  # (= 1 << 12)  # NaNs values will be skipped instead of rendered as missing data

class TriangleFlags_(enum.IntFlag):
    """Flags for PlotTriangle"""

    # ImPlot3DTriangleFlags_None = 0,     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DTriangleFlags_NoLegend = ImPlot3DItemFlags_NoLegend,    /* original C++ signature */
    no_legend = enum.auto()  # (= ItemFlags_NoLegend)
    # ImPlot3DTriangleFlags_NoFit = ImPlot3DItemFlags_NoFit,    /* original C++ signature */
    no_fit = enum.auto()  # (= ItemFlags_NoFit)
    # ImPlot3DTriangleFlags_NoLines = 1 << 10,       /* original C++ signature */
    no_lines = enum.auto()  # (= 1 << 10)  # No lines will be rendered
    # ImPlot3DTriangleFlags_NoFill = 1 << 11,        /* original C++ signature */
    no_fill = enum.auto()  # (= 1 << 11)  # No fill will be rendered
    # ImPlot3DTriangleFlags_NoMarkers = 1 << 12,     /* original C++ signature */
    no_markers = enum.auto()  # (= 1 << 12)  # No markers will be rendered

class QuadFlags_(enum.IntFlag):
    """Flags for PlotQuad"""

    # ImPlot3DQuadFlags_None = 0,     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DQuadFlags_NoLegend = ImPlot3DItemFlags_NoLegend,    /* original C++ signature */
    no_legend = enum.auto()  # (= ItemFlags_NoLegend)
    # ImPlot3DQuadFlags_NoFit = ImPlot3DItemFlags_NoFit,    /* original C++ signature */
    no_fit = enum.auto()  # (= ItemFlags_NoFit)
    # ImPlot3DQuadFlags_NoLines = 1 << 10,       /* original C++ signature */
    no_lines = enum.auto()  # (= 1 << 10)  # No lines will be rendered
    # ImPlot3DQuadFlags_NoFill = 1 << 11,        /* original C++ signature */
    no_fill = enum.auto()  # (= 1 << 11)  # No fill will be rendered
    # ImPlot3DQuadFlags_NoMarkers = 1 << 12,     /* original C++ signature */
    no_markers = enum.auto()  # (= 1 << 12)  # No markers will be rendered

class SurfaceFlags_(enum.IntFlag):
    """Flags for PlotSurface"""

    # ImPlot3DSurfaceFlags_None = 0,     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DSurfaceFlags_NoLegend = ImPlot3DItemFlags_NoLegend,    /* original C++ signature */
    no_legend = enum.auto()  # (= ItemFlags_NoLegend)
    # ImPlot3DSurfaceFlags_NoFit = ImPlot3DItemFlags_NoFit,    /* original C++ signature */
    no_fit = enum.auto()  # (= ItemFlags_NoFit)
    # ImPlot3DSurfaceFlags_NoLines = 1 << 10,       /* original C++ signature */
    no_lines = enum.auto()  # (= 1 << 10)  # No lines will be rendered
    # ImPlot3DSurfaceFlags_NoFill = 1 << 11,        /* original C++ signature */
    no_fill = enum.auto()  # (= 1 << 11)  # No fill will be rendered
    # ImPlot3DSurfaceFlags_NoMarkers = 1 << 12,     /* original C++ signature */
    no_markers = enum.auto()  # (= 1 << 12)  # No markers will be rendered

class MeshFlags_(enum.IntFlag):
    """Flags for PlotMesh"""

    # ImPlot3DMeshFlags_None = 0,     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DMeshFlags_NoLegend = ImPlot3DItemFlags_NoLegend,    /* original C++ signature */
    no_legend = enum.auto()  # (= ItemFlags_NoLegend)
    # ImPlot3DMeshFlags_NoFit = ImPlot3DItemFlags_NoFit,    /* original C++ signature */
    no_fit = enum.auto()  # (= ItemFlags_NoFit)
    # ImPlot3DMeshFlags_NoLines = 1 << 10,       /* original C++ signature */
    no_lines = enum.auto()  # (= 1 << 10)  # No lines will be rendered
    # ImPlot3DMeshFlags_NoFill = 1 << 11,        /* original C++ signature */
    no_fill = enum.auto()  # (= 1 << 11)  # No fill will be rendered
    # ImPlot3DMeshFlags_NoMarkers = 1 << 12,     /* original C++ signature */
    no_markers = enum.auto()  # (= 1 << 12)  # No markers will be rendered

class ImageFlags_(enum.IntFlag):
    """Flags for PlotImage"""

    # ImPlot3DImageFlags_None = 0,     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DImageFlags_NoLegend = ImPlot3DItemFlags_NoLegend,    /* original C++ signature */
    no_legend = enum.auto()  # (= ItemFlags_NoLegend)
    # ImPlot3DImageFlags_NoFit = ImPlot3DItemFlags_NoFit,    /* original C++ signature */
    # }
    no_fit = enum.auto()  # (= ItemFlags_NoFit)

class DummyFlags_(enum.IntFlag):
    """Flags for PlotDummy"""

    # ImPlot3DDummyFlags_None = 0     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default

class LegendFlags_(enum.IntFlag):
    """Flags for legends"""

    # ImPlot3DLegendFlags_None = 0,                     /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DLegendFlags_NoButtons = 1 << 0,           /* original C++ signature */
    no_buttons = enum.auto()  # (= 1 << 0)  # Legend icons will not function as hide/show buttons
    # ImPlot3DLegendFlags_NoHighlightItem = 1 << 1,     /* original C++ signature */
    no_highlight_item = (
        enum.auto()
    )  # (= 1 << 1)  # Plot items will not be highlighted when their legend entry is hovered
    # ImPlot3DLegendFlags_Horizontal = 1 << 2,          /* original C++ signature */
    horizontal = enum.auto()  # (= 1 << 2)  # Legend entries will be displayed horizontally

class Location_(enum.IntFlag):
    """Used to position legend on a plot"""

    # ImPlot3DLocation_Center = 0,                                                     /* original C++ signature */
    center = enum.auto()  # (= 0)  # Center-center
    # ImPlot3DLocation_North = 1 << 0,                                                 /* original C++ signature */
    north = enum.auto()  # (= 1 << 0)  # Top-center
    # ImPlot3DLocation_South = 1 << 1,                                                 /* original C++ signature */
    south = enum.auto()  # (= 1 << 1)  # Bottom-center
    # ImPlot3DLocation_West = 1 << 2,                                                  /* original C++ signature */
    west = enum.auto()  # (= 1 << 2)  # Center-left
    # ImPlot3DLocation_East = 1 << 3,                                                  /* original C++ signature */
    east = enum.auto()  # (= 1 << 3)  # Center-right
    # ImPlot3DLocation_NorthWest = ImPlot3DLocation_North | ImPlot3DLocation_West,     /* original C++ signature */
    north_west = enum.auto()  # (= Location_North | Location_West)  # Top-left
    # ImPlot3DLocation_NorthEast = ImPlot3DLocation_North | ImPlot3DLocation_East,     /* original C++ signature */
    north_east = enum.auto()  # (= Location_North | Location_East)  # Top-right
    # ImPlot3DLocation_SouthWest = ImPlot3DLocation_South | ImPlot3DLocation_West,     /* original C++ signature */
    south_west = enum.auto()  # (= Location_South | Location_West)  # Bottom-left
    # ImPlot3DLocation_SouthEast = ImPlot3DLocation_South | ImPlot3DLocation_East      /* original C++ signature */
    south_east = enum.auto()  # (= Location_South | Location_East)  # Bottom-right

class AxisFlags_(enum.IntFlag):
    """Flags for axis"""

    # ImPlot3DAxisFlags_None = 0,                  /* original C++ signature */
    none = enum.auto()  # (= 0)  # Default
    # ImPlot3DAxisFlags_NoLabel = 1 << 0,          /* original C++ signature */
    no_label = enum.auto()  # (= 1 << 0)  # No axis label will be displayed
    # ImPlot3DAxisFlags_NoGridLines = 1 << 1,      /* original C++ signature */
    no_grid_lines = enum.auto()  # (= 1 << 1)  # No grid lines will be displayed
    # ImPlot3DAxisFlags_NoTickMarks = 1 << 2,      /* original C++ signature */
    no_tick_marks = enum.auto()  # (= 1 << 2)  # No tick marks will be displayed
    # ImPlot3DAxisFlags_NoTickLabels = 1 << 3,     /* original C++ signature */
    no_tick_labels = enum.auto()  # (= 1 << 3)  # No tick labels will be displayed
    # ImPlot3DAxisFlags_LockMin = 1 << 4,          /* original C++ signature */
    lock_min = enum.auto()  # (= 1 << 4)  # The axis minimum value will be locked when panning/zooming
    # ImPlot3DAxisFlags_LockMax = 1 << 5,          /* original C++ signature */
    lock_max = enum.auto()  # (= 1 << 5)  # The axis maximum value will be locked when panning/zooming
    # ImPlot3DAxisFlags_AutoFit = 1 << 6,          /* original C++ signature */
    auto_fit = enum.auto()  # (= 1 << 6)  # Axis will be auto-fitting to data extents
    # ImPlot3DAxisFlags_Invert = 1 << 7,           /* original C++ signature */
    invert = enum.auto()  # (= 1 << 7)  # The axis will be inverted
    # ImPlot3DAxisFlags_PanStretch = 1 << 8,       /* original C++ signature */
    pan_stretch = (
        enum.auto()
    )  # (= 1 << 8)  # Panning in a locked or constrained state will cause the axis to stretch if possible
    # ImPlot3DAxisFlags_Lock = ImPlot3DAxisFlags_LockMin | ImPlot3DAxisFlags_LockMax,    /* original C++ signature */
    lock = enum.auto()  # (= AxisFlags_LockMin | AxisFlags_LockMax)
    # ImPlot3DAxisFlags_NoDecorations = ImPlot3DAxisFlags_NoLabel | ImPlot3DAxisFlags_NoGridLines | ImPlot3DAxisFlags_NoTickLabels,    /* original C++ signature */
    # }
    no_decorations = enum.auto()  # (= AxisFlags_NoLabel | AxisFlags_NoGridLines | AxisFlags_NoTickLabels)

class ImAxis3D_(enum.IntFlag):
    """Axis indices"""

    # ImAxis3D_X = 0,     /* original C++ signature */
    x = enum.auto()  # (= 0)  # X-axis
    # ImAxis3D_Y,         /* original C++ signature */
    y = enum.auto()  # (= 1)  # Y-axis
    # ImAxis3D_Z,         /* original C++ signature */
    z = enum.auto()  # (= 2)  # Z-axis
    # ImAxis3D_COUNT,    /* original C++ signature */
    # }
    count = enum.auto()  # (= 3)

class ImPlane3D_(enum.IntFlag):
    """Plane indices"""

    # ImPlane3D_YZ = 0,     /* original C++ signature */
    yz = enum.auto()  # (= 0)  # YZ plane (perpendicular to X-axis)
    # ImPlane3D_XZ,         /* original C++ signature */
    xz = enum.auto()  # (= 1)  # XZ plane (perpendicular to Y-axis)
    # ImPlane3D_XY,         /* original C++ signature */
    xy = enum.auto()  # (= 2)  # XY plane (perpendicular to Z-axis)
    # ImPlane3D_COUNT,    /* original C++ signature */
    # }
    count = enum.auto()  # (= 3)

class Scale_(enum.IntFlag):
    """Axis scale"""

    # ImPlot3DScale_Linear = 0,     /* original C++ signature */
    linear = enum.auto()  # (= 0)  # Default linear scale
    # ImPlot3DScale_Log10,          /* original C++ signature */
    log10 = enum.auto()  # (= 1)  # Base 10 log scale
    # ImPlot3DScale_SymLog,         /* original C++ signature */
    sym_log = enum.auto()  # (= 2)  # Symmetric base 10 log scale

class Colormap_(enum.IntFlag):
    """Colormaps"""

    # ImPlot3DColormap_Deep = 0,          /* original C++ signature */
    deep = enum.auto()  # (= 0)  # Same as seaborn "deep"
    # ImPlot3DColormap_Dark = 1,          /* original C++ signature */
    dark = enum.auto()  # (= 1)  # Same as matplotlib "Set1"
    # ImPlot3DColormap_Pastel = 2,        /* original C++ signature */
    pastel = enum.auto()  # (= 2)  # Same as matplotlib "Pastel1"
    # ImPlot3DColormap_Paired = 3,        /* original C++ signature */
    paired = enum.auto()  # (= 3)  # Same as matplotlib "Paired"
    # ImPlot3DColormap_Viridis = 4,       /* original C++ signature */
    viridis = enum.auto()  # (= 4)  # Same as matplotlib "viridis"
    # ImPlot3DColormap_Plasma = 5,        /* original C++ signature */
    plasma = enum.auto()  # (= 5)  # Same as matplotlib "plasma"
    # ImPlot3DColormap_Hot = 6,           /* original C++ signature */
    hot = enum.auto()  # (= 6)  # Same as matplotlib/MATLAB "hot"
    # ImPlot3DColormap_Cool = 7,          /* original C++ signature */
    cool = enum.auto()  # (= 7)  # Same as matplotlib/MATLAB "cool"
    # ImPlot3DColormap_Pink = 8,          /* original C++ signature */
    pink = enum.auto()  # (= 8)  # Same as matplotlib/MATLAB "pink"
    # ImPlot3DColormap_Jet = 9,           /* original C++ signature */
    jet = enum.auto()  # (= 9)  # Same as matplotlib/MATLAB "jet"
    # ImPlot3DColormap_Twilight = 10,     /* original C++ signature */
    twilight = enum.auto()  # (= 10)  # Same as matplotlib "twilight"
    # ImPlot3DColormap_RdBu = 11,         /* original C++ signature */
    rd_bu = enum.auto()  # (= 11)  # Same as matplotlib "RdBu"
    # ImPlot3DColormap_BrBG = 12,         /* original C++ signature */
    br_bg = enum.auto()  # (= 12)  # Same as matplotlib "BrGB"
    # ImPlot3DColormap_PiYG = 13,         /* original C++ signature */
    pi_yg = enum.auto()  # (= 13)  # Same as matplotlib "PiYG"
    # ImPlot3DColormap_Spectral = 14,     /* original C++ signature */
    spectral = enum.auto()  # (= 14)  # Same as matplotlib "Spectral"
    # ImPlot3DColormap_Greys = 15,        /* original C++ signature */
    greys = enum.auto()  # (= 15)  # White/black

# -----------------------------------------------------------------------------
# [SECTION] Specs API
# -----------------------------------------------------------------------------

class Spec:
    """Plot item styling specification. Provide these to PlotX functions to override styling, specify
    offsetting or stride, or set optional flags. This struct can be used in the following ways:

    1. By declaring and defining a struct instance:

       ImPlot3DSpec spec;
       spec.LineColor = ImVec4(1,0,0,1);
       spec.LineWeight = 2.0;
       spec.Marker = ImPlot3DMarker_Circle;
       spec.Flags = ImPlot3DItemFlags_NoLegend | ImPlot3DLineFlags_Segments;
       ImPlot3D::PlotLine("MyLine", xs, ys, zs, 100, spec);

    2. Inline using ImPlot3DProp,value pairs (order does NOT matter):

       ImPlot3D::PlotLine("MyLine", xs, ys, zs, 100, {
         ImPlot3DProp_LineColor, ImVec4(1,0,0,1),
         ImPlot3DProp_LineWeight, 2.0,
         ImPlot3DProp_Marker, ImPlot3DMarker_Circle,
         ImPlot3DProp_Flags, ImPlot3DItemFlags_NoLegend | ImPlot3DLineFlags_Segments
       });
    """

    # ImVec4 LineColor = IMPLOT3D_AUTO_COL;    /* original C++ signature */
    line_color: ImVec4 = IMPLOT3D_AUTO_COL  # Line color; IMPLOT3D_AUTO_COL will use next Colormap color
    # float LineWeight = 1.0f;    /* original C++ signature */
    line_weight: float = 1.0  # Line weight in pixels
    # ImVec4 FillColor = IMPLOT3D_AUTO_COL;    /* original C++ signature */
    fill_color: ImVec4 = (
        IMPLOT3D_AUTO_COL  # Fill color (applies to shaded regions); IMPLOT3D_AUTO_COL will use next Colormap color
    )
    # float FillAlpha = IMPLOT3D_AUTO;    /* original C++ signature */
    fill_alpha: float = IMPLOT3D_AUTO  # Alpha multiplier (applies to FillColor and MarkerFillColor)
    # ImPlot3DMarker Marker = ImPlot3DMarker_Auto;    /* original C++ signature */
    marker: Marker = Marker_Auto  # Marker type
    # float MarkerSize = IMPLOT3D_AUTO;    /* original C++ signature */
    marker_size: float = IMPLOT3D_AUTO  # Size of markers (radius) *in pixels*
    # ImVec4 MarkerLineColor = IMPLOT3D_AUTO_COL;    /* original C++ signature */
    marker_line_color: ImVec4 = IMPLOT3D_AUTO_COL  # Marker outline color; IMPLOT3D_AUTO_COL will use LineColor
    # ImVec4 MarkerFillColor = IMPLOT3D_AUTO_COL;    /* original C++ signature */
    marker_fill_color: ImVec4 = IMPLOT3D_AUTO_COL  # Marker fill color; IMPLOT3D_AUTO_COL will use LineColor
    # int Offset = 0;    /* original C++ signature */
    offset: int = 0  # Data index offset
    # int Stride = IMPLOT3D_AUTO;    /* original C++ signature */
    stride: int = (
        IMPLOT3D_AUTO  # Data stride in bytes; IMPLOT3D_AUTO will result in sizeof(T) where T is the type passed to PlotX
    )
    # ImPlot3DItemFlags Flags =    /* original C++ signature */
    #         ImPlot3DItemFlags_None;
    flags: ItemFlags = (
        ItemFlags_None  # Optional item flags; can be composed from common ImPlot3DItemFlags and/or specialized ImPlot3DXFlags
    )

    # ImPlot3DSpec(ImVec4 LineColor = IMPLOT3D_AUTO_COL, float LineWeight = 1.0f, ImVec4 FillColor = IMPLOT3D_AUTO_COL, float FillAlpha = IMPLOT3D_AUTO, ImPlot3DMarker Marker = ImPlot3DMarker_Auto, float MarkerSize = IMPLOT3D_AUTO, ImVec4 MarkerLineColor = IMPLOT3D_AUTO_COL, ImVec4 MarkerFillColor = IMPLOT3D_AUTO_COL, int Offset = 0, int Stride = IMPLOT3D_AUTO, ImPlot3DItemFlags Flags = ImPlot3DItemFlags_None);    /* original C++ signature */
    def __init__(
        self,
        line_color: Optional[ImVec4Like] = None,
        line_weight: float = 1.0,
        fill_color: Optional[ImVec4Like] = None,
        fill_alpha: float = IMPLOT3D_AUTO,
        marker: Optional[Marker] = None,
        marker_size: float = IMPLOT3D_AUTO,
        marker_line_color: Optional[ImVec4Like] = None,
        marker_fill_color: Optional[ImVec4Like] = None,
        offset: int = 0,
        stride: int = IMPLOT3D_AUTO,
        flags: ItemFlags = ItemFlags_None,
    ) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * LineColor: IMPLOT3D_AUTO_COL
                * FillColor: IMPLOT3D_AUTO_COL
                * Marker: Marker_Auto
                * MarkerLineColor: IMPLOT3D_AUTO_COL
                * MarkerFillColor: IMPLOT3D_AUTO_COL
        """
        pass

# -----------------------------------------------------------------------------
# [SECTION] Callbacks
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# [SECTION] Context
# -----------------------------------------------------------------------------

# IMPLOT3D_API ImPlot3DContext* CreateContext();    /* original C++ signature */
def create_context() -> Context:
    """Creates a new ImPlot3D context. Call this after ImGui::CreateContext"""
    pass

# IMPLOT3D_API void DestroyContext(ImPlot3DContext* ctx = nullptr);    /* original C++ signature */
def destroy_context(ctx: Optional[Context] = None) -> None:
    """Destroys an ImPlot3D context. Call this before ImGui::DestroyContext. None = destroy current context"""
    pass

# IMPLOT3D_API ImPlot3DContext* GetCurrentContext();    /* original C++ signature */
def get_current_context() -> Context:
    """Returns the current ImPlot3D context. None if no context has been set"""
    pass

# IMPLOT3D_API void SetCurrentContext(ImPlot3DContext* ctx);    /* original C++ signature */
def set_current_context(ctx: Context) -> None:
    """Sets the current ImPlot3D context"""
    pass

# -----------------------------------------------------------------------------
# [SECTION] Begin/End Plot
# -----------------------------------------------------------------------------

# Starts a 3D plotting context. If this function returns True, EndPlot() MUST
# be called! You are encouraged to use the following convention:
#
# if (ImPlot3D::BeginPlot(...)) {
#     ImPlot3D::PlotLine(...);
#     ...
#     ImPlot3D::EndPlot();
# }
#
# Important notes:
# - #title_id must be unique to the current ImGui ID scope. If you need to avoid ID
#   collisions or don't want to display a title in the plot, use double hashes
#   (e.g. "MyPlot##HiddenIdText" or "##NoTitle").
# - #size is the **frame** size of the plot widget, not the plot area.
# IMPLOT3D_API bool BeginPlot(const char* title_id, const ImVec2& size = ImVec2(-1, 0), ImPlot3DFlags flags = 0);    /* original C++ signature */
def begin_plot(title_id: str, size: Optional[ImVec2Like] = None, flags: Flags = 0) -> bool:
    """Python bindings defaults:
    If size is None, then its default value will be: ImVec2(-1, 0)
    """
    pass

# IMPLOT3D_API void EndPlot();     /* original C++ signature */
def end_plot() -> None:
    """Only call if BeginPlot() returns True!"""
    pass

# -----------------------------------------------------------------------------
# [SECTION] Setup
# -----------------------------------------------------------------------------

# The following API allows you to setup and customize various aspects of the
# current plot. The functions should be called immediately after BeginPlot()
# and before any other API calls. Typical usage is as follows:

# if (ImPlot3D::BeginPlot(...)) {                     1) Begin a new plot
#     ImPlot3D::SetupAxis(ImAxis3D_X, "My X-Axis");    2) Make Setup calls
#     ImPlot3D::SetupAxis(ImAxis3D_Y, "My Y-Axis");
#     ImPlot3D::SetupLegend(ImPlotLocation_North);
#     ...
#     ImPlot3D::SetupFinish();                        3) [Optional] Explicitly finish setup
#     ImPlot3D::PlotLine(...);                        4) Plot items
#     ...
#     ImPlot3D::EndPlot();                            5) End the plot
# }
#
# Important notes:
#
# - Always call Setup code at the top of your BeginPlot conditional statement.
# - Setup is locked once you start plotting or explicitly call SetupFinish.
#   Do NOT call Setup code after you begin plotting or after you make
#   any non-Setup API calls (e.g. utils like PlotToPixels also lock Setup).
# - Calling SetupFinish is OPTIONAL, but probably good practice. If you do not
#   call it yourself, then the first subsequent plotting or utility function will
#   call it for you.

# IMPLOT3D_API void SetupAxis(ImAxis3D axis, const char* label = nullptr, ImPlot3DAxisFlags flags = 0);    /* original C++ signature */
def setup_axis(axis: ImAxis3D, label: Optional[str] = None, flags: AxisFlags = 0) -> None:
    """Enables an axis or sets the label and/or flags for an existing axis. Leave #label = None for no label"""
    pass

# IMPLOT3D_API void SetupAxisLimits(ImAxis3D axis, double v_min, double v_max, ImPlot3DCond cond = ImPlot3DCond_Once);    /* original C++ signature */
def setup_axis_limits(axis: ImAxis3D, v_min: float, v_max: float, cond: Optional[Cond] = None) -> None:
    """Sets an axis range limits. If ImPlot3DCond_Always is used, the axis limits will be locked.
     Note: To invert an axis, use ImPlot3DAxisFlags_Invert with SetupAxis instead of swapping min/max


    Python bindings defaults:
        If cond is None, then its default value will be: Cond_Once
    """
    pass

# IMPLOT3D_API void SetupAxisScale(ImAxis3D axis, ImPlot3DScale scale);    /* original C++ signature */
def setup_axis_scale(axis: ImAxis3D, scale: Scale) -> None:
    """Sets an axis' scale using built-in options"""
    pass

# IMPLOT3D_API void SetupAxisLimitsConstraints(ImAxis3D axis, double v_min, double v_max);    /* original C++ signature */
def setup_axis_limits_constraints(axis: ImAxis3D, v_min: float, v_max: float) -> None:
    """Sets an axis' limits constraints. The axis will be constrained to never go below #v_min or above #v_max"""
    pass

# IMPLOT3D_API void SetupAxisZoomConstraints(ImAxis3D axis, double zoom_min, double zoom_max);    /* original C++ signature */
def setup_axis_zoom_constraints(axis: ImAxis3D, zoom_min: float, zoom_max: float) -> None:
    """Sets an axis' zoom constraints. The zoom (axis range size: range.max - range.min) will be constrained between #zoom_min and #zoom_max"""
    pass

# IMPLOT3D_API void SetupAxes(const char* x_label, const char* y_label, const char* z_label, ImPlot3DAxisFlags x_flags = 0,    /* original C++ signature */
#                             ImPlot3DAxisFlags y_flags = 0, ImPlot3DAxisFlags z_flags = 0);
def setup_axes(
    x_label: str, y_label: str, z_label: str, x_flags: AxisFlags = 0, y_flags: AxisFlags = 0, z_flags: AxisFlags = 0
) -> None:
    """Sets the label and/or flags for primary X/Y/Z axes (shorthand for three calls to SetupAxis)"""
    pass

# IMPLOT3D_API void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, double z_min, double z_max,    /* original C++ signature */
#                                   ImPlot3DCond cond = ImPlot3DCond_Once);
def setup_axes_limits(
    x_min: float, x_max: float, y_min: float, y_max: float, z_min: float, z_max: float, cond: Optional[Cond] = None
) -> None:
    """Sets the X/Y/Z axes range limits. If ImPlot3DCond_Always is used, the axes limits will be locked (shorthand for three calls to SetupAxisLimits)


    Python bindings defaults:
        If cond is None, then its default value will be: Cond_Once
    """
    pass

# IMPLOT3D_API void SetupBoxRotation(double elevation, double azimuth, bool animate = false, ImPlot3DCond cond = ImPlot3DCond_Once);    /* original C++ signature */
@overload
def setup_box_rotation(elevation: float, azimuth: float, animate: bool = False, cond: Optional[Cond] = None) -> None:
    """Sets the plot box rotation given the elevation and azimuth angles in degrees. If ImPlot3DCond_Always is used, the rotation will be locked


    Python bindings defaults:
        If cond is None, then its default value will be: Cond_Once
    """
    pass

# IMPLOT3D_API void SetupBoxRotation(ImPlot3DQuat rotation, bool animate = false, ImPlot3DCond cond = ImPlot3DCond_Once);    /* original C++ signature */
@overload
def setup_box_rotation(rotation: Quat, animate: bool = False, cond: Optional[Cond] = None) -> None:
    """Sets the plot box rotation given a quaternion. If ImPlot3DCond_Always is used, the rotation will be locked


    Python bindings defaults:
        If cond is None, then its default value will be: Cond_Once
    """
    pass

# IMPLOT3D_API void SetupBoxInitialRotation(double elevation, double azimuth);    /* original C++ signature */
@overload
def setup_box_initial_rotation(elevation: float, azimuth: float) -> None:
    """Sets the plot box initial rotation given the elevation and azimuth angles in degrees. The initial rotation is the rotation the plot goes back to
    when a left mouse button double click happens
    """
    pass

# IMPLOT3D_API void SetupBoxInitialRotation(ImPlot3DQuat rotation);    /* original C++ signature */
@overload
def setup_box_initial_rotation(rotation: Quat) -> None:
    """Sets the plot box initial rotation given a quaternion. The initial rotation is the rotation the plot goes back to when a left mouse button double
    click happens
    """
    pass

# IMPLOT3D_API void SetupBoxScale(double x, double y, double z);    /* original C++ signature */
def setup_box_scale(x: float, y: float, z: float) -> None:
    """Sets the plot box X/Y/Z scale. A scale of 1.0 is the default. Values greater than 1.0 enlarge the plot, while values between 0.0 and 1.0 shrink it"""
    pass

# IMPLOT3D_API void SetupLegend(ImPlot3DLocation location, ImPlot3DLegendFlags flags = 0);    /* original C++ signature */
def setup_legend(location: Location, flags: LegendFlags = 0) -> None:
    """Sets up the plot legend location and flags"""
    pass

# -----------------------------------------------------------------------------
# [SECTION] Plot Items
# -----------------------------------------------------------------------------

# The plotting API is provided below. Call these functions between
# BeginPlot/EndPlot and after any Setup API calls.
#
# The templated functions are explicitly instantiated in implot3_items.cpp.
# They are not intended to be used generically with custom types. You will get
# a linker error if you try! All functions support the following scalar types:
#
# float, double, ImS8, ImU8, ImS16, ImU16, ImS32, ImU32, ImS64, ImU64
#
# If you need to plot custom or non-homogenous data you have a few options:
#
# 1. If your data is a simple struct/class (e.g. Vector3), you can use striding.
#    This is the most performant option if applicable.
#
#    struct Vector3 { float X, Y, Z; };
#    ...
#    Vector3 data[42];
#    ImPlot3D::PlotLine("line", &data[0].X, &data[0].Y, &data[0].Z, 42, {ImPlot3DProp_Stride, sizeof(Vector2)});
#
# 2. If your data is in separate arrays or requires computation, you can copy/transform
#    it into temporary float or double arrays before plotting.
#
# NB: All types are converted to double before plotting. You may lose information
# if you try plotting extremely large 64-bit integral types. Proceed with caution!

# IMPLOT3D_TMP void PlotScatter(const char* label_id, const T* xs, const T* ys, const T* zs, int count, const ImPlot3DSpec& spec = ImPlot3DSpec());    /* original C++ signature */
def plot_scatter(label_id: str, xs: np.ndarray, ys: np.ndarray, zs: np.ndarray, spec: Optional[Spec] = None) -> None:
    """Plots a scatter plot in 3D. Points are rendered as markers at the specified coordinates


    Python bindings defaults:
        If spec is None, then its default value will be: Spec()
    """
    pass

# IMPLOT3D_TMP void PlotLine(const char* label_id, const T* xs, const T* ys, const T* zs, int count, const ImPlot3DSpec& spec = ImPlot3DSpec());    /* original C++ signature */
def plot_line(label_id: str, xs: np.ndarray, ys: np.ndarray, zs: np.ndarray, spec: Optional[Spec] = None) -> None:
    """Plots a line in 3D. Consecutive points are connected with line segments


    Python bindings defaults:
        If spec is None, then its default value will be: Spec()
    """
    pass

# IMPLOT3D_TMP void PlotTriangle(const char* label_id, const T* xs, const T* ys, const T* zs, int count, const ImPlot3DSpec& spec = ImPlot3DSpec());    /* original C++ signature */
def plot_triangle(label_id: str, xs: np.ndarray, ys: np.ndarray, zs: np.ndarray, spec: Optional[Spec] = None) -> None:
    """Plots triangles in 3D. Every 3 consecutive points define a triangle


    Python bindings defaults:
        If spec is None, then its default value will be: Spec()
    """
    pass

# IMPLOT3D_TMP void PlotQuad(const char* label_id, const T* xs, const T* ys, const T* zs, int count, const ImPlot3DSpec& spec = ImPlot3DSpec());    /* original C++ signature */
def plot_quad(label_id: str, xs: np.ndarray, ys: np.ndarray, zs: np.ndarray, spec: Optional[Spec] = None) -> None:
    """Plots quads in 3D. Every 4 consecutive points define a quadrilateral


    Python bindings defaults:
        If spec is None, then its default value will be: Spec()
    """
    pass

# [ADAPT_IMGUI_BUNDLE]
# #ifdef IMGUI_BUNDLE_PYTHON_API
#
# A version of PlotSurface whose API is easier to port to Python
#    (params xs_count, ys_count and zs_count are removed in the Python API, but are used in the bindings code generation)

# IMPLOT3D_TMP void PlotSurface(    /* original C++ signature */
#     const char* label_id,
#     const T* xs, int xs_count,
#     const T* ys, int ys_count,
#     const T* zs, int zs_count,
#     int x_count, int y_count,
#     double scale_min = 0.0, double scale_max = 0.0,
#     const ImPlot3DSpec& spec = ImPlot3DSpec()
#     );
def plot_surface(
    label_id: str,
    xs: np.ndarray,
    ys: np.ndarray,
    zs: np.ndarray,
    x_count: int,
    y_count: int,
    scale_min: float = 0.0,
    scale_max: float = 0.0,
    spec: Optional[Spec] = None,
) -> None:
    """Plot the surface defined by a grid of vertices. The grid is defined by the x and y arrays,
     and the z array contains the height of each vertex.
     A total of x_count * y_count vertices are expected for each array.
     Leave #scale_min and #scale_max both at 0 for automatic color scaling, or set them to a predefined range.


    Python bindings defaults:
        If spec is None, then its default value will be: Spec()
    """
    pass

# #endif
#
# [/ADAPT_IMGUI_BUNDLE]

# [ADAPT_IMGUI_BUNDLE]
# #ifdef IMGUI_BUNDLE_PYTHON_API
#
class Mesh:
    # std::vector<ImPlot3DPoint> Points;    /* original C++ signature */
    points: List[Point]
    # std::vector<UInt> Idx;    /* original C++ signature */
    idx: List[UInt]  # Triangles are defined by the index buffer (every 3 indices form a triangle)
    # Mesh(std::vector<ImPlot3DPoint> Points = std::vector<ImPlot3DPoint>(), std::vector<UInt> Idx = std::vector<UInt>());    /* original C++ signature */
    def __init__(self, points: Optional[List[Point]] = None, idx: Optional[List[UInt]] = None) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * Points: List[Point]()
                * Idx: List[UInt]()
        """
        pass

# IMPLOT3D_API void PlotMesh(const char* label_id, const Mesh& mesh, const ImPlot3DSpec& spec = ImPlot3DSpec());    /* original C++ signature */
def plot_mesh(label_id: str, mesh: Mesh, spec: Optional[Spec] = None) -> None:
    """Python bindings defaults:
    If spec is None, then its default value will be: Spec()
    """
    pass

# #endif
#
# [/ADAPT_IMGUI_BUNDLE]

# IMPLOT3D_API void PlotImage(const char* label_id, ImTextureRef tex_ref, const ImPlot3DPoint& center, const ImPlot3DPoint& axis_u,    /* original C++ signature */
#                             const ImPlot3DPoint& axis_v, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1),
#                             const ImVec4& tint_col = ImVec4(1, 1, 1, 1), const ImPlot3DSpec& spec = ImPlot3DSpec());
@overload
def plot_image(
    label_id: str,
    tex_ref: ImTextureRef,
    center: Point,
    axis_u: Point,
    axis_v: Point,
    uv0: Optional[ImVec2Like] = None,
    uv1: Optional[ImVec2Like] = None,
    tint_col: Optional[ImVec4Like] = None,
    spec: Optional[Spec] = None,
) -> None:
    """Plots a rectangular image in 3D defined by its center and two direction vectors (axes).
     #center is the center of the rectangle in plot coordinates.
     #axis_u and #axis_v define the local axes and half-extents of the rectangle in 3D space.
     The rectangle is formed by moving from the center along axis_u and axis_v.
     #uv0 and #uv1 define the texture mapping.
     #tint_col can be used to tint the image.


    Python bindings defaults:
        If any of the params below is None, then its default value below will be used:
            * uv0: ImVec2(0, 0)
            * uv1: ImVec2(1, 1)
            * tint_col: ImVec4(1, 1, 1, 1)
            * spec: Spec()
    """
    pass

# IMPLOT3D_API void PlotImage(const char* label_id, ImTextureRef tex_ref, const ImPlot3DPoint& p0, const ImPlot3DPoint& p1, const ImPlot3DPoint& p2,    /* original C++ signature */
#                             const ImPlot3DPoint& p3, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 0),
#                             const ImVec2& uv2 = ImVec2(1, 1), const ImVec2& uv3 = ImVec2(0, 1), const ImVec4& tint_col = ImVec4(1, 1, 1, 1),
#                             const ImPlot3DSpec& spec = ImPlot3DSpec());
@overload
def plot_image(
    label_id: str,
    tex_ref: ImTextureRef,
    p0: Point,
    p1: Point,
    p2: Point,
    p3: Point,
    uv0: Optional[ImVec2Like] = None,
    uv1: Optional[ImVec2Like] = None,
    uv2: Optional[ImVec2Like] = None,
    uv3: Optional[ImVec2Like] = None,
    tint_col: Optional[ImVec4Like] = None,
    spec: Optional[Spec] = None,
) -> None:
    """Plots an image using four arbitrary 3D points that define a quad in space.
     Each corner (p0 to p3) corresponds to a corner in the image, and #uv0 to #uv3 are the texture coordinates for each.
     This overload allows full control over orientation, shape, and distortion.
     Note: The quad is internally split into two triangles, so non-rectangular quads may produce rendering artifacts
     since distortion is interpolated per triangle rather than over the full quad.


    Python bindings defaults:
        If any of the params below is None, then its default value below will be used:
            * uv0: ImVec2(0, 0)
            * uv1: ImVec2(1, 0)
            * uv2: ImVec2(1, 1)
            * uv3: ImVec2(0, 1)
            * tint_col: ImVec4(1, 1, 1, 1)
            * spec: Spec()
    """
    pass

# IMPLOT3D_API void PlotText(const char* text, double x, double y, double z, double angle = 0.0, const ImVec2& pix_offset = ImVec2(0, 0));    /* original C++ signature */
def plot_text(
    text: str, x: float, y: float, z: float, angle: float = 0.0, pix_offset: Optional[ImVec2Like] = None
) -> None:
    """Plots a centered text label at point x,y,z with optional rotation angle (in radians) and pixel offset


    Python bindings defaults:
        If pix_offset is None, then its default value will be: ImVec2(0, 0)
    """
    pass

# IMPLOT3D_API void PlotDummy(const char* label_id, const ImPlot3DSpec& spec = ImPlot3DSpec());    /* original C++ signature */
def plot_dummy(label_id: str, spec: Optional[Spec] = None) -> None:
    """Plots a dummy item (can be used to modify legend entry appearance when called after plotting an item, or add a dummy legend entry)


    Python bindings defaults:
        If spec is None, then its default value will be: Spec()
    """
    pass

# -----------------------------------------------------------------------------
# [SECTION] Plot Utils
# -----------------------------------------------------------------------------

# Convert a position in the current plot's coordinate system to pixels
# IMPLOT3D_API ImVec2 PlotToPixels(const ImPlot3DPoint& point);    /* original C++ signature */
@overload
def plot_to_pixels(point: Point) -> ImVec2:
    pass

# IMPLOT3D_API ImVec2 PlotToPixels(double x, double y, double z);    /* original C++ signature */
@overload
def plot_to_pixels(x: float, y: float, z: float) -> ImVec2:
    pass

# Convert a pixel coordinate to a ray in the current plot's coordinate system. Useful for 3D picking and intersection tests
# IMPLOT3D_API ImPlot3DRay PixelsToPlotRay(const ImVec2& pix);    /* original C++ signature */
@overload
def pixels_to_plot_ray(pix: ImVec2Like) -> Ray:
    pass

# IMPLOT3D_API ImPlot3DRay PixelsToPlotRay(double x, double y);    /* original C++ signature */
@overload
def pixels_to_plot_ray(x: float, y: float) -> Ray:
    pass

# Convert a pixel coordinate to a point on one of the plot box's axis-aligned planes (XY, XZ, or YZ).
# By default, the result is masked to the axis ranges. Set #mask=False to project to the infinite plane.
# Returns ImPlot3DPoint(NAN, NAN, NAN) if the ray does not intersect the plane
# IMPLOT3D_API ImPlot3DPoint PixelsToPlotPlane(const ImVec2& pix, ImPlane3D plane, bool mask = true);    /* original C++ signature */
@overload
def pixels_to_plot_plane(pix: ImVec2Like, plane: ImPlane3D, mask: bool = True) -> Point:
    pass

# IMPLOT3D_API ImPlot3DPoint PixelsToPlotPlane(double x, double y, ImPlane3D plane, bool mask = true);    /* original C++ signature */
@overload
def pixels_to_plot_plane(x: float, y: float, plane: ImPlane3D, mask: bool = True) -> Point:
    pass

# IMPLOT3D_API ImVec2 GetPlotRectPos();    /* original C++ signature */
def get_plot_rect_pos() -> ImVec2:
    """Get the current plot rect position (top-left) in absolute screen coordinates"""
    pass

# IMPLOT3D_API ImVec2 GetPlotRectSize();    /* original C++ signature */
def get_plot_rect_size() -> ImVec2:
    """Get the current plot rect size in pixels"""
    pass

# -----------------------------------------------------------------------------
# [SECTION] Miscellaneous
# -----------------------------------------------------------------------------

# IMPLOT3D_API ImDrawList* GetPlotDrawList();    /* original C++ signature */
def get_plot_draw_list() -> ImDrawList:
    """Returns the ImDrawList used for rendering plot items. Use this to add custom rendering inside plots"""
    pass

# -----------------------------------------------------------------------------
# [SECTION] Styles API (legacy)
# -----------------------------------------------------------------------------

# Get current style
# IMPLOT3D_API ImPlot3DStyle& GetStyle();    /* original C++ signature */
def get_style() -> Style:
    pass

# IMPLOT3D_API void SetStyle(const ImPlot3DStyle& style);    /* original C++ signature */
def set_style(style: Style) -> None:
    pass

# Set color styles
# IMPLOT3D_API void StyleColorsAuto(ImPlot3DStyle* dst = nullptr);        /* original C++ signature */
def style_colors_auto(dst: Optional[Style] = None) -> None:
    """Set colors with ImGui style"""
    pass

# IMPLOT3D_API void StyleColorsDark(ImPlot3DStyle* dst = nullptr);        /* original C++ signature */
def style_colors_dark(dst: Optional[Style] = None) -> None:
    """Set colors with dark style"""
    pass

# IMPLOT3D_API void StyleColorsLight(ImPlot3DStyle* dst = nullptr);       /* original C++ signature */
def style_colors_light(dst: Optional[Style] = None) -> None:
    """Set colors with light style"""
    pass

# IMPLOT3D_API void StyleColorsClassic(ImPlot3DStyle* dst = nullptr);     /* original C++ signature */
def style_colors_classic(dst: Optional[Style] = None) -> None:
    """Set colors with classic style"""
    pass

# Temporarily modify a style color. Don't forget to call PopStyleColor!
# IMPLOT3D_API void PushStyleColor(ImPlot3DCol idx, ImU32 col);    /* original C++ signature */
@overload
def push_style_color(idx: Col, col: ImU32) -> None:
    pass

# IMPLOT3D_API void PushStyleColor(ImPlot3DCol idx, const ImVec4& col);    /* original C++ signature */
@overload
def push_style_color(idx: Col, col: ImVec4Like) -> None:
    pass

# IMPLOT3D_API void PopStyleColor(int count = 1);    /* original C++ signature */
def pop_style_color(count: int = 1) -> None:
    """Undo temporary style color modification(s). Undo multiple pushes at once by increasing count"""
    pass

# IMPLOT3D_API void PushStyleVar(ImPlot3DStyleVar idx, float val);    /* original C++ signature */
@overload
def push_style_var(idx: StyleVar, val: float) -> None:
    """Temporarily modify a style variable of float type. Don't forget to call PopStyleVar!"""
    pass

# IMPLOT3D_API void PushStyleVar(ImPlot3DStyleVar idx, int val);    /* original C++ signature */
@overload
def push_style_var(idx: StyleVar, val: int) -> None:
    """Temporarily modify a style variable of int type. Don't forget to call PopStyleVar!"""
    pass

# IMPLOT3D_API void PushStyleVar(ImPlot3DStyleVar idx, const ImVec2& val);    /* original C++ signature */
@overload
def push_style_var(idx: StyleVar, val: ImVec2Like) -> None:
    """Temporarily modify a style variable of ImVec2 type. Don't forget to call PopStyleVar!"""
    pass

# IMPLOT3D_API void PopStyleVar(int count = 1);    /* original C++ signature */
def pop_style_var(count: int = 1) -> None:
    """Undo temporary style variable modification(s). Undo multiple pushes at once by increasing count"""
    pass

# Get color
# IMPLOT3D_API ImVec4 GetStyleColorVec4(ImPlot3DCol idx);    /* original C++ signature */
def get_style_color_vec4(idx: Col) -> ImVec4:
    pass

# IMPLOT3D_API ImU32 GetStyleColorU32(ImPlot3DCol idx);    /* original C++ signature */
def get_style_color_u32(idx: Col) -> ImU32:
    pass

# IMPLOT3D_API ImPlot3DMarker NextMarker();    /* original C++ signature */
def next_marker() -> Marker:
    """Returns the next marker and advances the marker for the current plot. You need to call this between Begin/EndPlot!"""
    pass

# -----------------------------------------------------------------------------
# [SECTION] Colormaps
# -----------------------------------------------------------------------------

# Item styling is based on colormaps when the relevant ImPlot3DCol_XXX is set to
# IMPLOT3D_AUTO_COL (default). Several built-in colormaps are available. You can
# add and then push/pop your own colormaps as well. To permanently set a colormap,
# modify the Colormap index member of your ImPlot3DStyle.

# Colormap data will be ignored and a custom color will be used if you have done one of the following:
#     1) Modified an item style color in your ImPlot3DStyle to anything other than IMPLOT3D_AUTO_COL.

# Add a new colormap. The color data will be copied. The colormap can be used by pushing either the returned index or the
# string name with PushColormap. The colormap name must be unique and the size must be greater than 1. You will receive
# an assert otherwise! By default colormaps are considered to be qualitative (i.e. discrete). If you want to create a
# continuous colormap, set #qual=False. This will treat the colors you provide as keys, and ImPlot3D will build a linearly
# interpolated lookup table. The memory footprint of this table will be exactly ((size-1)*255+1)*4 bytes.

# IMPLOT3D_API ImPlot3DColormap AddColormap(const char* name, const ImVec4* cols, int size, bool qual = true);    /* original C++ signature */
@overload
def add_colormap(name: str, cols: ImVec4Like, size: int, qual: bool = True) -> Colormap:
    pass

# IMPLOT3D_API ImPlot3DColormap AddColormap(const char* name, const ImU32* cols, int size, bool qual = true);    /* original C++ signature */
@overload
def add_colormap(name: str, cols: ImU32, size: int, qual: bool = True) -> Colormap:
    pass

# IMPLOT3D_API int GetColormapCount();    /* original C++ signature */
def get_colormap_count() -> int:
    """Returns the number of available colormaps (i.e. the built-in + user-added count)"""
    pass

# IMPLOT3D_API const char* GetColormapName(ImPlot3DColormap cmap);    /* original C++ signature */
def get_colormap_name(cmap: Colormap) -> str:
    """Returns a null terminated string name for a colormap given an index. Returns None if index is invalid"""
    pass

# IMPLOT3D_API ImPlot3DColormap GetColormapIndex(const char* name);    /* original C++ signature */
def get_colormap_index(name: str) -> Colormap:
    """Returns an index number for a colormap given a valid string name. Returns -1 if name is invalid"""
    pass

# IMPLOT3D_API void PushColormap(ImPlot3DColormap cmap);    /* original C++ signature */
@overload
def push_colormap(cmap: Colormap) -> None:
    """Temporarily switch to one of the built-in (i.e. ImPlot3DColormap_XXX) or user-added colormaps (i.e. a return value of AddColormap). Don't forget to
    call PopColormap!
    """
    pass

# IMPLOT3D_API void PushColormap(const char* name);    /* original C++ signature */
@overload
def push_colormap(name: str) -> None:
    """Push a colormap by string name. Use built-in names such as "Default", "Deep", "Jet", etc. or a string you provided to AddColormap. Don't forget to
    call PopColormap!
    """
    pass

# IMPLOT3D_API void PopColormap(int count = 1);    /* original C++ signature */
def pop_colormap(count: int = 1) -> None:
    """Undo temporary colormap modification(s). Undo multiple pushes at once by increasing count"""
    pass

# IMPLOT3D_API ImVec4 NextColormapColor();    /* original C++ signature */
def next_colormap_color() -> ImVec4:
    """Returns the next color from the current colormap and advances the colormap for the current plot
    Can also be used with no return value to skip colors if desired. You need to call it between Begin/EndPlot!
    """
    pass

# IMPLOT3D_API int GetColormapSize(ImPlot3DColormap cmap = IMPLOT3D_AUTO);    /* original C++ signature */
def get_colormap_size(cmap: Optional[Colormap] = None) -> int:
    """Returns the size of a colormap


    Python bindings defaults:
        If cmap is None, then its default value will be: IMPLOT3D_AUTO
    """
    pass

# IMPLOT3D_API ImVec4 GetColormapColor(int idx, ImPlot3DColormap cmap = IMPLOT3D_AUTO);    /* original C++ signature */
def get_colormap_color(idx: int, cmap: Optional[Colormap] = None) -> ImVec4:
    """Returns a color from a colormap given an index >= 0 (modulo will be performed)


    Python bindings defaults:
        If cmap is None, then its default value will be: IMPLOT3D_AUTO
    """
    pass

# IMPLOT3D_API ImVec4 SampleColormap(float t, ImPlot3DColormap cmap = IMPLOT3D_AUTO);    /* original C++ signature */
def sample_colormap(t: float, cmap: Optional[Colormap] = None) -> ImVec4:
    """Sample a color from the current colormap given t between 0 and 1


    Python bindings defaults:
        If cmap is None, then its default value will be: IMPLOT3D_AUTO
    """
    pass

# -----------------------------------------------------------------------------
# [SECTION] Demo
# -----------------------------------------------------------------------------
# Add implot3_demo.cpp to your sources to use methods in this section

# IMPLOT3D_API void ShowDemoWindow(bool* p_open = nullptr);    /* original C++ signature */
def show_demo_window(p_open: Optional[bool] = None) -> Optional[bool]:
    """Shows the ImPlot3D demo window"""
    pass

# Shows all ImPlot3D demos, without enclosing window
# IMPLOT3D_API void ShowAllDemos();    /* original C++ signature */
def show_all_demos() -> None:
    pass

# IMPLOT3D_API void  ShowDemoWindow_MaybeDocked(bool create_window, bool* p_open = NULL);    /* original C++ signature */
def show_demo_window_maybe_docked(create_window: bool, p_open: Optional[bool] = None) -> Optional[bool]:
    pass

# IMPLOT3D_API void ShowStyleEditor(ImPlot3DStyle* ref = nullptr);    /* original C++ signature */
def show_style_editor(ref: Optional[Style] = None) -> None:
    """Shows ImPlot3D style editor block (not a window)"""
    pass

# IMPLOT3D_API bool ShowStyleSelector(const char* label);    /* original C++ signature */
def show_style_selector(label: str) -> bool:
    """Shows ImPlot3D style selector and returns True if selection is changed (not a window)"""
    pass

# IMPLOT3D_API bool ShowColormapSelector(const char* label);    /* original C++ signature */
def show_colormap_selector(label: str) -> bool:
    """Shows ImPlot3D colormap selector and returns True if selection is changed (not a window)"""
    pass

# IMPLOT3D_API void ShowMetricsWindow(bool* p_popen = nullptr);    /* original C++ signature */
def show_metrics_window(p_popen: Optional[bool] = None) -> Optional[bool]:
    """Shows ImPlot3D metrics/debug information window."""
    pass

# IMPLOT3D_API void ShowAboutWindow(bool* p_open = nullptr);    /* original C++ signature */
def show_about_window(p_open: Optional[bool] = None) -> Optional[bool]:
    """Shows ImPlot3D about window."""
    pass

# -----------------------------------------------------------------------------
# [SECTION] ImPlot3DPoint
# -----------------------------------------------------------------------------

class Point:
    """ImPlot3DPoint: 3D vector to store points in 3D space"""

    # double x,     /* original C++ signature */
    x: float  # Coordinates
    # y,     /* original C++ signature */
    y: float  # Coordinates
    # z;    /* original C++ signature */
    z: float  # Coordinates
    # constexpr ImPlot3DPoint() : x(0.0), y(0.0), z(0.0) {}    /* original C++ signature */
    @overload
    def __init__(self) -> None:
        pass
    # constexpr ImPlot3DPoint(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}    /* original C++ signature */
    @overload
    def __init__(self, _x: float, _y: float, _z: float) -> None:
        pass
    # Accessors
    # double& operator[](size_t idx) {    /* original C++ signature */
    #         IM_ASSERT(idx == 0 || idx == 1 || idx == 2);
    #         return ((double*)(void*)(char*)this)[idx];
    #     }
    @overload
    def __getitem__(self, idx: int) -> float:
        """(private API)"""
        pass
    # double operator[](size_t idx) const {    /* original C++ signature */
    #         IM_ASSERT(idx == 0 || idx == 1 || idx == 2);
    #         return ((const double*)(const void*)(const char*)this)[idx];
    #     }
    @overload
    def __getitem__(self, idx: int) -> float:
        """(private API)"""
        pass
    # Binary operators
    # IMPLOT3D_API ImPlot3DPoint operator*(double rhs) const;    /* original C++ signature */
    @overload
    def __mul__(self, rhs: float) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint operator/(double rhs) const;    /* original C++ signature */
    @overload
    def __truediv__(self, rhs: float) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint operator+(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    def __add__(self, rhs: Point) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint operator-(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    @overload
    def __sub__(self, rhs: Point) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint operator*(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    @overload
    def __mul__(self, rhs: Point) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint operator/(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    @overload
    def __truediv__(self, rhs: Point) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint operator-() const;    /* original C++ signature */
    @overload
    def __neg__(self) -> Point:
        """Unary operator"""
        pass
    # Compound assignment operators
    # IMPLOT3D_API ImPlot3DPoint& operator*=(double rhs);    /* original C++ signature */
    @overload
    def __imul__(self, rhs: float) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint& operator/=(double rhs);    /* original C++ signature */
    @overload
    def __itruediv__(self, rhs: float) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint& operator+=(const ImPlot3DPoint& rhs);    /* original C++ signature */
    def __iadd__(self, rhs: Point) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint& operator-=(const ImPlot3DPoint& rhs);    /* original C++ signature */
    def __isub__(self, rhs: Point) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint& operator*=(const ImPlot3DPoint& rhs);    /* original C++ signature */
    @overload
    def __imul__(self, rhs: Point) -> Point:
        pass
    # IMPLOT3D_API ImPlot3DPoint& operator/=(const ImPlot3DPoint& rhs);    /* original C++ signature */
    @overload
    def __itruediv__(self, rhs: Point) -> Point:
        pass
    # Comparison operators
    # IMPLOT3D_API bool operator==(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    def __eq__(self, rhs: Point) -> bool:
        pass
    # IMPLOT3D_API bool operator!=(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    def __ne__(self, rhs: Point) -> bool:
        pass
    # IMPLOT3D_API double Dot(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    def dot(self, rhs: Point) -> float:
        """Dot product"""
        pass
    # IMPLOT3D_API ImPlot3DPoint Cross(const ImPlot3DPoint& rhs) const;    /* original C++ signature */
    def cross(self, rhs: Point) -> Point:
        """Cross product"""
        pass
    # IMPLOT3D_API double Length() const;    /* original C++ signature */
    def length(self) -> float:
        """Get vector length"""
        pass
    # IMPLOT3D_API double LengthSquared() const;    /* original C++ signature */
    def length_squared(self) -> float:
        """Get vector squared length"""
        pass
    # IMPLOT3D_API void Normalize();    /* original C++ signature */
    def normalize(self) -> None:
        """Normalize to unit length"""
        pass
    # IMPLOT3D_API ImPlot3DPoint Normalized() const;    /* original C++ signature */
    def normalized(self) -> Point:
        """Return vector normalized to unit length"""
        pass
    # IMPLOT3D_API bool IsNaN() const;    /* original C++ signature */
    def is_nan(self) -> bool:
        """Check if the point is NaN"""
        pass

# -----------------------------------------------------------------------------
# [SECTION] ImPlot3DRay
# -----------------------------------------------------------------------------

class Ray:
    """ImPlot3DRay: Represents a ray in 3D space with an origin and direction"""

    # ImPlot3DPoint Origin;    /* original C++ signature */
    origin: Point  # Ray origin point
    # ImPlot3DPoint Direction;    /* original C++ signature */
    direction: Point  # Ray direction (not necessarily normalized)
    # ImPlot3DRay(ImPlot3DPoint Origin = ImPlot3DPoint(), ImPlot3DPoint Direction = ImPlot3DPoint());    /* original C++ signature */
    def __init__(self, origin: Optional[Point] = None, direction: Optional[Point] = None) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * Origin: Point()
                * Direction: Point()
        """
        pass

# -----------------------------------------------------------------------------
# [SECTION] ImPlot3DPlane
# -----------------------------------------------------------------------------

class Plane:
    """ImPlot3DPlane: Represents a plane in 3D space defined by a point and normal vector"""

    # ImPlot3DPoint Point;    /* original C++ signature */
    point: Point  # A point on the plane
    # ImPlot3DPoint Normal;    /* original C++ signature */
    normal: Point  # Plane normal vector
    # ImPlot3DPlane(ImPlot3DPoint Point = ImPlot3DPoint(), ImPlot3DPoint Normal = ImPlot3DPoint());    /* original C++ signature */
    def __init__(self, point: Optional[Point] = None, normal: Optional[Point] = None) -> None:
        """Auto-generated default constructor with named params


        Python bindings defaults:
            If any of the params below is None, then its default value below will be used:
                * Point: Point()
                * Normal: Point()
        """
        pass

# -----------------------------------------------------------------------------
# [SECTION] ImPlot3DBox
# -----------------------------------------------------------------------------

class Box:
    """ImPlot3DBox: Axis-aligned bounding box in 3D space"""

    # ImPlot3DPoint Min;    /* original C++ signature */
    min: Point  # Minimum corner of the box
    # ImPlot3DPoint Max;    /* original C++ signature */
    max: Point  # Maximum corner of the box

    # constexpr ImPlot3DBox() : Min(ImPlot3DPoint()), Max(ImPlot3DPoint()) {}    /* original C++ signature */
    @overload
    def __init__(self) -> None:
        """Default constructor"""
        pass
    # constexpr ImPlot3DBox(const ImPlot3DPoint& min, const ImPlot3DPoint& max) : Min(min), Max(max) {}    /* original C++ signature */
    @overload
    def __init__(self, min: Point, max: Point) -> None:
        """Constructor with two points"""
        pass
    # IMPLOT3D_API void Expand(const ImPlot3DPoint& point);    /* original C++ signature */
    def expand(self, point: Point) -> None:
        """Method to expand the box to include a point"""
        pass
    # IMPLOT3D_API bool Contains(const ImPlot3DPoint& point) const;    /* original C++ signature */
    def contains(self, point: Point) -> bool:
        """Method to check if a point is inside the box"""
        pass
    # IMPLOT3D_API bool ClipLineSegment(const ImPlot3DPoint& p0, const ImPlot3DPoint& p1, ImPlot3DPoint& p0_clipped, ImPlot3DPoint& p1_clipped) const;    /* original C++ signature */
    def clip_line_segment(self, p0: Point, p1: Point, p0_clipped: Point, p1_clipped: Point) -> bool:
        """Method to clip a line segment against the box"""
        pass

# -----------------------------------------------------------------------------
# [SECTION] ImPlot3DRange
# -----------------------------------------------------------------------------

class Range:
    """ImPlot3DRange: Represents a 1D range with min and max values"""

    # double Min;    /* original C++ signature */
    min: float  # Minimum value
    # double Max;    /* original C++ signature */
    max: float  # Maximum value

    # constexpr ImPlot3DRange() : Min(0.0), Max(0.0) {}    /* original C++ signature */
    @overload
    def __init__(self) -> None:
        pass
    # constexpr ImPlot3DRange(double min, double max) : Min(min), Max(max) {}    /* original C++ signature */
    @overload
    def __init__(self, min: float, max: float) -> None:
        pass
    # IMPLOT3D_API void Expand(double value);             /* original C++ signature */
    def expand(self, value: float) -> None:
        """Expand range to include value"""
        pass
    # IMPLOT3D_API bool Contains(double value) const;     /* original C++ signature */
    def contains(self, value: float) -> bool:
        """Check if value is within range"""
        pass
    # double Size() const { return Max - Min; }           /* original C++ signature */
    def size(self) -> float:
        """(private API)

        Get range size
        """
        pass

# -----------------------------------------------------------------------------
# [SECTION] ImPlot3DQuat
# -----------------------------------------------------------------------------

class Quat:
    """ImPlot3DQuat: Quaternion for representing 3D rotations"""

    # double x,     /* original C++ signature */
    x: float  # Quaternion components
    # y,     /* original C++ signature */
    y: float  # Quaternion components
    # z,     /* original C++ signature */
    z: float  # Quaternion components
    # w;    /* original C++ signature */
    w: float  # Quaternion components

    # Constructors
    # constexpr ImPlot3DQuat() : x(0.0), y(0.0), z(0.0), w(1.0) {}    /* original C++ signature */
    @overload
    def __init__(self) -> None:
        pass
    # constexpr ImPlot3DQuat(double _x, double _y, double _z, double _w) : x(_x), y(_y), z(_z), w(_w) {}    /* original C++ signature */
    @overload
    def __init__(self, _x: float, _y: float, _z: float, _w: float) -> None:
        pass
    # IMPLOT3D_API ImPlot3DQuat(double _angle, const ImPlot3DPoint& _axis);    /* original C++ signature */
    @overload
    def __init__(self, _angle: float, _axis: Point) -> None:
        """Construct quaternion from angle-axis representation (angle in radians)"""
        pass
    # IMPLOT3D_API static ImPlot3DQuat FromTwoVectors(const ImPlot3DPoint& v0, const ImPlot3DPoint& v1);    /* original C++ signature */
    @staticmethod
    def from_two_vectors(v0: Point, v1: Point) -> Quat:
        """Create quaternion that rotates from v0 to v1"""
        pass
    # IMPLOT3D_API static ImPlot3DQuat FromElAz(double elevation, double azimuth);    /* original C++ signature */
    @staticmethod
    def from_el_az(elevation: float, azimuth: float) -> Quat:
        """Create quaternion from elevation and azimuth angles (in radians)"""
        pass
    # IMPLOT3D_API double Length() const;    /* original C++ signature */
    def length(self) -> float:
        """Get quaternion length"""
        pass
    # IMPLOT3D_API ImPlot3DQuat Normalized() const;    /* original C++ signature */
    def normalized(self) -> Quat:
        """Get normalized quaternion"""
        pass
    # IMPLOT3D_API ImPlot3DQuat Conjugate() const;    /* original C++ signature */
    def conjugate(self) -> Quat:
        """Conjugate of the quaternion"""
        pass
    # IMPLOT3D_API ImPlot3DQuat Inverse() const;    /* original C++ signature */
    def inverse(self) -> Quat:
        """Inverse of the quaternion"""
        pass
    # Binary operators
    # IMPLOT3D_API ImPlot3DQuat operator*(const ImPlot3DQuat& rhs) const;     /* original C++ signature */
    @overload
    def __mul__(self, rhs: Quat) -> Quat:
        """Quaternion multiplication"""
        pass
    # IMPLOT3D_API ImPlot3DQuat& Normalize();    /* original C++ signature */
    def normalize(self) -> Quat:
        """Normalize the quaternion in place"""
        pass
    # IMPLOT3D_API ImPlot3DPoint operator*(const ImPlot3DPoint& point) const;    /* original C++ signature */
    @overload
    def __mul__(self, point: Point) -> Point:
        """Rotate a 3D point using the quaternion"""
        pass
    # Comparison operators
    # IMPLOT3D_API bool operator==(const ImPlot3DQuat& rhs) const;    /* original C++ signature */
    def __eq__(self, rhs: Quat) -> bool:
        pass
    # IMPLOT3D_API bool operator!=(const ImPlot3DQuat& rhs) const;    /* original C++ signature */
    def __ne__(self, rhs: Quat) -> bool:
        pass
    # IMPLOT3D_API static ImPlot3DQuat Slerp(const ImPlot3DQuat& q1, const ImPlot3DQuat& q2, double t);    /* original C++ signature */
    @staticmethod
    def slerp(q1: Quat, q2: Quat, t: float) -> Quat:
        """Spherical linear interpolation between two quaternions (t in [0,1])"""
        pass
    # IMPLOT3D_API double Dot(const ImPlot3DQuat& rhs) const;    /* original C++ signature */
    def dot(self, rhs: Quat) -> float:
        """Get quaternion dot product"""
        pass

# -----------------------------------------------------------------------------
# [SECTION] ImPlot3DStyle
# -----------------------------------------------------------------------------

class Style:
    """
    (has support for copy.copy)
    """

    # Item style
    # float LineWeight;    /* original C++ signature */
    line_weight: float  # Line weight in pixels
    # int Marker;    /* original C++ signature */
    marker: int  # Default marker type (ImPlot3DMarker_None)
    # float MarkerSize;    /* original C++ signature */
    marker_size: float  # Marker size in pixels (roughly the marker's "radius")
    # float FillAlpha;    /* original C++ signature */
    fill_alpha: float  # Alpha modifier applied to plot fills
    # Plot style
    # ImVec2 PlotDefaultSize;    /* original C++ signature */
    plot_default_size: ImVec2  # Default size used when ImVec2(0,0) is passed to BeginPlot
    # ImVec2 PlotMinSize;    /* original C++ signature */
    plot_min_size: ImVec2  # Minimum size plot frame can be when shrunk
    # ImVec2 PlotPadding;    /* original C++ signature */
    plot_padding: ImVec2  # Padding between widget frame and plot area
    # ImVec2 LabelPadding;    /* original C++ signature */
    label_padding: ImVec2  # Padding between axes labels, tick labels, and plot edge
    # float ViewScaleFactor;    /* original C++ signature */
    view_scale_factor: float  # Scale factor for 3D view
    # Legend style
    # ImVec2 LegendPadding;    /* original C++ signature */
    legend_padding: ImVec2  # Legend padding from plot edges
    # ImVec2 LegendInnerPadding;    /* original C++ signature */
    legend_inner_padding: ImVec2  # Legend inner padding from legend edges
    # ImVec2 LegendSpacing;    /* original C++ signature */
    legend_spacing: ImVec2  # Spacing between legend entries
    # Colors
    # inline ImVec4 GetColor(ImPlot3DCol idx) const { return Colors[idx]; }    /* original C++ signature */
    def get_color(self, idx: Col) -> ImVec4:
        """(private API)"""
        pass
    # inline void SetColor(ImPlot3DCol idx, const ImVec4& col) { Colors[idx] = col; }    /* original C++ signature */
    def set_color(self, idx: Col, col: ImVec4Like) -> None:
        """(private API)"""
        pass
    # Colormap
    # ImPlot3DColormap Colormap;    /* original C++ signature */
    colormap: Colormap  # The current colormap (ImPlot3DColormap_ enum or index from AddColormap)
    # IMPLOT3D_API ImPlot3DStyle();    /* original C++ signature */
    @overload
    def __init__(self) -> None:
        """Constructor"""
        pass
    # ImPlot3DStyle(const ImPlot3DStyle& other) = default;    /* original C++ signature */
    @overload
    def __init__(self, other: Style) -> None:
        pass

# -----------------------------------------------------------------------------
# [SECTION] Meshes
# -----------------------------------------------------------------------------

# Cube

# Sphere

# Duck (Rubber Duck by Poly by Google [CC-BY] via Poly Pizza)

# -----------------------------------------------------------------------------
# [SECTION] Obsolete API
# -----------------------------------------------------------------------------

# The following functions will be removed! Keep your copy of ImPlot3D up to date!
# Occasionally set '#define IMPLOT3D_DISABLE_OBSOLETE_FUNCTIONS' to stay ahead.
# If you absolutely must use these functions and do not want to receive compiler
# warnings, set '#define IMPLOT3D_DISABLE_OBSOLETE_WARNINGS'.

# #endif
####################    </generated_from:implot3d.h>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

###############################################################################
# MANUAL BINDINGS BELOW
###############################################################################

# Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true.
# IMPLOT3D_API void SetupAxisTicks(ImAxis3D axis, double v_min, double v_max, int n_ticks, const char* const labels[] = nullptr, bool keep_default = false);
@overload
def setup_axis_ticks(
    axis: ImAxis3D,
    v_min: float,
    v_max: float,
    n_ticks: int,
    labels: List[str] | None = None,
    keep_default: bool = False,
):
    pass

# Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true.
# IMPLOT3D_API void SetupAxisTicks(ImAxis3D axis, const double* values, int n_ticks, const char* const labels[] = nullptr, bool keep_default = false);
@overload
def setup_axis_ticks(
    axis: ImAxis3D,
    values: List[float],
    labels: List[str] | None = None,
    keep_default: bool = False,
):
    pass


# OBSOLETED in v0.4 (from February 2026)
# ============================================================================
# The following functions have been REMOVED. Use Spec objects instead:
#
# set_next_line_style(col, weight)
#   -> Use: spec=implot3d.Spec(line_color=col, line_weight=weight)
#
# set_next_fill_style(col, alpha_mod)
#   -> Use: spec=implot3d.Spec(fill_color=col, fill_alpha=alpha_mod)
#
# set_next_marker_style(marker, size, fill, weight, outline)
#   -> Use: spec=implot3d.Spec(marker=marker, marker_size=size,
#                               marker_fill_color=fill, line_weight=weight,
#                               marker_line_color=outline)
#
# Example migration:
#   # OLD (removed):
#   implot3d.set_next_line_style(ImVec4(1,0,0,1), 2.0)
#   implot3d.plot_line("data", xs, ys, zs)
#
#   # NEW:
#   implot3d.plot_line("data", xs, ys, zs,
#                      spec=implot3d.Spec(line_color=ImVec4(1,0,0,1),
#                                        line_weight=2.0))
# ============================================================================
