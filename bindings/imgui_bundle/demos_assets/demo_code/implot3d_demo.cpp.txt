// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2024-2026 Breno Cunha Queiroz

// ImPlot3D v0.4 WIP

// Acknowledgments:
//  ImPlot3D is heavily inspired by ImPlot
//  (https://github.com/epezent/implot) by Evan Pezent,
//  and follows a similar code style and structure to
//  maintain consistency with ImPlot's API.

// Table of Contents:
// [SECTION] User Namespace
// [SECTION] Helpers
// [SECTION] Plots
// [SECTION] Axes
// [SECTION] Tools
// [SECTION] Custom
// [SECTION] Config
// [SECTION] Demo Window
// [SECTION] Style Editor
// [SECTION] User Namespace Implementation

// We define this to avoid accidentally using the deprecated API
#ifndef IMPLOT_DISABLE_OBSOLETE_FUNCTIONS
#define IMPLOT_DISABLE_OBSOLETE_FUNCTIONS
#endif

#include "implot3d.h"
#include "implot3d_internal.h"

// IMGUI_DEMO_MARKER can be used to mark sections of the demo and link them to an interactive code browser.
// In order to use it, define it to an actual macro via force-include.
#ifndef IMGUI_DEMO_MARKER
#define IMGUI_DEMO_MARKER(section)  // Called everywhere in the code to mark interesting sections for the reader.
#endif


//-----------------------------------------------------------------------------
// [SECTION] User Namespace
//-----------------------------------------------------------------------------

// Encapsulates examples for customizing ImPlot3D
namespace MyImPlot3D {

// Example for Custom Styles section
void StyleSeaborn();

} // namespace MyImPlot3D

namespace ImPlot3D {

//-----------------------------------------------------------------------------
// [SECTION] Helpers
//-----------------------------------------------------------------------------

#define CHECKBOX_FLAG(flags, flag) ImGui::CheckboxFlags(#flag, (unsigned int*)&flags, flag)

static void HelpMarker(const char* desc) {
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip()) {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

// Utility structure for realtime plot
struct ScrollingBuffer {
    int MaxSize;
    int Offset;
    ImVector<float> Data;
    ScrollingBuffer(int max_size = 2000) {
        MaxSize = max_size;
        Offset = 0;
        Data.reserve(MaxSize);
    }
    void AddPoint(float x) {
        if (Data.size() < MaxSize)
            Data.push_back(x);
        else {
            Data[Offset] = x;
            Offset = (Offset + 1) % MaxSize;
        }
    }
    void Erase() {
        if (Data.size() > 0) {
            Data.shrink(0);
            Offset = 0;
        }
    }
};

// Custom axis formatter that adds metric prefixes (G, M, k, m, u, n)
int MetricFormatter(double value, char* buff, int size, void* data) {
    const char* unit = (const char*)data;
    static double v[] = {1000000000, 1000000, 1000, 1, 0.001, 0.000001, 0.000000001};
    static const char* p[] = {"G", "M", "k", "", "m", "u", "n"};
    if (value == 0) {
        return snprintf(buff, size, "0 %s", unit);
    }
    for (int i = 0; i < 7; ++i) {
        if (fabs(value) >= v[i]) {
            return snprintf(buff, size, "%g %s%s", value / v[i], p[i], unit);
        }
    }
    return snprintf(buff, size, "%g %s%s", value / v[6], p[6], unit);
}

//-----------------------------------------------------------------------------
// [SECTION] Plots
//-----------------------------------------------------------------------------

void DemoLinePlots() {
    IMGUI_DEMO_MARKER("Plots/Line Plots");
    static float xs1[1001], ys1[1001], zs1[1001];
    for (int i = 0; i < 1001; i++) {
        xs1[i] = i * 0.001f;
        ys1[i] = 0.5f + 0.5f * cosf(50 * (xs1[i] + (float)ImGui::GetTime() / 10));
        zs1[i] = 0.5f + 0.5f * sinf(50 * (xs1[i] + (float)ImGui::GetTime() / 10));
    }
    static double xs2[20], ys2[20], zs2[20];
    for (int i = 0; i < 20; i++) {
        xs2[i] = i * 1 / 19.0f;
        ys2[i] = xs2[i] * xs2[i];
        zs2[i] = xs2[i] * ys2[i];
    }
    if (ImPlot3D::BeginPlot("Line Plots")) {
        ImPlot3D::SetupAxes("x", "y", "z");
        ImPlot3D::PlotLine("f(x)", xs1, ys1, zs1, 1001);
        ImPlot3D::PlotLine("g(x)", xs2, ys2, zs2, 20, {ImPlot3DProp_Marker, ImPlot3DMarker_Circle, ImPlot3DProp_Flags, ImPlot3DLineFlags_Segments});
        ImPlot3D::EndPlot();
    }
}

void DemoScatterPlots() {
    IMGUI_DEMO_MARKER("Plots/Scatter Plots");
    srand(0);
    static float xs1[100], ys1[100], zs1[100];
    for (int i = 0; i < 100; i++) {
        xs1[i] = i * 0.01f;
        ys1[i] = xs1[i] + 0.1f * ((float)rand() / (float)RAND_MAX);
        zs1[i] = xs1[i] + 0.1f * ((float)rand() / (float)RAND_MAX);
    }
    static float xs2[50], ys2[50], zs2[50];
    for (int i = 0; i < 50; i++) {
        xs2[i] = 0.25f + 0.2f * ((float)rand() / (float)RAND_MAX);
        ys2[i] = 0.50f + 0.2f * ((float)rand() / (float)RAND_MAX);
        zs2[i] = 0.75f + 0.2f * ((float)rand() / (float)RAND_MAX);
    }

    if (ImPlot3D::BeginPlot("Scatter Plots")) {
        ImPlot3D::PlotScatter("Data 1", xs1, ys1, zs1, 100);
        ImPlot3DSpec spec;
        spec.Marker = ImPlot3DMarker_Square;
        spec.MarkerSize = 6;
        spec.MarkerLineColor = ImPlot3D::GetColormapColor(1);
        spec.MarkerFillColor = ImPlot3D::GetColormapColor(1);
        spec.FillAlpha = 0.25f;
        ImPlot3D::PlotScatter("Data 2", xs2, ys2, zs2, 50, spec);
        ImPlot3D::EndPlot();
    }
}

void DemoTrianglePlots() {
    IMGUI_DEMO_MARKER("Plots/Triangle Plots");
    // Pyramid coordinates
    // Apex
    float ax = 0.0f, ay = 0.0f, az = 1.0f;
    // Square base corners
    float cx[4] = {-0.5f, 0.5f, 0.5f, -0.5f};
    float cy[4] = {-0.5f, -0.5f, 0.5f, 0.5f};
    float cz[4] = {0.0f, 0.0f, 0.0f, 0.0f};

    // We have 6 triangles (18 vertices) total:
    // Sides:
    // T1: apex, corner0, corner1
    // T2: apex, corner1, corner2
    // T3: apex, corner2, corner3
    // T4: apex, corner3, corner0
    // Base (two triangles form a square):
    // T5: corner0, corner1, corner2
    // T6: corner0, corner2, corner3

    static float xs[18], ys[18], zs[18];
    int i = 0;

    // Helper lambda to append a vertex
    auto AddVertex = [&](float X, float Y, float Z) {
        xs[i] = X;
        ys[i] = Y;
        zs[i] = Z;
        i++;
    };

    // Triangle 1
    AddVertex(ax, ay, az);
    AddVertex(cx[0], cy[0], cz[0]);
    AddVertex(cx[1], cy[1], cz[1]);

    // Triangle 2
    AddVertex(ax, ay, az);
    AddVertex(cx[1], cy[1], cz[1]);
    AddVertex(cx[2], cy[2], cz[2]);

    // Triangle 3
    AddVertex(ax, ay, az);
    AddVertex(cx[2], cy[2], cz[2]);
    AddVertex(cx[3], cy[3], cz[3]);

    // Triangle 4
    AddVertex(ax, ay, az);
    AddVertex(cx[3], cy[3], cz[3]);
    AddVertex(cx[0], cy[0], cz[0]);

    // Triangle 5 (base)
    AddVertex(cx[0], cy[0], cz[0]);
    AddVertex(cx[1], cy[1], cz[1]);
    AddVertex(cx[2], cy[2], cz[2]);

    // Triangle 6 (base)
    AddVertex(cx[0], cy[0], cz[0]);
    AddVertex(cx[2], cy[2], cz[2]);
    AddVertex(cx[3], cy[3], cz[3]);

    // Now we have 18 vertices in xs, ys, zs forming the pyramid

    // Triangle flags
    static ImPlot3DTriangleFlags flags = ImPlot3DTriangleFlags_None;
    CHECKBOX_FLAG(flags, ImPlot3DTriangleFlags_NoLines);
    CHECKBOX_FLAG(flags, ImPlot3DTriangleFlags_NoFill);
    CHECKBOX_FLAG(flags, ImPlot3DTriangleFlags_NoMarkers);

    if (ImPlot3D::BeginPlot("Triangle Plots")) {
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -0.5, 1.5);

        // Setup pyramid colors
        ImPlot3DSpec spec;
        spec.FillColor = ImPlot3D::GetColormapColor(0);
        spec.LineColor = ImPlot3D::GetColormapColor(1);
        spec.Marker = ImPlot3DMarker_Square;
        spec.MarkerSize = 3;
        spec.Flags = flags;

        // Plot pyramid
        ImPlot3D::PlotTriangle("Pyramid", xs, ys, zs, 6 * 3, spec); // 6 triangles, 3 vertices each = 18
        ImPlot3D::EndPlot();
    }
}

void DemoQuadPlots() {
    IMGUI_DEMO_MARKER("Plots/Quad Plots");
    static float xs[6 * 4], ys[6 * 4], zs[6 * 4];

    // clang-format off
    // Initialize the cube vertices for +x and -x faces
    // +x face
    xs[0] = 1; ys[0] = -1; zs[0] = -1;
    xs[1] = 1; ys[1] =  1; zs[1] = -1;
    xs[2] = 1; ys[2] =  1; zs[2] =  1;
    xs[3] = 1; ys[3] = -1; zs[3] =  1;

    // -x face
    xs[4] = -1; ys[4] = -1; zs[4] = -1;
    xs[5] = -1; ys[5] =  1; zs[5] = -1;
    xs[6] = -1; ys[6] =  1; zs[6] =  1;
    xs[7] = -1; ys[7] = -1; zs[7] =  1;

    // Initialize the cube vertices for +y and -y faces
    // +y face
    xs[8] = -1; ys[8] = 1; zs[8] = -1;
    xs[9] =  1; ys[9] = 1; zs[9] = -1;
    xs[10] =  1; ys[10] = 1; zs[10] =  1;
    xs[11] = -1; ys[11] = 1; zs[11] =  1;

    // -y face
    xs[12] = -1; ys[12] = -1; zs[12] = -1;
    xs[13] =  1; ys[13] = -1; zs[13] = -1;
    xs[14] =  1; ys[14] = -1; zs[14] =  1;
    xs[15] = -1; ys[15] = -1; zs[15] =  1;

    // Initialize the cube vertices for +z and -z faces
    // +z face
    xs[16] = -1; ys[16] = -1; zs[16] = 1;
    xs[17] =  1; ys[17] = -1; zs[17] = 1;
    xs[18] =  1; ys[18] =  1; zs[18] = 1;
    xs[19] = -1; ys[19] =  1; zs[19] = 1;

    // -z face
    xs[20] = -1; ys[20] = -1; zs[20] = -1;
    xs[21] =  1; ys[21] = -1; zs[21] = -1;
    xs[22] =  1; ys[22] =  1; zs[22] = -1;
    xs[23] = -1; ys[23] =  1; zs[23] = -1;
    // clang-format on

    // Quad flags
    static ImPlot3DQuadFlags flags = ImPlot3DQuadFlags_None;
    CHECKBOX_FLAG(flags, ImPlot3DQuadFlags_NoLines);
    CHECKBOX_FLAG(flags, ImPlot3DQuadFlags_NoFill);
    CHECKBOX_FLAG(flags, ImPlot3DQuadFlags_NoMarkers);

    if (ImPlot3D::BeginPlot("Quad Plots")) {
        ImPlot3D::SetupAxesLimits(-1.5, 1.5, -1.5, 1.5, -1.5, 1.5);

        ImPlot3DSpec spec;
        spec.Marker = ImPlot3DMarker_Square;
        spec.MarkerSize = 3;
        spec.Flags = flags;

        // Render +x and -x faces
        static ImVec4 colorX(0.8f, 0.2f, 0.2f, 0.8f); // Red
        spec.FillColor = colorX;
        spec.LineColor = colorX;
        ImPlot3D::PlotQuad("X", &xs[0], &ys[0], &zs[0], 8, spec);

        // Render +y and -y faces
        static ImVec4 colorY(0.2f, 0.8f, 0.2f, 0.8f); // Green
        spec.FillColor = colorY;
        spec.LineColor = colorY;
        ImPlot3D::PlotQuad("Y", &xs[8], &ys[8], &zs[8], 8, spec);

        // Render +z and -z faces
        static ImVec4 colorZ(0.2f, 0.2f, 0.8f, 0.8f); // Blue
        spec.FillColor = colorZ;
        spec.LineColor = colorZ;
        ImPlot3D::PlotQuad("Z", &xs[16], &ys[16], &zs[16], 8, spec);

        ImPlot3D::EndPlot();
    }
}

void DemoSurfacePlots() {
    IMGUI_DEMO_MARKER("Plots/Surface Plots");
    constexpr int N = 20;
    static float xs[N * N], ys[N * N], zs[N * N];
    static float t = 0.0f;
    t += ImGui::GetIO().DeltaTime;

    // Define the range for X and Y
    constexpr float min_val = -1.0f;
    constexpr float max_val = 1.0f;
    constexpr float step = (max_val - min_val) / (N - 1);

    // Populate the xs, ys, and zs arrays
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            int idx = i * N + j;
            xs[idx] = min_val + j * step;                                             // X values are constant along rows
            ys[idx] = min_val + i * step;                                             // Y values are constant along columns
            zs[idx] = ImSin(2 * t + ImSqrt((xs[idx] * xs[idx] + ys[idx] * ys[idx]))); // z = sin(2t + sqrt(x^2 + y^2))
        }
    }

    // Choose fill color
    ImGui::Text("Fill color");
    static int selected_fill = 1; // Colormap by default
    static ImVec4 solid_color = ImVec4(0.8f, 0.8f, 0.2f, 0.6f);
    const char* colormaps[] = {"Viridis", "Plasma", "Hot", "Cool", "Pink", "Jet", "Twilight", "RdBu", "BrBG", "PiYG", "Spectral", "Greys"};
    static int sel_colormap = 5; // Jet by default
    {
        ImGui::Indent();

        // Choose solid color
        ImGui::RadioButton("Solid", &selected_fill, 0);
        if (selected_fill == 0) {
            ImGui::SameLine();
            ImGui::ColorEdit4("##SurfaceSolidColor", (float*)&solid_color);
        }

        // Choose colormap
        ImGui::RadioButton("Colormap", &selected_fill, 1);
        if (selected_fill == 1) {
            ImGui::SameLine();
            ImGui::Combo("##SurfaceColormap", &sel_colormap, colormaps, IM_ARRAYSIZE(colormaps));
        }
        ImGui::Unindent();
    }

    // Choose range
    static bool custom_range = false;
    static float range_min = -1.0f;
    static float range_max = 1.0f;
    ImGui::Checkbox("Custom range", &custom_range);
    {
        ImGui::Indent();

        if (!custom_range)
            ImGui::BeginDisabled();
        ImGui::SliderFloat("Range min", &range_min, -1.0f, range_max - 0.01f);
        ImGui::SliderFloat("Range max", &range_max, range_min + 0.01f, 1.0f);
        if (!custom_range)
            ImGui::EndDisabled();

        ImGui::Unindent();
    }

    // Select flags
    static ImPlot3DSurfaceFlags flags = ImPlot3DSurfaceFlags_NoMarkers;
    CHECKBOX_FLAG(flags, ImPlot3DSurfaceFlags_NoLines);
    CHECKBOX_FLAG(flags, ImPlot3DSurfaceFlags_NoFill);
    CHECKBOX_FLAG(flags, ImPlot3DSurfaceFlags_NoMarkers);

    // Begin the plot
    if (selected_fill == 1)
        ImPlot3D::PushColormap(colormaps[sel_colormap]);
    if (ImPlot3D::BeginPlot("Surface Plots", ImVec2(-1, 0), ImPlot3DFlags_NoClip)) {
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -1.5, 1.5);

        ImPlot3DSpec spec;
        spec.FillAlpha = 0.8f;
        spec.Flags = flags;
        spec.Marker = ImPlot3DMarker_Square;
        spec.LineColor = ImPlot3D::GetColormapColor(1);
        if (selected_fill == 0)
            spec.FillColor = solid_color;

        // Plot the surface
        if (custom_range)
            ImPlot3D::PlotSurface("Wave Surface", xs, ys, zs, N, N, (double)range_min, (double)range_max, spec);
        else
            ImPlot3D::PlotSurface("Wave Surface", xs, ys, zs, N, N, 0.0, 0.0, spec);

        // End the plot
        ImPlot3D::EndPlot();
    }
    if (selected_fill == 1)
        ImPlot3D::PopColormap();
}

void DemoMeshPlots() {
    IMGUI_DEMO_MARKER("Plots/Mesh Plots");
    static int mesh_id = 0;
    ImGui::Combo("Mesh", &mesh_id, "Duck\0Sphere\0Cube\0\0");

    // Choose line color
    static ImVec4 line_color = ImVec4(0.5f, 0.5f, 0.2f, 0.6f);
    ImGui::ColorEdit4("Line Color##Mesh", (float*)&line_color);

    // Choose fill color
    static ImVec4 fill_color = ImVec4(0.8f, 0.8f, 0.2f, 0.6f);
    ImGui::ColorEdit4("Fill Color##Mesh", (float*)&fill_color);

    // Choose marker color
    static ImVec4 marker_color = ImVec4(0.5f, 0.5f, 0.2f, 0.6f);
    ImGui::ColorEdit4("Marker Color##Mesh", (float*)&marker_color);

    // Mesh flags
    static ImPlot3DMeshFlags flags = ImPlot3DMeshFlags_NoMarkers;
    CHECKBOX_FLAG(flags, ImPlot3DMeshFlags_NoLines);
    CHECKBOX_FLAG(flags, ImPlot3DMeshFlags_NoFill);
    CHECKBOX_FLAG(flags, ImPlot3DMeshFlags_NoMarkers);

    if (ImPlot3D::BeginPlot("Mesh Plots")) {
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -1, 1);

        ImPlot3DSpec spec;
        spec.Flags = flags;
        // Set fill style
        spec.FillColor = fill_color;
        // Set line style
        spec.LineColor = line_color;
        // Set marker style
        spec.Marker = ImPlot3DMarker_Square;
        spec.MarkerSize = 3.0f;
        spec.MarkerLineColor = marker_color;
        spec.MarkerFillColor = marker_color;

        // Plot mesh
        if (mesh_id == 0)
            ImPlot3D::PlotMesh("Duck", duck_vtx, duck_idx, DUCK_VTX_COUNT, DUCK_IDX_COUNT, spec);
        else if (mesh_id == 1)
            ImPlot3D::PlotMesh("Sphere", sphere_vtx, sphere_idx, SPHERE_VTX_COUNT, SPHERE_IDX_COUNT, spec);
        else if (mesh_id == 2)
            ImPlot3D::PlotMesh("Cube", cube_vtx, cube_idx, CUBE_VTX_COUNT, CUBE_IDX_COUNT, spec);

        ImPlot3D::EndPlot();
    }
}

void DemoImagePlots() {
    IMGUI_DEMO_MARKER("Plots/Image Plots");
    ImGui::BulletText("Below we are displaying the font texture, which is the only texture we have\naccess to in this demo.");
    ImGui::BulletText("Use the 'ImTextureID' type as storage to pass pointers or identifiers to your\nown texture data.");
    ImGui::BulletText("See ImGui Wiki page 'Image Loading and Displaying Examples'.");

    static ImVec4 tint1(1, 1, 1, 1);
    static ImVec4 tint2(1, 1, 1, 1);

    static ImPlot3DPoint center1(0, 0, 1);
    static ImPlot3DPoint axis_u1(1, 0, 0);
    static ImPlot3DPoint axis_v1(0, 1, 0);
    static ImVec2 uv0_1(0, 0), uv1_1(1, 1);

    static ImPlot3DPoint p0(-1, -1, 0);
    static ImPlot3DPoint p1(1, -1, 0);
    static ImPlot3DPoint p2(1, 1, 0);
    static ImPlot3DPoint p3(-1, 1, 0);
    static ImVec2 uv0(0, 0), uv1(1, 0), uv2(1, 1), uv3(0, 1);

    // Spacing
    ImGui::Dummy(ImVec2(0, 10));

    // Image 1 Controls
    if (ImGui::TreeNodeEx("Image 1 Controls: Center + Axes")) {
        float center1_f[3] = {(float)center1.x, (float)center1.y, (float)center1.z};
        if (ImGui::SliderFloat3("Center", center1_f, -2, 2, "%.1f")) {
            center1 = ImPlot3DPoint(center1_f[0], center1_f[1], center1_f[2]);
        }
        float axis_u1_f[3] = {(float)axis_u1.x, (float)axis_u1.y, (float)axis_u1.z};
        if (ImGui::SliderFloat3("Axis U", axis_u1_f, -2, 2, "%.1f")) {
            axis_u1 = ImPlot3DPoint(axis_u1_f[0], axis_u1_f[1], axis_u1_f[2]);
        }
        float axis_v1_f[3] = {(float)axis_v1.x, (float)axis_v1.y, (float)axis_v1.z};
        if (ImGui::SliderFloat3("Axis V", axis_v1_f, -2, 2, "%.1f")) {
            axis_v1 = ImPlot3DPoint(axis_v1_f[0], axis_v1_f[1], axis_v1_f[2]);
        }
        ImGui::SliderFloat2("UV0", &uv0_1.x, 0, 1, "%.2f");
        ImGui::SliderFloat2("UV1", &uv1_1.x, 0, 1, "%.2f");
        ImGui::ColorEdit4("Tint", &tint1.x);

        ImGui::TreePop();
    }

    // Image 2 Controls
    if (ImGui::TreeNodeEx("Image 2 Controls: Full Quad")) {
        float p0_f[3] = {(float)p0.x, (float)p0.y, (float)p0.z};
        if (ImGui::SliderFloat3("P0", p0_f, -2, 2, "%.1f")) {
            p0 = ImPlot3DPoint(p0_f[0], p0_f[1], p0_f[2]);
        }
        float p1_f[3] = {(float)p1.x, (float)p1.y, (float)p1.z};
        if (ImGui::SliderFloat3("P1", p1_f, -2, 2, "%.1f")) {
            p1 = ImPlot3DPoint(p1_f[0], p1_f[1], p1_f[2]);
        }
        float p2_f[3] = {(float)p2.x, (float)p2.y, (float)p2.z};
        if (ImGui::SliderFloat3("P2", p2_f, -2, 2, "%.1f")) {
            p2 = ImPlot3DPoint(p2_f[0], p2_f[1], p2_f[2]);
        }
        float p3_f[3] = {(float)p3.x, (float)p3.y, (float)p3.z};
        if (ImGui::SliderFloat3("P3", p3_f, -2, 2, "%.1f")) {
            p3 = ImPlot3DPoint(p3_f[0], p3_f[1], p3_f[2]);
        }

        ImGui::SliderFloat2("UV0", &uv0.x, 0, 1, "%.2f");
        ImGui::SliderFloat2("UV1", &uv1.x, 0, 1, "%.2f");
        ImGui::SliderFloat2("UV2", &uv2.x, 0, 1, "%.2f");
        ImGui::SliderFloat2("UV3", &uv3.x, 0, 1, "%.2f");

        ImGui::ColorEdit4("Tint##2", &tint2.x);

        ImGui::TreePop();
    }

    // Plot
    if (ImPlot3D::BeginPlot("Image Plot", ImVec2(-1, 0), ImPlot3DFlags_NoClip)) {
#ifdef IMGUI_HAS_TEXTURES
        // We use the font atlas ImTextureRef for this demo, but in your real code when you submit
        // an image that you have loaded yourself, you would normally have a ImTextureID which works
        // just as well (as ImTextureRef can be constructed from ImTextureID).
        ImTextureRef tex = ImGui::GetIO().Fonts->TexRef;
#else
        ImTextureID tex = ImGui::GetIO().Fonts->TexID;
#endif

        ImPlot3D::PlotImage("Image 1", tex, center1, axis_u1, axis_v1, uv0_1, uv1_1, tint1);
        ImPlot3D::PlotImage("Image 2", tex, p0, p1, p2, p3, uv0, uv1, uv2, uv3, tint2);

        ImPlot3D::EndPlot();
    }
}

void DemoRealtimePlots() {
    IMGUI_DEMO_MARKER("Plots/Realtime Plots");
    ImGui::BulletText("Move your mouse to change the data!");
    static ScrollingBuffer sdata1, sdata2, sdata3;
    static ImPlot3DAxisFlags flags = ImPlot3DAxisFlags_NoTickLabels;
    static float t = 0.0f;
    static float last_t = -1.0f;

    if (ImPlot3D::BeginPlot("Scrolling Plot")) {
        // Pool mouse data every 10 ms
        t += ImGui::GetIO().DeltaTime;
        if (t - last_t > 0.01f) {
            last_t = t;
            ImVec2 mouse = ImGui::GetMousePos();
            if (ImAbs(mouse.x) < 1e4f && ImAbs(mouse.y) < 1e4f) {
                ImVec2 plot_center = ImPlot3D::GetFramePos();
                plot_center.x += ImPlot3D::GetFrameSize().x / 2;
                plot_center.y += ImPlot3D::GetFrameSize().y / 2;
                sdata1.AddPoint(t);
                sdata2.AddPoint(mouse.x - plot_center.x);
                sdata3.AddPoint(mouse.y - plot_center.y);
            }
        }

        ImPlot3D::SetupAxes("Time", "Mouse X", "Mouse Y", flags, flags, flags);
        ImPlot3D::SetupAxisLimits(ImAxis3D_X, t - 10.0, t, ImPlot3DCond_Always);
        ImPlot3D::SetupAxisLimits(ImAxis3D_Y, -400, 400, ImPlot3DCond_Once);
        ImPlot3D::SetupAxisLimits(ImAxis3D_Z, -400, 400, ImPlot3DCond_Once);
        ImPlot3D::PlotLine("Mouse", &sdata1.Data[0], &sdata2.Data[0], &sdata3.Data[0], sdata1.Data.size(),
                           {ImPlot3DProp_Offset, sdata1.Offset, ImPlot3DProp_Stride, sizeof(float)});
        ImPlot3D::EndPlot();
    }
}

void DemoPlotFlags() {
    IMGUI_DEMO_MARKER("Plots/Plot Flags");
    static ImPlot3DFlags flags = ImPlot3DFlags_None;

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoTitle);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Hide plot title");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoLegend);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Hide plot legend");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoMouseText);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Hide mouse position in plot coordinates");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoClip);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Disable 3D box clipping");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoMenus);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("The user will not be able to open context menus");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_Equal);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("X, Y, and Z axes will be constrained to have the same units/pixel");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoRotate);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Lock rotation interaction");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoPan);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Lock panning/translation interaction");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoZoom);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Lock zooming interaction");
    }

    CHECKBOX_FLAG(flags, ImPlot3DFlags_NoInputs);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Disable all user inputs");
    }

    if (ImPlot3D::BeginPlot("Plot Flags Demo", ImVec2(-1, 0), flags)) {
        ImPlot3D::SetupAxes("X-axis", "Y-axis", "Z-axis");
        ImPlot3D::SetupAxesLimits(-10, 10, -10, 10, -5, 5);

        // Generate some sample data for demonstration
        static float x[100], y[100], z[100];
        static bool first = true;
        if (first) {
            for (int i = 0; i < 100; i++) {
                float t = i * 0.1f;
                x[i] = 3.0f * cosf(t);
                y[i] = 3.0f * sinf(t);
                z[i] = t - 5.0f;
            }
            first = false;
        }

        ImPlot3D::PlotLine("Helix", x, y, z, 100);

        // Add some scatter points to show equal scaling effect
        float scatter_x[8] = {-10, 10, -10, 10, -10, 10, -10, 10};
        float scatter_y[8] = {-10, -10, 10, 10, -10, -10, 10, 10};
        float scatter_z[8] = {-5, -5, -5, -5, 5, 5, 5, 5};
        ImPlot3D::PlotScatter("Cube corners", scatter_x, scatter_y, scatter_z, 8);

        ImPlot3D::EndPlot();
    }
}

void DemoOffsetAndStride() {
    IMGUI_DEMO_MARKER("Plots/Offset and Stride");
    static const int k_spirals = 11;
    static const int k_points_per = 50;
    static const int k_size = 3 * k_points_per * k_spirals;
    static double interleaved_data[k_size];
    for (int p = 0; p < k_points_per; ++p) {
        for (int s = 0; s < k_spirals; ++s) {
            double r = (double)s / (k_spirals - 1) * 0.2 + 0.2;
            double theta = (double)p / k_points_per * 6.28;
            interleaved_data[p * 3 * k_spirals + 3 * s + 0] = 0.5 + r * cos(theta);
            interleaved_data[p * 3 * k_spirals + 3 * s + 1] = 0.5 + r * sin(theta);
            interleaved_data[p * 3 * k_spirals + 3 * s + 2] = 0.5 + 0.5 * sin(2.0 * theta);
        }
    }
    static int offset = 0;
    ImGui::BulletText("Offsetting is useful for realtime plots (see above) and circular buffers.");
    ImGui::BulletText("Striding is useful for interleaved data (e.g. audio) or plotting structs.");
    ImGui::BulletText("Here, all spiral data is stored in a single interleaved buffer:");
    ImGui::BulletText("[s0.x0 s0.y0 s0.z0 ... sn.x0 sn.y0 sn.z0 s0.x1 s0.y1 s0.z1 ... sn.x1 sn.y1 sn.z1 ... sn.xm sn.ym sn.zm]");
    ImGui::BulletText("The offset value indicates which spiral point index is considered the first.");
    ImGui::BulletText("Offsets can be negative and/or larger than the actual data count.");
    ImGui::SliderInt("Offset", &offset, -2 * k_points_per, 2 * k_points_per);
    if (ImPlot3D::BeginPlot("##strideoffset", ImVec2(-1, 0))) {
        ImPlot3D::PushColormap(ImPlot3DColormap_Jet);
        char buff[32];
        for (int s = 0; s < k_spirals; ++s) {
            snprintf(buff, sizeof(buff), "Spiral %d", s);
            ImPlot3DSpec spec;
            spec.Offset = offset;
            spec.Stride = 3 * k_spirals * sizeof(double);
            ImPlot3D::PlotLine(buff, &interleaved_data[s * 3 + 0], &interleaved_data[s * 3 + 1], &interleaved_data[s * 3 + 2], k_points_per, spec);
        }
        ImPlot3D::EndPlot();
        ImPlot3D::PopColormap();
    }
}

void DemoLegendOptions() {
    IMGUI_DEMO_MARKER("Plots/Legend Options");
    static ImPlot3DLocation loc = ImPlot3DLocation_East;
    ImGui::CheckboxFlags("North", (unsigned int*)&loc, ImPlot3DLocation_North);
    ImGui::SameLine();
    ImGui::CheckboxFlags("South", (unsigned int*)&loc, ImPlot3DLocation_South);
    ImGui::SameLine();
    ImGui::CheckboxFlags("West", (unsigned int*)&loc, ImPlot3DLocation_West);
    ImGui::SameLine();
    ImGui::CheckboxFlags("East", (unsigned int*)&loc, ImPlot3DLocation_East);

    static ImPlot3DLegendFlags flags = 0;

    CHECKBOX_FLAG(flags, ImPlot3DLegendFlags_Horizontal);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Legend entries will be displayed horizontally");
    }

    CHECKBOX_FLAG(flags, ImPlot3DLegendFlags_NoButtons);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Legend icons will not function as hide/show buttons");
    }

    CHECKBOX_FLAG(flags, ImPlot3DLegendFlags_NoHighlightItem);
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Plot items will not be highlighted when their legend entry is hovered");
    }

    ImGui::SliderFloat2("LegendPadding", (float*)&ImPlot3D::GetStyle().LegendPadding, 0.0f, 20.0f, "%.0f");
    ImGui::SliderFloat2("LegendInnerPadding", (float*)&ImPlot3D::GetStyle().LegendInnerPadding, 0.0f, 10.0f, "%.0f");
    ImGui::SliderFloat2("LegendSpacing", (float*)&ImPlot3D::GetStyle().LegendSpacing, 0.0f, 5.0f, "%.0f");

    if (ImPlot3D::BeginPlot("Legend Options Demo", ImVec2(-1, 0))) {
        ImPlot3D::SetupAxes("X-Axis", "Y-Axis", "Z-Axis");
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -1, 1);
        ImPlot3D::SetupLegend(loc, flags);

        // Generate some 3D line data
        static float t = 0;
        t += ImGui::GetIO().DeltaTime * 0.5f;

        constexpr int count = 50;
        static float xs1[count], ys1[count], zs1[count];
        static float xs2[count], ys2[count], zs2[count];
        static float xs3[count], ys3[count], zs3[count];

        for (int i = 0; i < count; i++) {
            float phase = i * 0.1f + t;
            xs1[i] = 0.8f * cosf(phase);
            ys1[i] = 0.8f * sinf(phase);
            zs1[i] = 0.5f * sinf(phase * 2);

            xs2[i] = 0.6f * cosf(phase + 1.0f);
            ys2[i] = 0.6f * sinf(phase + 1.0f);
            zs2[i] = -0.3f * cosf(phase * 1.5f);

            xs3[i] = 0.4f * sinf(phase);
            ys3[i] = 0.4f * cosf(phase);
            zs3[i] = 0.7f * cosf(phase * 0.8f);
        }

        ImPlot3D::PlotLine("Helix A", xs1, ys1, zs1, count);
        ImPlot3D::PlotLine("Helix B##IDText", xs2, ys2, zs2, count); // Text after ## used for ID only
        ImPlot3D::PlotLine("##NotListed", xs3, ys3, zs3, count);     // Plotted, but not added to legend

        ImPlot3D::EndPlot();
    }
}

void DemoMarkersAndText() {
    IMGUI_DEMO_MARKER("Plots/Markers and Text");
    static float mk_size = ImPlot3D::GetStyle().MarkerSize;
    static float mk_weight = ImPlot3D::GetStyle().LineWeight;
    ImGui::DragFloat("Marker Size", &mk_size, 0.1f, 2.0f, 10.0f, "%.2f px");
    ImGui::DragFloat("Marker Weight", &mk_weight, 0.05f, 0.5f, 3.0f, "%.2f px");

    if (ImPlot3D::BeginPlot("##MarkerStyles", ImVec2(-1, 0), ImPlot3DFlags_CanvasOnly)) {

        ImPlot3D::SetupAxes(nullptr, nullptr, nullptr, ImPlot3DAxisFlags_NoDecorations, ImPlot3DAxisFlags_NoDecorations,
                            ImPlot3DAxisFlags_NoDecorations);
        ImPlot3D::SetupAxesLimits(-0.5, 1.5, -0.5, 1.5, 0, ImPlot3DMarker_COUNT + 1);

        float xs[2] = {0, 0};
        float ys[2] = {0, 0};
        float zs[2] = {ImPlot3DMarker_COUNT, ImPlot3DMarker_COUNT + 1};

        // Filled markers
        for (int m = 0; m < ImPlot3DMarker_COUNT; ++m) {
            xs[1] = xs[0] + ImCos(zs[0] / float(ImPlot3DMarker_COUNT) * 2 * IM_PI) * 0.5f;
            ys[1] = ys[0] + ImSin(zs[0] / float(ImPlot3DMarker_COUNT) * 2 * IM_PI) * 0.5f;

            ImGui::PushID(m);
            ImPlot3D::PlotLine("##Filled", xs, ys, zs, 2,
                               {ImPlot3DProp_Marker, m, ImPlot3DProp_MarkerSize, mk_size, ImPlot3DProp_LineWeight, mk_weight});
            ImGui::PopID();
            zs[0]--;
            zs[1]--;
        }

        xs[0] = 1;
        ys[0] = 1;
        zs[0] = ImPlot3DMarker_COUNT;
        zs[1] = zs[0] + 1;

        // Open markers
        for (int m = 0; m < ImPlot3DMarker_COUNT; ++m) {
            xs[1] = xs[0] + ImCos(zs[0] / float(ImPlot3DMarker_COUNT) * 2 * IM_PI) * 0.5f;
            ys[1] = ys[0] - ImSin(zs[0] / float(ImPlot3DMarker_COUNT) * 2 * IM_PI) * 0.5f;

            ImGui::PushID(m);
            ImPlot3D::PlotLine("##Open", xs, ys, zs, 2,
                               {ImPlot3DProp_Marker, m, ImPlot3DProp_MarkerSize, mk_size, ImPlot3DProp_LineWeight, mk_weight, ImPlot3DProp_FillColor,
                                ImVec4(0, 0, 0, 0)});
            ImGui::PopID();
            zs[0]--;
            zs[1]--;
        }

        ImPlot3D::PlotText("Filled Markers", 0.0, 0.0, 6.0);
        ImPlot3D::PlotText("Open Markers", 1.0, 1.0, 6.0);

        ImPlot3D::PushStyleColor(ImPlot3DCol_InlayText, ImVec4(1, 0, 1, 1));
        ImPlot3D::PlotText("Rotated Text", 0.5, 0.5, 6.0, IM_PI / 4, ImVec2(0, 0));
        ImPlot3D::PopStyleColor();

        ImPlot3D::EndPlot();
    }
}

void DemoNaNValues() {
    IMGUI_DEMO_MARKER("Plots/NaN Values");
    static bool include_nan = true;
    static ImPlot3DLineFlags flags = 0;

    float data1[5] = {0.0f, 0.25f, 0.5f, 0.75f, 1.0f};
    float data2[5] = {0.0f, 0.25f, 0.5f, 0.75f, 1.0f};
    float data3[5] = {0.0f, 0.25f, 0.5f, 0.75f, 1.0f};

    if (include_nan)
        data1[2] = NAN;

    ImGui::Checkbox("Include NaN", &include_nan);
    ImGui::SameLine();
    ImGui::CheckboxFlags("Skip NaN", (unsigned int*)&flags, ImPlot3DLineFlags_SkipNaN);

    if (ImPlot3D::BeginPlot("##NaNValues")) {
        ImPlot3D::PlotLine("Line", data1, data2, data3, 5, {ImPlot3DProp_Flags, flags, ImPlot3DProp_Marker, ImPlot3DMarker_Square});
        ImPlot3D::EndPlot();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Axes
//-----------------------------------------------------------------------------

void DemoBoxScale() {
    IMGUI_DEMO_MARKER("Axes/Box Scale");
    constexpr int N = 100;
    float xs[N], ys[N], zs[N];
    for (int i = 0; i < N; i++) {
        float t = i / (float)(N - 1);
        xs[i] = sinf(t * 2.0f * IM_PI);
        ys[i] = cosf(t * 4.0f * IM_PI);
        zs[i] = t * 2.0f - 1.0f;
    }

    static float scale[3] = {1.0f, 1.0f, 1.0f};
    ImGui::SliderFloat3("Box Scale", scale, 0.1f, 2.0f, "%.2f");

    if (ImPlot3D::BeginPlot("##BoxScale")) {
        ImPlot3D::SetupBoxScale(scale[0], scale[1], scale[2]);
        ImPlot3D::PlotLine("3D Curve", xs, ys, zs, N);
        ImPlot3D::EndPlot();
    }
}

void DemoBoxRotation() {
    IMGUI_DEMO_MARKER("Axes/Box Rotation");
    double origin[2] = {0.0, 0.0};
    double axis[2] = {0.0, 1.0};

    // Sliders for rotation angles
    static float elevation = 45.0f;
    static float azimuth = -135.0f;
    static bool animate = false;
    ImGui::Text("Rotation");
    bool changed = false;
    if (ImGui::SliderFloat("Elevation", &elevation, -90.0f, 90.0f, "%.1f degrees"))
        changed = true;
    if (ImGui::SliderFloat("Azimuth", &azimuth, -180.0f, 180.0f, "%.1f degrees"))
        changed = true;
    ImGui::Checkbox("Animate", &animate);

    ImGui::Text("Initial Rotation");
    ImGui::SameLine();
    HelpMarker("The rotation will be reset to the initial rotation when you double right-click");
    static float init_elevation = 45.0f;
    static float init_azimuth = -135.0f;
    ImGui::SliderFloat("Initial Elevation", &init_elevation, -90.0f, 90.0f, "%.1f degrees");
    ImGui::SliderFloat("Initial Azimuth", &init_azimuth, -180.0f, 180.0f, "%.1f degrees");

    if (ImPlot3D::BeginPlot("##BoxRotation")) {
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -1, 1, ImPlot3DCond_Always);

        // Set initial rotation
        ImPlot3D::SetupBoxInitialRotation(init_elevation, init_azimuth);

        // Set the rotation using the specified elevation and azimuth
        if (changed)
            ImPlot3D::SetupBoxRotation(elevation, azimuth, animate, ImPlot3DCond_Always);

        // Plot axis lines
        ImPlot3D::PlotLine("X-Axis", axis, origin, origin, 2, {ImPlot3DProp_LineColor, ImVec4(0.8f, 0.2f, 0.2f, 1)});
        ImPlot3D::PlotLine("Y-Axis", origin, axis, origin, 2, {ImPlot3DProp_LineColor, ImVec4(0.2f, 0.8f, 0.2f, 1)});
        ImPlot3D::PlotLine("Z-Axis", origin, origin, axis, 2, {ImPlot3DProp_LineColor, ImVec4(0.2f, 0.2f, 0.8f, 1)});

        ImPlot3D::EndPlot();
    }
}

void Demo_LogScale() {
    IMGUI_DEMO_MARKER("Axes/Log Scale");
    static double xs[1001], ys1[1001], ys2[1001], ys3[1001], zs[1001];
    for (int i = 0; i < 1001; i++) {
        xs[i] = i * 0.1;
        ys1[i] = sin(xs[i]) + 1;
        ys2[i] = log(xs[i]);
        ys3[i] = pow(10.0, xs[i]);
        zs[i] = 0.0;
    }

    if (ImPlot3D::BeginPlot("Log Plot 3D", ImVec2(-1, 0))) {
        ImPlot3D::SetupAxisScale(ImAxis3D_X, ImPlot3DScale_Log10);
        ImPlot3D::SetupAxesLimits(0.1, 100, 0, 10, -1, 1);
        ImPlot3D::PlotLine("f(x) = x", xs, xs, zs, 1001);
        ImPlot3D::PlotLine("f(x) = sin(x)+1", xs, ys1, zs, 1001);
        ImPlot3D::PlotLine("f(x) = log(x)", xs, ys2, zs, 1001);
        ImPlot3D::PlotLine("f(x) = 10^x", xs, ys3, zs, 21);
        ImPlot3D::EndPlot();
    }
}

void Demo_SymmetricLogScale() {
    IMGUI_DEMO_MARKER("Axes/Symmetric Log Scale");
    static double xs[1001], ys1[1001], ys2[1001], zs[1001];
    for (int i = 0; i < 1001; i++) {
        xs[i] = i * 0.1f - 50;
        ys1[i] = sin(xs[i]);
        ys2[i] = i * 0.002 - 1;
        zs[i] = 0.0;
    }
    if (ImPlot3D::BeginPlot("SymLog Plot", ImVec2(-1, 0))) {
        ImPlot3D::SetupAxisScale(ImAxis3D_X, ImPlot3DScale_SymLog);
        ImPlot3D::PlotLine("f(x) = a*x+b", xs, ys2, zs, 1001);
        ImPlot3D::PlotLine("f(x) = sin(x)", xs, ys1, zs, 1001);
        ImPlot3D::EndPlot();
    }
}

void DemoTickLabels() {
    IMGUI_DEMO_MARKER("Axes/Tick Labels");
    static bool custom_fmt = true;
    static bool custom_ticks = false;
    static bool custom_labels = true;
    ImGui::Checkbox("Show Custom Format", &custom_fmt);
    ImGui::SameLine();
    ImGui::Checkbox("Show Custom Ticks", &custom_ticks);
    if (custom_ticks) {
        ImGui::SameLine();
        ImGui::Checkbox("Show Custom Labels", &custom_labels);
    }
    const double pi = 3.14;
    const char* pi_str[] = {"PI"};
    static double letters_ticks[] = {0.0, 0.2, 0.4, 0.6, 0.8, 1.0};
    static const char* letters_labels[] = {"A", "B", "C", "D", "E", "F"};
    if (ImPlot3D::BeginPlot("##Ticks")) {
        ImPlot3D::SetupAxesLimits(2, 5, 0, 1, 0, 1000);
        if (custom_fmt) {
            ImPlot3D::SetupAxisFormat(ImAxis3D_Y, MetricFormatter, (void*)"Hz");
            ImPlot3D::SetupAxisFormat(ImAxis3D_Z, MetricFormatter, (void*)"m");
        }
        if (custom_ticks) {
            ImPlot3D::SetupAxisTicks(ImAxis3D_X, &pi, 1, custom_labels ? pi_str : nullptr, true);
            ImPlot3D::SetupAxisTicks(ImAxis3D_Y, letters_ticks, 6, custom_labels ? letters_labels : nullptr, false);
            ImPlot3D::SetupAxisTicks(ImAxis3D_Z, 0, 1000, 6, custom_labels ? letters_labels : nullptr, false);
        }
        ImPlot3D::EndPlot();
    }
}

void DemoAxisConstraints() {
    IMGUI_DEMO_MARKER("Axes/Axis Constraints");
    static float limit_constraints[2] = {-10, 10};
    static float zoom_constraints[2] = {1, 20};
    static ImPlot3DAxisFlags flags;
    ImGui::DragFloat2("Limits Constraints", limit_constraints, 0.01f);
    ImGui::DragFloat2("Zoom Constraints", zoom_constraints, 0.01f);
    CHECKBOX_FLAG(flags, ImPlot3DAxisFlags_PanStretch);
    if (ImPlot3D::BeginPlot("##AxisConstraints", ImVec2(-1, 0))) {
        ImPlot3D::SetupAxes("X", "Y", "Z", flags, flags, flags);
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -1, 1);
        ImPlot3D::SetupAxisLimitsConstraints(ImAxis3D_X, (double)limit_constraints[0], (double)limit_constraints[1]);
        ImPlot3D::SetupAxisLimitsConstraints(ImAxis3D_Y, (double)limit_constraints[0], (double)limit_constraints[1]);
        ImPlot3D::SetupAxisLimitsConstraints(ImAxis3D_Z, (double)limit_constraints[0], (double)limit_constraints[1]);
        ImPlot3D::SetupAxisZoomConstraints(ImAxis3D_X, (double)zoom_constraints[0], (double)zoom_constraints[1]);
        ImPlot3D::SetupAxisZoomConstraints(ImAxis3D_Y, (double)zoom_constraints[0], (double)zoom_constraints[1]);
        ImPlot3D::SetupAxisZoomConstraints(ImAxis3D_Z, (double)zoom_constraints[0], (double)zoom_constraints[1]);
        ImPlot3D::EndPlot();
    }
}

void DemoEqualAxes() {
    IMGUI_DEMO_MARKER("Axes/Equal Axes");
    ImGui::BulletText("Equal constraint applies to all three axes (X, Y, Z)");
    ImGui::BulletText("When enabled, the axes maintain the same units/pixel ratio");

    static double circle_xs[360], circle_ys[360], circle_zs[360];
    static double helix_xs[360], helix_ys[360], helix_zs[360];
    float square_xs[] = {-0.5f, 0.5f, 0.5f, -0.5f, -0.5f};
    float square_ys[] = {-0.5f, -0.5f, 0.5f, 0.5f, -0.5f};
    float square_zs[] = {-0.5f, -0.5f, -0.5f, -0.5f, -0.5f};
    static bool initialized = false;
    if (!initialized) {
        for (int i = 0; i < 360; ++i) {
            double angle = i * 2 * IM_PI / 359.0;
            // Circle in XY plane at Z=0
            circle_xs[i] = cos(angle);
            circle_ys[i] = sin(angle);
            circle_zs[i] = 0;
            // Helix
            helix_xs[i] = 0.5 * cos(angle);
            helix_ys[i] = 0.5 * sin(angle);
            helix_zs[i] = (double)i / 359.0 * 2.0 - 1.0;
        }
        initialized = true;
    }

    static ImPlot3DFlags flags = ImPlot3DFlags_Equal;
    CHECKBOX_FLAG(flags, ImPlot3DFlags_Equal);

    if (ImPlot3D::BeginPlot("##EqualAxes", ImVec2(-1, 0), flags)) {
        ImPlot3D::SetupAxes("X-Axis", "Y-Axis", "Z-Axis");
        ImPlot3D::PlotLine("Circle", circle_xs, circle_ys, circle_zs, 360);
        ImPlot3D::PlotLine("Helix", helix_xs, helix_ys, helix_zs, 360);
        ImPlot3D::PlotLine("Square", square_xs, square_ys, square_zs, 5);
        ImPlot3D::EndPlot();
    }
}

void DemoAutoFittingData() {
    IMGUI_DEMO_MARKER("Axes/Auto-Fitting Data");
    ImGui::BulletText("Axes can be configured to auto-fit to data extents.");
    ImGui::BulletText("Try panning and zooming to see the axes adjust.");
    ImGui::BulletText("Disable AutoFit on an axis to fix its range.");

    static ImPlot3DAxisFlags xflags = ImPlot3DAxisFlags_None;
    static ImPlot3DAxisFlags yflags = ImPlot3DAxisFlags_None;
    static ImPlot3DAxisFlags zflags = ImPlot3DAxisFlags_AutoFit;

    ImGui::TextUnformatted("X: ");
    ImGui::SameLine();
    ImGui::CheckboxFlags("ImPlot3DAxisFlags_AutoFit##X", (unsigned int*)&xflags, ImPlot3DAxisFlags_AutoFit);

    ImGui::TextUnformatted("Y: ");
    ImGui::SameLine();
    ImGui::CheckboxFlags("ImPlot3DAxisFlags_AutoFit##Y", (unsigned int*)&yflags, ImPlot3DAxisFlags_AutoFit);

    ImGui::TextUnformatted("Z: ");
    ImGui::SameLine();
    ImGui::CheckboxFlags("ImPlot3DAxisFlags_AutoFit##Z", (unsigned int*)&zflags, ImPlot3DAxisFlags_AutoFit);

    static double data_x[101], data_y[101], data_z[101];
    static bool initialized = false;
    if (!initialized) {
        srand(0);
        for (int i = 0; i < 101; ++i) {
            data_x[i] = i * 0.1;
            data_y[i] = i * 0.1;
            data_z[i] = 1 + sin(i / 10.0);
        }
        initialized = true;
    }

    if (ImPlot3D::BeginPlot("##AutoFitting")) {
        ImPlot3D::SetupAxes("X-Axis", "Y-Axis", "Z-Axis", xflags, yflags, zflags);
        ImPlot3D::PlotLine("Wave", data_x, data_y, data_z, 101);
        ImPlot3D::EndPlot();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Tools
//-----------------------------------------------------------------------------

void DemoMousePicking() {
    IMGUI_DEMO_MARKER("Tools/Mouse Picking");
    static ImVector<ImPlot3DPoint> points;
    static ImVector<ImPlot3DRay> rays;

    ImGui::BulletText("Click anywhere in the plot to place points/rays.");

    static int selected_plane = ImPlane3D_XY;
    ImGui::RadioButton("XY-Plane", &selected_plane, ImPlane3D_XY);
    ImGui::SameLine();
    ImGui::RadioButton("XZ-Plane", &selected_plane, ImPlane3D_XZ);
    ImGui::SameLine();
    ImGui::RadioButton("YZ-Plane", &selected_plane, ImPlane3D_YZ);

    static bool mask_plane = true;
    ImGui::Checkbox("Mask Plane", &mask_plane);
    if (ImGui::Button("Clear")) {
        points.clear();
        rays.clear();
    }

    if (ImPlot3D::BeginPlot("Mouse Picking", ImVec2(-1, 0), ImPlot3DFlags_NoClip)) {
        ImPlot3D::SetupAxes("X-Axis", "Y-Axis", "Z-Axis");
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -1, 1);

        // Get mouse position and convert to ray
        ImVec2 mouse_pos = ImGui::GetMousePos();
        ImPlot3DRay ray = ImPlot3D::PixelsToPlotRay(mouse_pos);

        // Convert to selected plane
        ImPlane3D plane = (ImPlane3D)selected_plane;
        ImPlot3DPoint point = ImPlot3D::PixelsToPlotPlane(mouse_pos, plane, mask_plane);

        // Show intersection point
        if (ImGui::IsItemHovered() && !point.IsNaN()) {
            ImPlot3DSpec spec;
            spec.Marker = ImPlot3DMarker_Circle;
            spec.MarkerSize = 5;
            spec.FillColor = ImVec4(1, 1, 0, 1);
            ImPlot3D::PlotScatter("##Intersection", &point.x, &point.y, &point.z, 1, spec);
        }

        // Add point/ray on click
        if (ImGui::IsItemHovered() && ImGui::IsMouseClicked(0) && !point.IsNaN()) {
            points.push_back(point);
            rays.push_back(ray);
        }

        // Draw all placed points
        if (!points.empty()) {
            // Plot points
            ImPlot3DSpec spec;
            spec.Marker = ImPlot3DMarker_Circle;
            spec.MarkerSize = 3;
            spec.Stride = sizeof(ImPlot3DPoint);
            ImPlot3D::PlotScatter("Placed Points", &points[0].x, &points[0].y, &points[0].z, (int)points.Size, spec);
        }

        // Draw all placed rays
        if (!rays.empty()) {
            ImVector<ImPlot3DPoint> ray_points;
            ray_points.reserve(rays.Size * 2);
            for (int i = 0; i < rays.Size; i++) {
                ImPlot3DPoint p1 = points[i];
                ImPlot3DPoint p2 = points[i] - rays[i].Direction; // Ray from added point to the camera
                ray_points.push_back(p1);
                ray_points.push_back(p2);
            }
            ImPlot3DSpec spec;
            spec.Flags = ImPlot3DLineFlags_Segments;
            spec.Offset = 0;
            spec.Stride = sizeof(ImPlot3DPoint);
            ImPlot3D::PlotLine("Placed Rays", &ray_points[0].x, &ray_points[0].y, &ray_points[0].z, (int)rays.Size * 2, spec);
        }

        ImPlot3D::EndPlot();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Custom
//-----------------------------------------------------------------------------

void DemoCustomStyles() {
    IMGUI_DEMO_MARKER("Custom/Custom Styles");
    ImPlot3D::PushColormap(ImPlot3DColormap_Deep);
    // normally you wouldn't change the entire style each frame
    ImPlot3DStyle backup = ImPlot3D::GetStyle();
    MyImPlot3D::StyleSeaborn();
    if (ImPlot3D::BeginPlot("Seaborn Style")) {
        ImPlot3D::SetupAxes("X-axis", "Y-axis", "Z-axis");
        ImPlot3D::SetupAxesLimits(-0.5, 9.5, -0.5, 0.5, 0, 10);
        unsigned int xs[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        unsigned int ys[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        unsigned int lin[10] = {8, 8, 9, 7, 8, 8, 8, 9, 7, 8};
        unsigned int dot[10] = {7, 6, 6, 7, 8, 5, 6, 5, 8, 7};
        ImPlot3D::NextColormapColor(); // Skip blue
        ImPlot3D::PlotLine("Line", xs, ys, lin, 10);
        ImPlot3D::NextColormapColor(); // Skip green
        ImPlot3D::PlotScatter("Scatter", xs, ys, dot, 10);
        ImPlot3D::EndPlot();
    }
    ImPlot3D::GetStyle() = backup;
    ImPlot3D::PopColormap();
}

void DemoCustomRendering() {
    IMGUI_DEMO_MARKER("Custom/Custom Rendering");
    if (ImPlot3D::BeginPlot("##CustomRend")) {
        ImPlot3D::SetupAxesLimits(-0.1, 1.1, -0.1, 1.1, -0.1, 1.1);

        // Draw circle
        ImVec2 cntr = ImPlot3D::PlotToPixels(ImPlot3DPoint(0.5, 0.5, 0.5));
        ImPlot3D::GetPlotDrawList()->AddCircleFilled(cntr, 20, IM_COL32(255, 255, 0, 255), 20);

        // Draw box
        ImPlot3DPoint corners[8] = {
            ImPlot3DPoint(0, 0, 0), ImPlot3DPoint(1, 0, 0), ImPlot3DPoint(1, 1, 0), ImPlot3DPoint(0, 1, 0),
            ImPlot3DPoint(0, 0, 1), ImPlot3DPoint(1, 0, 1), ImPlot3DPoint(1, 1, 1), ImPlot3DPoint(0, 1, 1),
        };
        ImVec2 corners_px[8];
        for (int i = 0; i < 8; i++)
            corners_px[i] = ImPlot3D::PlotToPixels(corners[i]);

        ImU32 col = IM_COL32(128, 0, 255, 255);
        for (int i = 0; i < 4; i++) {
            ImPlot3D::GetPlotDrawList()->AddLine(corners_px[i], corners_px[(i + 1) % 4], col);
            ImPlot3D::GetPlotDrawList()->AddLine(corners_px[i + 4], corners_px[(i + 1) % 4 + 4], col);
            ImPlot3D::GetPlotDrawList()->AddLine(corners_px[i], corners_px[i + 4], col);
        }
        ImPlot3D::EndPlot();
    }
}

void DemoCustomOverlay() {
    IMGUI_DEMO_MARKER("Custom/Custom Overlay");
    ImGui::BulletText("Demonstrates custom 2D overlays using GetPlotRectPos/GetPlotRectSize.");
    ImGui::BulletText("Shows mouse tooltip, line to closest point, and orientation gizmo.");

    // Generate some 3D scatter data
    static float xs[50], ys[50], zs[50];
    static bool initialized = false;
    if (!initialized) {
        srand(0);
        for (int i = 0; i < 50; i++) {
            xs[i] = (float)rand() / (float)RAND_MAX;
            ys[i] = (float)rand() / (float)RAND_MAX;
            zs[i] = (float)rand() / (float)RAND_MAX;
        }
        initialized = true;
    }

    if (ImPlot3D::BeginPlot("##CustomOverlay", ImVec2(-1, 0))) {
        ImPlot3D::SetupAxes("X-Axis", "Y-Axis", "Z-Axis");
        ImPlot3D::SetupAxesLimits(0, 1, 0, 1, 0, 1);
        ImPlot3D::PlotScatter("Data", xs, ys, zs, 50);

        ImDrawList* draw_list = ImPlot3D::GetPlotDrawList();
        ImVec2 mouse_pos = ImGui::GetMousePos();
        ImVec2 plot_pos = ImPlot3D::GetPlotRectPos();
        ImVec2 plot_size = ImPlot3D::GetPlotRectSize();

        // Check if mouse is over plot
        bool is_hovered = ImGui::IsItemHovered();

        if (is_hovered) {
            // Find closest point to mouse in screen space
            int closest_idx = -1;
            float min_dist_sq = 1e10f; // Large value instead of FLT_MAX
            ImVec2 closest_px;

            for (int i = 0; i < 50; i++) {
                ImVec2 point_px = ImPlot3D::PlotToPixels(xs[i], ys[i], zs[i]);
                float dx = point_px.x - mouse_pos.x;
                float dy = point_px.y - mouse_pos.y;
                float dist_sq = dx * dx + dy * dy;
                if (dist_sq < min_dist_sq) {
                    min_dist_sq = dist_sq;
                    closest_idx = i;
                    closest_px = point_px;
                }
            }

            // Draw line to closest point
            if (closest_idx >= 0) {
                draw_list->AddLine(mouse_pos, closest_px, IM_COL32(255, 255, 0, 255), 2.0f);

                // Draw tooltip
                ImGui::BeginTooltip();
                ImGui::Text("Mouse: (%.1f, %.1f)", mouse_pos.x, mouse_pos.y);
                ImGui::Text("Closest Point #%d", closest_idx);
                ImGui::Text("Position: (%.3f, %.3f, %.3f)", xs[closest_idx], ys[closest_idx], zs[closest_idx]);
                ImGui::Text("Distance: %.1f px", ImSqrt(min_dist_sq));
                ImGui::EndTooltip();
            }
        }

        // Draw orientation gizmo in bottom-right corner
        ImPlot3DContext& gp = *GImPlot3D;
        ImPlot3DPlot* plot = gp.CurrentPlot;
        if (plot) {
            ImVec2 gizmo_center = ImVec2(plot_pos.x + plot_size.x - 50, plot_pos.y + plot_size.y - 50);
            float gizmo_size = 30.0f;

            // Get rotation quaternion
            ImPlot3DQuat rot = plot->Rotation;

            // Define axis directions in plot space
            ImPlot3DPoint axes[3] = {
                ImPlot3DPoint(1, 0, 0), // X-axis (red)
                ImPlot3DPoint(0, 1, 0), // Y-axis (green)
                ImPlot3DPoint(0, 0, 1)  // Z-axis (blue)
            };

            ImU32 colors[3] = {
                IM_COL32(200, 50, 50, 255), // Red
                IM_COL32(50, 200, 50, 255), // Green
                IM_COL32(50, 50, 200, 255)  // Blue
            };

            const char* labels[3] = {"X", "Y", "Z"};

            // Draw gizmo background circle
            draw_list->AddCircleFilled(gizmo_center, gizmo_size + 5, IM_COL32(0, 0, 0, 100));

            // Draw each axis
            for (int i = 0; i < 3; i++) {
                // Rotate axis by quaternion
                ImPlot3DPoint rotated = rot * axes[i];

                // Project to 2D gizmo space (simple orthographic projection)
                ImVec2 axis_end = ImVec2(gizmo_center.x + float(rotated.x) * gizmo_size,
                                         gizmo_center.y - float(rotated.y) * gizmo_size // Flip Y for screen coords
                );

                // Draw line
                draw_list->AddLine(gizmo_center, axis_end, colors[i], 2.0f);

                // Draw circle at end
                draw_list->AddCircleFilled(axis_end, 4.0f, colors[i]);

                // Draw label
                ImVec2 label_pos = ImVec2(axis_end.x + 8, axis_end.y - 8);
                draw_list->AddText(label_pos, colors[i], labels[i]);
            }
        }

        ImPlot3D::EndPlot();
    }
}

void DemoCustomPerPointStyle() {
    IMGUI_DEMO_MARKER("Custom/Custom Per-Point Style");
    ImGui::BulletText("Demonstrates per-point coloring using colormap sampling.");
    ImGui::BulletText("A different color is sampled for each point.");
    ImGui::BulletText("All points share the same label for a single legend entry.");

    static float marker_size = 4.0f;
    static ImPlot3DColormap cmap = ImPlot3DColormap_Viridis;

    ImGui::SliderFloat("Marker Size", &marker_size, 2.0f, 10.0f);
    if (ImGui::BeginCombo("Colormap", ImPlot3D::GetColormapName(cmap))) {
        ImPlot3DContext& gp = *GImPlot3D;
        for (int i = 0; i < ImPlot3D::GetColormapCount(); i++) {
            // Only show continuous colormaps
            if (!gp.ColormapData.IsQual(i)) {
                if (ImGui::Selectable(ImPlot3D::GetColormapName(i), cmap == i))
                    cmap = i;
            }
        }
        ImGui::EndCombo();
    }

    // Generate three stacked toruses with different color patterns
    static float torus_data[3][400][4]; // 3 toruses, 400 points each, XYZT per point
    static bool initialized = false;
    if (!initialized) {
        const float R = 0.6f; // Major radius
        const float r = 0.2f; // Minor radius
        const int u_samples = 20;
        const int v_samples = 20;

        for (int torus = 0; torus < 3; torus++) {
            float z_offset = (2 - torus) * 0.6f;
            int idx = 0;

            for (int i = 0; i < u_samples; i++) {
                float u = (float)i / u_samples * 2.0f * IM_PI;
                for (int j = 0; j < v_samples; j++) {
                    float v = (float)j / v_samples * 2.0f * IM_PI;

                    // Parametric torus equations
                    float x = (R + r * ImCos(v)) * ImCos(u);
                    float y = (R + r * ImCos(v)) * ImSin(u);
                    float z = r * ImSin(v) + z_offset;

                    // Different color pattern for each torus
                    float t;
                    if (torus == 0) {
                        // Color by height (Z coordinate)
                        // Normalize Z to [0, 1] range for this torus
                        t = (z - (z_offset - r)) / (2.0f * r);
                    } else if (torus == 1) {
                        // Color by radial distance from tube center
                        // V parameter directly gives us position around tube
                        // Map from [-r, +r] to [0, 1]
                        t = (ImCos(v) + 1.0f) / 2.0f;
                    } else {
                        // Angular pattern: varies smoothly around the major circle
                        // Creates wave-like color pattern
                        t = (ImCos(u) + 1.0f) / 2.0f; // Maps [-1, 1] to [0, 1]
                    }

                    torus_data[torus][idx][0] = x;
                    torus_data[torus][idx][1] = y;
                    torus_data[torus][idx][2] = z;
                    torus_data[torus][idx][3] = t;
                    idx++;
                }
            }
        }
        initialized = true;
    }

    if (ImPlot3D::BeginPlot("##PerPointStyle", ImVec2(-1, 0))) {
        ImPlot3D::SetupAxes("X", "Y", "Z");
        ImPlot3D::SetupAxesLimits(-1, 1, -1, 1, -0.5, 1.5);

        const char* labels[3] = {"Height-colored", "Radial-colored", "Angular-colored"};
        const ImVec4 legend_colors[3] = {
            ImVec4(1.0f, 0.0f, 0.0f, 1.0f), // Red
            ImVec4(0.0f, 1.0f, 0.0f, 1.0f), // Green
            ImVec4(0.0f, 0.0f, 1.0f, 1.0f)  // Blue
        };

        ImPlot3DSpec spec;
        spec.Marker = ImPlot3DMarker_Circle;
        spec.MarkerSize = marker_size;

        for (int torus = 0; torus < 3; torus++) {
            const int point_count = 400;
            for (int i = 0; i < point_count; i++) {
                float x = torus_data[torus][i][0];
                float y = torus_data[torus][i][1];
                float z = torus_data[torus][i][2];
                float t = torus_data[torus][i][3];

                // Sample colormap and set marker style
                ImVec4 color = ImPlot3D::SampleColormap(t, cmap);
                spec.FillColor = color;
                spec.LineColor = color;
                ImPlot3D::PlotScatter(labels[torus], &x, &y, &z, 1, spec);
            }
            // Override legend color with PlotDummy
            spec.LineColor = legend_colors[torus];
            ImPlot3D::PlotDummy(labels[torus], spec);
        }

        ImPlot3D::EndPlot();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Config
//-----------------------------------------------------------------------------

void DemoConfig() {
    IMGUI_DEMO_MARKER("Config");
    ImGui::ShowFontSelector("Font");
    ImGui::ShowStyleSelector("ImGui Style");
    ImPlot3D::ShowStyleSelector("ImPlot3D Style");
    ImPlot3D::ShowColormapSelector("ImPlot3D Colormap");
    ImGui::Separator();

    // Preview plot with 3D spirals
    if (ImPlot3D::BeginPlot("Preview", ImVec2(-1, 0))) {
        // Generate 10 spirals at different heights
        static float xs[10][50], ys[10][50], zs[10][50];
        static bool initialized = false;
        if (!initialized) {
            for (int i = 0; i < 10; ++i) {
                for (int j = 0; j < 50; ++j) {
                    float t = j / 49.0f;
                    float angle = t * 4.0f * IM_PI;
                    float radius = 0.3f + i * 0.05f;
                    xs[i][j] = radius * ImCos(angle);
                    ys[i][j] = radius * ImSin(angle);
                    zs[i][j] = i / 9.0f;
                }
            }
            initialized = true;
        }

        for (int i = 0; i < 10; ++i) {
            ImGui::PushID(i);
            ImPlot3D::PlotLine("##Spiral", xs[i], ys[i], zs[i], 50);
            ImGui::PopID();
        }

        ImPlot3D::EndPlot();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Demo Window
//-----------------------------------------------------------------------------

void DemoHelp() {
    IMGUI_DEMO_MARKER("Help");
    ImGui::SeparatorText("ABOUT THIS DEMO:");
    ImGui::BulletText("The other tabs are demonstrating many aspects of the library.");

    ImGui::SeparatorText("PROGRAMMER GUIDE:");
    ImGui::BulletText("See the ShowDemoWindow() code in implot3d_demo.cpp. <- you are here!");
    ImGui::BulletText("See comments in implot3d_demo.cpp.");
    ImGui::BulletText("See example application in example/ folder.");

    ImGui::SeparatorText("USER GUIDE:");
    ImGui::BulletText("Translation");
    {
        ImGui::Indent();
        ImGui::BulletText("Left-click drag to translate.");
        ImGui::BulletText("If over axis, only that axis will translate.");
        ImGui::BulletText("If over plane, only that plane will translate.");
        ImGui::BulletText("If outside plot area, translate in the view plane.");
        ImGui::Unindent();
    }

    ImGui::BulletText("Zoom");
    {
        ImGui::Indent();
        ImGui::BulletText("Scroll or middle-click drag to zoom.");
        ImGui::BulletText("If over axis, only that axis will zoom.");
        ImGui::BulletText("If over plane, only that plane will zoom.");
        ImGui::BulletText("If outside plot area, zoom the entire plot.");
        ImGui::Unindent();
    }

    ImGui::BulletText("Rotation");
    {
        ImGui::Indent();
        ImGui::BulletText("Right-click drag to rotate.");
        ImGui::BulletText("To reset rotation, double right-click outside plot area.");
        ImGui::BulletText("To rotate to plane, double right-click when over the plane.");
        ImGui::Unindent();
    }

    ImGui::BulletText("Fit data");
    {
        ImGui::Indent();
        ImGui::BulletText("Double left-click to fit.");
        ImGui::BulletText("If over axis, fit data to axis.");
        ImGui::BulletText("If over plane, fit data to plane.");
        ImGui::BulletText("If outside plot area, fit data to plot.");
        ImGui::Unindent();
    }

    ImGui::BulletText("Context Menus");
    {
        ImGui::Indent();
        ImGui::BulletText("Right-click outside plot area to show full context menu.");
        ImGui::BulletText("Right-click over legend to show legend context menu.");
        ImGui::BulletText("Right-click over axis to show axis context menu.");
        ImGui::BulletText("Right-click over plane to show plane context menu.");
        ImGui::Unindent();
    }

    ImGui::BulletText("Click legend label icons to show/hide plot items.");
}

void DemoHeader(const char* label, void (*demo)()) {
    if (ImGui::TreeNodeEx(label)) {
        demo();
        ImGui::TreePop();
    }
}

void ShowAllDemos() {
    ImGui::Text("ImPlot3D says ol! (%s) (%d)", IMPLOT3D_VERSION, IMPLOT3D_VERSION_NUM);
    ImGui::Spacing();
    if (ImGui::BeginTabBar("ImPlot3DDemoTabs")) {
        if (ImGui::BeginTabItem("Plots")) {
            // Plot Types
            ImGui::SeparatorText("Plot Types");
            DemoHeader("Line Plots", DemoLinePlots);
            DemoHeader("Scatter Plots", DemoScatterPlots);
            DemoHeader("Triangle Plots", DemoTrianglePlots);
            DemoHeader("Quad Plots", DemoQuadPlots);
            DemoHeader("Surface Plots", DemoSurfacePlots);
            DemoHeader("Mesh Plots", DemoMeshPlots);
            DemoHeader("Realtime Plots", DemoRealtimePlots);
            DemoHeader("Image Plots", DemoImagePlots);

            // Plot Options
            ImGui::SeparatorText("Plot Options");
            DemoHeader("Plot Flags", DemoPlotFlags);
            DemoHeader("Offset and Stride", DemoOffsetAndStride);
            DemoHeader("Legend Options", DemoLegendOptions);
            DemoHeader("Markers and Text", DemoMarkersAndText);
            DemoHeader("NaN Values", DemoNaNValues);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Axes")) {
            DemoHeader("Box Scale", DemoBoxScale);
            DemoHeader("Box Rotation", DemoBoxRotation);
            DemoHeader("Log Scale", Demo_LogScale);
            DemoHeader("Symmetric Log Scale", Demo_SymmetricLogScale);
            DemoHeader("Tick Labels", DemoTickLabels);
            DemoHeader("Axis Constraints", DemoAxisConstraints);
            DemoHeader("Equal Axes", DemoEqualAxes);
            DemoHeader("Auto-Fitting Data", DemoAutoFittingData);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Tools")) {
            DemoHeader("Mouse Picking", DemoMousePicking);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Custom")) {
            DemoHeader("Custom Styles", DemoCustomStyles);
            DemoHeader("Custom Rendering", DemoCustomRendering);
            DemoHeader("Custom Overlay", DemoCustomOverlay);
            DemoHeader("Custom Per-Point Style", DemoCustomPerPointStyle);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Config")) {
            DemoConfig();
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Help")) {
            DemoHelp();
            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }

    IMGUI_DEMO_MARKER("end");
}

void ShowDemoWindow(bool* p_open)
{
        ShowDemoWindow_MaybeDocked(true, p_open);
}

void  ShowDemoWindow_MaybeDocked(bool create_window, bool* p_open)
{
    static bool show_implot3d_metrics = false;
    static bool show_implot3d_style_editor = false;
    static bool show_implot3d_about = false;
    static bool show_imgui_metrics = false;
    static bool show_imgui_style_editor = false;
    static bool show_imgui_demo = false;

    if (show_implot3d_metrics)
        ImPlot3D::ShowMetricsWindow(&show_implot3d_metrics);
    if (show_implot3d_style_editor) {
        ImGui::Begin("Style Editor (ImPlot3D)", &show_implot3d_style_editor);
        ImPlot3D::ShowStyleEditor();
        ImGui::End();
    }
    if (show_implot3d_about)
        ImPlot3D::ShowAboutWindow(&show_implot3d_about);
    if (show_imgui_style_editor) {
        ImGui::Begin("Style Editor (ImGui)", &show_imgui_style_editor);
        ImGui::ShowStyleEditor();
        ImGui::End();
    }
    if (show_imgui_metrics)
        ImGui::ShowMetricsWindow(&show_imgui_metrics);
    if (show_imgui_demo)
        ImGui::ShowDemoWindow(&show_imgui_demo);

    if (create_window)
    {
        ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowSize(ImVec2(600, 750), ImGuiCond_FirstUseEver);
        ImGui::Begin("ImPlot3D Demo", p_open, ImGuiWindowFlags_MenuBar);
    }
    if (ImGui::BeginMenuBar()) {
        if (ImGui::BeginMenu("Tools")) {
            ImGui::MenuItem("Metrics", nullptr, &show_implot3d_metrics);
            ImGui::MenuItem("Style Editor", nullptr, &show_implot3d_style_editor);
            ImGui::MenuItem("About ImPlot3D", nullptr, &show_implot3d_about);
            ImGui::Separator();
            ImGui::MenuItem("ImGui Metrics", nullptr, &show_imgui_metrics);
            ImGui::MenuItem("ImGui Style Editor", nullptr, &show_imgui_style_editor);
            ImGui::MenuItem("ImGui Demo", nullptr, &show_imgui_demo);
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }
    ShowAllDemos();

    if (create_window)
        ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Style Editor
//-----------------------------------------------------------------------------

bool ColormapButton(const char* label, const ImVec2& size_arg, ImPlot3DColormap cmap) {
    ImGuiContext& G = *GImGui;
    const ImGuiStyle& style = G.Style;
    ImGuiWindow* Window = G.CurrentWindow;
    if (Window->SkipItems)
        return false;
    ImPlot3DContext& gp = *GImPlot3D;
    cmap = cmap == IMPLOT3D_AUTO ? gp.Style.Colormap : cmap;
    IM_ASSERT_USER_ERROR(cmap >= 0 && cmap < gp.ColormapData.Count, "Invalid colormap index!");
    const ImU32* keys = gp.ColormapData.GetKeys(cmap);
    const int count = gp.ColormapData.GetKeyCount(cmap);
    const bool qual = gp.ColormapData.IsQual(cmap);
    const ImVec2 pos = ImGui::GetCurrentWindow()->DC.CursorPos;
    const ImVec2 label_size = ImGui::CalcTextSize(label, nullptr, true);
    ImVec2 size = ImGui::CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);
    const ImRect rect = ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y);
    RenderColorBar(keys, count, *ImGui::GetWindowDrawList(), rect, false, false, !qual);
    const ImU32 text = CalcTextColor(gp.ColormapData.LerpTable(cmap, G.Style.ButtonTextAlign.x));
    ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32_BLACK_TRANS);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(1, 1, 1, 0.1f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(1, 1, 1, 0.2f));
    ImGui::PushStyleColor(ImGuiCol_Text, text);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0);
    const bool pressed = ImGui::Button(label, size);
    ImGui::PopStyleColor(4);
    ImGui::PopStyleVar(1);
    return pressed;
}

void ShowStyleEditor(ImPlot3DStyle* ref) {
    ImPlot3DContext& gp = *GImPlot3D;

    // Handle style internal storage
    ImPlot3DStyle& style = GetStyle();
    static ImPlot3DStyle ref_saved_style;
    static bool init = true;
    if (init && ref == nullptr)
        ref_saved_style = style;
    init = false;
    if (ref == nullptr)
        ref = &ref_saved_style;

    // Handle flash style color
    static float flash_color_time = 0.5f;
    static ImPlot3DCol flash_color_idx = ImPlot3DCol_COUNT;
    static ImVec4 flash_color_backup = ImVec4(0, 0, 0, 0);
    if (flash_color_idx != ImPlot3DCol_COUNT) {
        // Flash color
        ImVec4& color = style.Colors[flash_color_idx];
        ImGui::ColorConvertHSVtoRGB(ImCos(flash_color_time * 6.0f) * 0.5f + 0.5f, 0.5f, 0.5f, color.x, color.y, color.z);
        color.w = 1.0f;

        // Decrease timer until zero
        if ((flash_color_time -= ImGui::GetIO().DeltaTime) <= 0.0f) {
            // When timer reaches zero, restore the backup color
            style.Colors[flash_color_idx] = flash_color_backup;
            flash_color_idx = ImPlot3DCol_COUNT;
            flash_color_time = 0.5f;
        }
    }

    // Style selector
    if (ImPlot3D::ShowStyleSelector("Colors##Selector"))
        ref_saved_style = style;

    // Save/Revert button
    if (ImGui::Button("Save Ref"))
        *ref = ref_saved_style = style;
    ImGui::SameLine();
    if (ImGui::Button("Revert Ref"))
        style = *ref;
    ImGui::SameLine();
    HelpMarker("Save/Revert in local non-persistent storage. Default Colors definition are not affected. "
               "Use \"Export\" below to save them somewhere.");

    ImGui::Separator();

    if (ImGui::BeginTabBar("##Tabs", ImGuiTabBarFlags_None)) {
        if (ImGui::BeginTabItem("Variables")) {
            ImGui::Text("Item Styling");
            ImGui::SliderFloat("LineWeight", &style.LineWeight, 0.0f, 5.0f, "%.1f");
            ImGui::SliderFloat("MarkerSize", &style.MarkerSize, 2.0f, 10.0f, "%.1f");
            ImGui::SliderFloat("FillAlpha", &style.FillAlpha, 0.0f, 1.0f, "%.2f");
            ImGui::Text("Plot Styling");
            ImGui::SliderFloat2("PlotDefaultSize", (float*)&style.PlotDefaultSize, 0.0f, 1000, "%.0f");
            ImGui::SliderFloat2("PlotMinSize", (float*)&style.PlotMinSize, 0.0f, 300, "%.0f");
            ImGui::SliderFloat2("PlotPadding", (float*)&style.PlotPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("LabelPadding", (float*)&style.LabelPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat("ViewScaleFactor", (float*)&style.ViewScaleFactor, 0.1f, 2.0f, "%.2f");
            ImGui::Text("Legend Styling");
            ImGui::SliderFloat2("LegendPadding", (float*)&style.LegendPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("LegendInnerPadding", (float*)&style.LegendInnerPadding, 0.0f, 10.0f, "%.0f");
            ImGui::SliderFloat2("LegendSpacing", (float*)&style.LegendSpacing, 0.0f, 5.0f, "%.0f");
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Colors")) {
            static int output_dest = 0;
            static bool output_only_modified = true;
            if (ImGui::Button("Export")) {
                if (output_dest == 0)
                    ImGui::LogToClipboard();
                else
                    ImGui::LogToTTY();
                ImGui::LogText("ImVec4* colors = ImPlot3D::GetStyle().Colors;\n");
                for (int i = 0; i < ImPlot3DCol_COUNT; i++) {
                    const ImVec4& col = style.Colors[i];
                    const char* name = ImPlot3D::GetStyleColorName(i);
                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)
                        ImGui::LogText("colors[ImPlot3DCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);\n", name, 15 - (int)strlen(name), "", col.x,
                                       col.y, col.z, col.w);
                }
                ImGui::LogFinish();
            }
            ImGui::SameLine();
            ImGui::SetNextItemWidth(120);
            ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");
            ImGui::SameLine();
            ImGui::Checkbox("Only Modified Colors", &output_only_modified);

            static ImGuiTextFilter filter;
            filter.Draw("Filter colors", ImGui::GetFontSize() * 16);

            static ImGuiColorEditFlags alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf;
#if IMGUI_VERSION_NUM < 19173
            if (ImGui::RadioButton("Opaque", alpha_flags == ImGuiColorEditFlags_None))
                alpha_flags = ImGuiColorEditFlags_None;
            ImGui::SameLine();
            if (ImGui::RadioButton("Alpha", alpha_flags == ImGuiColorEditFlags_AlphaPreview))
                alpha_flags = ImGuiColorEditFlags_AlphaPreview;
            ImGui::SameLine();
            if (ImGui::RadioButton("Both", alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf))
                alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf;
            ImGui::SameLine();
#else
            if (ImGui::RadioButton("Opaque", alpha_flags == ImGuiColorEditFlags_AlphaOpaque))
                alpha_flags = ImGuiColorEditFlags_AlphaOpaque;
            ImGui::SameLine();
            if (ImGui::RadioButton("Alpha", alpha_flags == ImGuiColorEditFlags_None))
                alpha_flags = ImGuiColorEditFlags_None;
            ImGui::SameLine();
            if (ImGui::RadioButton("Both", alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf))
                alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf;
            ImGui::SameLine();
#endif
            HelpMarker("In the color list:\n"
                       "Left-click on color square to open color picker,\n"
                       "Right-click to open edit options menu.");

            ImGui::Separator();

            for (int i = 0; i < ImPlot3DCol_COUNT; i++) {
                const char* name = ImPlot3D::GetStyleColorName(i);
                if (!filter.PassFilter(name))
                    continue;
                ImGui::PushID(i);

                // Flash color
                if (ImGui::Button("?")) {
                    if (flash_color_idx != ImPlot3DCol_COUNT)
                        style.Colors[flash_color_idx] = flash_color_backup;
                    flash_color_time = 0.5f;
                    flash_color_idx = (ImPlot3DCol)i;
                    flash_color_backup = style.Colors[i];
                }
                ImGui::SetItemTooltip("Flash given color to identify places where it is used.");
                ImGui::SameLine();

                // Handle auto color selection
                const bool is_auto = IsColorAuto(style.Colors[i]);
                if (is_auto)
                    ImGui::BeginDisabled();
                if (ImGui::Button("Auto"))
                    style.Colors[i] = IMPLOT3D_AUTO_COL;
                if (is_auto)
                    ImGui::EndDisabled();

                // Color selection
                ImGui::SameLine();
                if (ImGui::ColorEdit4("##Color", (float*)&style.Colors[i], ImGuiColorEditFlags_NoInputs | alpha_flags)) {
                    if (style.Colors[i].w == -1)
                        style.Colors[i].w = 1;
                }

                // Save/Revert buttons if color changed
                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0) {
                    ImGui::SameLine();
                    if (ImGui::Button("Save"))
                        ref->Colors[i] = style.Colors[i];
                    ImGui::SameLine();
                    if (ImGui::Button("Revert"))
                        style.Colors[i] = ref->Colors[i];
                }
                ImGui::SameLine();
                ImGui::TextUnformatted(name);
                ImGui::PopID();
            }
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Colormaps")) {
            static int output_dest = 0;
            if (ImGui::Button("Export", ImVec2(75, 0))) {
                if (output_dest == 0)
                    ImGui::LogToClipboard();
                else
                    ImGui::LogToTTY();
                int size = GetColormapSize();
                const char* name = GetColormapName(gp.Style.Colormap);
                ImGui::LogText("static const ImU32 %s_Data[%d] = {\n", name, size);
                for (int i = 0; i < size; i++) {
                    ImU32 col = GetColormapColorU32(i, gp.Style.Colormap);
                    ImGui::LogText("    %u%s\n", col, i == size - 1 ? "" : ",");
                }
                ImGui::LogText("};\nImPlotColormap %s = ImPlot::AddColormap(\"%s\", %s_Data, %d);", name, name, name, size);
                ImGui::LogFinish();
            }
            ImGui::SameLine();
            ImGui::SetNextItemWidth(120);
            ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");
            ImGui::SameLine();
            static bool edit = false;
            ImGui::Checkbox("Edit Mode", &edit);

            // built-in/added
            ImGui::Separator();
            for (int i = 0; i < gp.ColormapData.Count; i++) {
                ImGui::PushID(i);
                int size = gp.ColormapData.GetKeyCount(i);
                bool selected = i == gp.Style.Colormap;

                const char* name = GetColormapName(i);
                if (!selected)
                    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.25f);
                if (ImGui::Button(name, ImVec2(100, 0))) {
                    gp.Style.Colormap = i;
                    BustItemCache();
                }
                if (!selected)
                    ImGui::PopStyleVar();
                ImGui::SameLine();
                ImGui::BeginGroup();
                if (edit) {
                    for (int c = 0; c < size; ++c) {
                        ImGui::PushID(c);
                        ImVec4 col4 = ImGui::ColorConvertU32ToFloat4(gp.ColormapData.GetKeyColor(i, c));
                        if (ImGui::ColorEdit4("", &col4.x, ImGuiColorEditFlags_NoInputs)) {
                            ImU32 col32 = ImGui::ColorConvertFloat4ToU32(col4);
                            gp.ColormapData.SetKeyColor(i, c, col32);
                            BustItemCache();
                        }
                        if ((c + 1) % 12 != 0 && c != size - 1)
                            ImGui::SameLine();
                        ImGui::PopID();
                    }
                } else {
                    if (ColormapButton("##", ImVec2(-1, 0), i))
                        edit = true;
                }
                ImGui::EndGroup();
                ImGui::PopID();
            }

            static ImVector<ImVec4> custom;
            if (custom.Size == 0) {
                custom.push_back(ImVec4(1, 0, 0, 1));
                custom.push_back(ImVec4(0, 1, 0, 1));
                custom.push_back(ImVec4(0, 0, 1, 1));
            }
            ImGui::Separator();
            ImGui::BeginGroup();
            static char name[16] = "MyColormap";

            if (ImGui::Button("+", ImVec2((100 - ImGui::GetStyle().ItemSpacing.x) / 2, 0)))
                custom.push_back(ImVec4(0, 0, 0, 1));
            ImGui::SameLine();
            if (ImGui::Button("-", ImVec2((100 - ImGui::GetStyle().ItemSpacing.x) / 2, 0)) && custom.Size > 2)
                custom.pop_back();
            ImGui::SetNextItemWidth(100);
            ImGui::InputText("##Name", name, 16, ImGuiInputTextFlags_CharsNoBlank);
            static bool qual = true;
            ImGui::Checkbox("Qualitative", &qual);
            if (ImGui::Button("Add", ImVec2(100, 0)) && gp.ColormapData.GetIndex(name) == -1)
                AddColormap(name, custom.Data, custom.Size, qual);

            ImGui::EndGroup();
            ImGui::SameLine();
            ImGui::BeginGroup();
            for (int c = 0; c < custom.Size; ++c) {
                ImGui::PushID(c);
                if (ImGui::ColorEdit4("##Col1", &custom[c].x, ImGuiColorEditFlags_NoInputs)) {
                }
                if ((c + 1) % 12 != 0)
                    ImGui::SameLine();
                ImGui::PopID();
            }
            ImGui::EndGroup();

            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }
}

void ShowAboutWindow(bool* p_open) {
    if (!ImGui::Begin("About ImPlot3D", p_open, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::End();
        return;
    }

    ImGui::Text("ImPlot3D %s (%d)", IMPLOT3D_VERSION, IMPLOT3D_VERSION_NUM);

    ImGui::TextLinkOpenURL("Homepage", "https://github.com/brenocq/implot3d");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("Q&A", "https://github.com/brenocq/implot3d/discussions/categories/q-a");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("Releases", "https://github.com/brenocq/implot3d/releases");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("Sponsors", "https://github.com/sponsors/brenocq");

    ImGui::Separator();
    ImGui::Text("(c) 2024-2025 Breno Cunha Queiroz");
    ImGui::Text("Developed by Breno Cunha Queiroz and all ImPlot3D contributors.");
    ImGui::Text("ImPlot3D is licensed under the MIT License.");
    ImGui::Text("If your company uses ImPlot3D, please consider sponsoring the project.");

    static bool show_config_info = false;
    ImGui::Checkbox("Config/Build Information", &show_config_info);
    if (show_config_info) {
        bool copy_to_clipboard = ImGui::Button("Copy to clipboard");
        ImVec2 child_size = ImVec2(0, ImGui::GetTextLineHeightWithSpacing() * 18);
        ImGui::BeginChild(ImGui::GetID("cfg_infos"), child_size, ImGuiChildFlags_FrameStyle);
        if (copy_to_clipboard) {
            ImGui::LogToClipboard();
            ImGui::LogText("```cpp\n");
        }

        ImGui::Text("ImPlot3D %s (%d)", IMPLOT3D_VERSION, IMPLOT3D_VERSION_NUM);
        ImGui::Separator();
        ImGui::Text("sizeof(size_t): %d, sizeof(ImPlot3DPoint): %d", (int)sizeof(size_t), (int)sizeof(ImPlot3DPoint));

#ifdef IMPLOT3D_DISABLE_OBSOLETE_FUNCTIONS
        ImGui::Text("define: IMPLOT3D_DISABLE_OBSOLETE_FUNCTIONS");
#endif

        ImGui::Text("define: __cplusplus=%d", (int)__cplusplus);
#ifdef _WIN32
        ImGui::Text("define: _WIN32");
#endif
#ifdef _WIN64
        ImGui::Text("define: _WIN64");
#endif
#ifdef __linux__
        ImGui::Text("define: __linux__");
#endif
#ifdef __APPLE__
        ImGui::Text("define: __APPLE__");
#endif
#ifdef _MSC_VER
        ImGui::Text("define: _MSC_VER=%d", _MSC_VER);
#endif
#ifdef __MINGW32__
        ImGui::Text("define: __MINGW32__");
#endif
#ifdef __MINGW64__
        ImGui::Text("define: __MINGW64__");
#endif
#ifdef __GNUC__
        ImGui::Text("define: __GNUC__=%d", (int)__GNUC__);
#endif
#ifdef __clang_version__
        ImGui::Text("define: __clang_version__=%s", __clang_version__);
#endif

        if (copy_to_clipboard) {
            ImGui::LogText("```\n");
            ImGui::LogFinish();
        }
        ImGui::EndChild();
    }

    ImGui::End();
}

} // namespace ImPlot3D

//-----------------------------------------------------------------------------
// [SECTION] User Namespace Implementation
//-----------------------------------------------------------------------------

namespace MyImPlot3D {

void StyleSeaborn() {

    ImPlot3DStyle& style = ImPlot3D::GetStyle();

    ImVec4* colors = style.Colors;
    colors[ImPlot3DCol_FrameBg] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImPlot3DCol_PlotBg] = ImVec4(0.92f, 0.92f, 0.95f, 1.00f);
    colors[ImPlot3DCol_PlotBorder] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImPlot3DCol_LegendBg] = ImVec4(0.92f, 0.92f, 0.95f, 1.00f);
    colors[ImPlot3DCol_LegendBorder] = ImVec4(0.80f, 0.81f, 0.85f, 1.00f);
    colors[ImPlot3DCol_LegendText] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlot3DCol_TitleText] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlot3DCol_InlayText] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlot3DCol_AxisText] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImPlot3DCol_AxisGrid] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

    style.LineWeight = 1.5;
    style.Marker = ImPlot3DMarker_None;
    style.MarkerSize = 4;
    style.FillAlpha = 1.0f;
    style.PlotPadding = ImVec2(12, 12);
    style.LabelPadding = ImVec2(5, 5);
    style.LegendPadding = ImVec2(5, 5);
    style.PlotMinSize = ImVec2(300, 225);
}

} // namespace MyImPlot3D
