"""Hello, Dear ImGui: cross-platform Gui apps for Windows / Mac / Linux / iOS / Android / Emscripten with the simplicity of a "Hello World" app
https://github.com/pthom/hello_imgui
"""
# ruff: noqa: F811, B008
from typing import List, Any, Callable, Tuple, Optional, overload
import numpy as np
import enum

from imgui_bundle import hello_imgui as HelloImGui
from imgui_bundle.imgui.internal import DockNodeFlags_, DockNodeFlags
from imgui_bundle.imgui import (
    ImVec2,
    ImVec4,
    ImFontConfig,
    ImFont,
    ImTextureID,
    Dir_,
    Cond_,
)

from imgui_bundle.imgui import test_engine

# Manual code
import imgui_bundle.imgui

ImGuiID = int
ImGuiDefaultSettings = imgui_default_settings  # noqa: F821

ImGuiDockNodeFlags_ = DockNodeFlags_
ImGuiDockNodeFlags = DockNodeFlags

DockSpaceName = str
ImGuiTestEngine = test_engine.TestEngine

VoidFunction = Callable[[], None]
AnyEventCallback = Callable[[Any], None]
ScreenSize = Tuple[int, int]
ScreenPosition = Tuple[int, int]
ImGuiCond_FirstUseEver = Cond_.first_use_ever
ImGuiDockNodeFlags_None = DockNodeFlags_.none
ImGuiDockNodeFlags_PassthruCentralNode = DockNodeFlags_.passthru_central_node

DefaultScreenSize = (800, 600)
DefaultWindowSize = (800, 600)
DefaultScreenPosition = (40, 40)

ImGuiCond = imgui_bundle.imgui.Cond
ImGuiDir_Down = Dir_.down
ImGuiTheme = imgui_bundle.hello_imgui
ImGuiStyle = imgui_bundle.imgui.Style
ImGuiDir_ = imgui_bundle.imgui.Dir_
ImGuiWindowFlags = imgui_bundle.imgui.WindowFlags

# ImWcharPair is used to defined unicode glyph ranges
ImWcharPair = Tuple[int, int]

def EmptyVoidFunction() -> VoidFunction:
    pass

def EmptyEventCallback() -> AnyEventCallback:
    pass

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:hello_imgui_amalgamation.h>    ####################
# THIS FILE WAS GENERATED AUTOMATICALLY. DO NOT EDIT.

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui.h                                                                          //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# *
# @@md#DocEmToVec2
#
# Special care must be taken in order to correctly handle screen with high DPI
# (for example, almost all recent laptops screens).
#
# Using ImVec2 with fixed values is *almost always a bad idea* if you intend your
# application to be used on high DPI screens!
# Otherwise, widgets might be misplaced or too small on different screens and/or OS.
#
# Instead you should use scale your widgets and windows relatively to the font size,
# as is done with the [em CSS Unit](https://lyty.dev/css/css-unit.html).
#
# @@md
# *

# @@md#EmToVec2
#  __HelloImGui::EmToVec2()__ returns an ImVec2 that you can use to size
#  or place your widgets in a DPI independent way.
#  Values are in multiples of the font size (i.e. as in the em CSS unit).
# ImVec2 EmToVec2(float x, float y);    /* original C++ signature */
@overload
def em_to_vec2(x: float, y: float) -> ImVec2:
    pass

# ImVec2 EmToVec2(ImVec2 v);    /* original C++ signature */
@overload
def em_to_vec2(v: ImVec2) -> ImVec2:
    pass

# float EmSize();    /* original C++ signature */
@overload
def em_size() -> float:
    """__HelloImGui::EmSize()__ returns the visible font size on the screen."""
    pass

# float EmSize(float nbLines);    /* original C++ signature */
@overload
def em_size(nb_lines: float) -> float:
    """__HelloImGui::EmSize(nbLines)__ returns a size corresponding to nbLines text lines"""
    pass

# @@md

# float DpiFontLoadingFactor();    /* original C++ signature */
def dpi_font_loading_factor() -> float:
    """Multiply font sizes by this factor when loading fonts manually with ImGui::GetIO().Fonts->AddFont...
    (HelloImGui::LoadFontTTF does this by default)
    """
    pass

# float DpiWindowSizeFactor();    /* original C++ signature */
def dpi_window_size_factor() -> float:
    """DpiWindowSizeFactor() is the factor by which window size should be multiplied to get a similar visible size on different OSes.
    It returns ApplicationScreenPixelPerInch / 96  under windows and linux. Under macOS, it will return 1.
    """
    pass

# float ImGuiDefaultFontGlobalScale();    /* original C++ signature */
# }
def imgui_default_font_global_scale() -> float:
    """returns the default value that should be stored inside `ImGui::GetIO().FontGlobalScale`"""
    pass

# namespace HelloImGui

# *
# @@md#AssetsStructure
#
# Assets located beside the application CMakeLists are embedded automatically.
#
# For example, you can have the following project structure:
# ```
# my_app/
# ├── CMakeLists.txt        # Your app's CMakeLists
# ├── assets/               # Its assets: for mobile devices and emscripten
# │         └── fonts/            # they are embedded automatically by hello_imgui_add_app.cmake
# │             └── my_font.ttf
# ├── my_app.main.cpp       # Its source code
# ```
#
# Then you can load the asset "fonts/my_font.ttf", on all platforms.
#
# @@md
#

# @@md#LoadAssetFileData

class AssetFileData:
    # void * data = nullptr;    /* original C++ signature */
    data: Any = None
    # size_t dataSize = 0;    /* original C++ signature */
    data_size: int = 0
    # AssetFileData(size_t dataSize = 0);    /* original C++ signature */
    def __init__(self, data_size: int = 0) -> None:
        """Auto-generated default constructor with named params"""
        pass

# AssetFileData LoadAssetFileData(const char *assetPath);    /* original C++ signature */
def load_asset_file_data(asset_path: str) -> AssetFileData:
    """LoadAssetFileData(const char *assetPath)`
    Will load an entire asset file into memory. This works on all platforms,
    including android.
    You *have* to call FreeAssetFileData to free the memory, except if you use
    ImGui::GetIO().Fonts->AddFontFromMemoryTTF, which will take ownership of the
    data and free it for you.
    """
    pass

# void FreeAssetFileData(AssetFileData * assetFileData);    /* original C++ signature */
def free_asset_file_data(asset_file_data: AssetFileData) -> None:
    """FreeAssetFileData(AssetFileData *)
    Will free the memory.
    Note: "ImGui::GetIO().Fonts->AddFontFromMemoryTTF" takes ownership of the data
    and will free the memory for you.
    """
    pass

# @@md

# @@md#assetFileFullPath

# std::string AssetFileFullPath(const std::string& assetRelativeFilename,    /* original C++ signature */
#                               bool assertIfNotFound = true);
def asset_file_full_path(
    asset_relative_filename: str, assert_if_not_found: bool = True
) -> str:
    """`std::string AssetFileFullPath(const std::string& assetRelativeFilename)`
    will return the path to assets.

    This works under all platforms *except Android*
    For compatibility with Android and other platforms, prefer to use `LoadAssetFileData`
    whenever possible.
       * Under iOS it will give a path in the app bundle (/private/XXX/....)
       * Under emscripten, it will be stored in the virtual filesystem at "/"
       * Under Android, assetFileFullPath is *not* implemented, and will throw an error:
         assets can be compressed under android, and you can't use standard file operations!
         Use LoadAssetFileData instead
    """
    pass

# bool AssetExists(const std::string& assetRelativeFilename);    /* original C++ signature */
def asset_exists(asset_relative_filename: str) -> bool:
    """Returns True if this asset file exists"""
    pass

# void SetAssetsFolder(const std::string& folder);    /* original C++ signature */
@overload
def set_assets_folder(folder: str) -> None:
    """Sets the assets folder location
    (when using this, automatic assets installation on mobile platforms may not work)
    """
    pass

# @@md

# void SetAssetsFolder(const char* folder);    /* original C++ signature */
@overload
def set_assets_folder(folder: str) -> None:
    """Legacy API, kept for compatibility"""
    pass

# inline std::string assetFileFullPath(const std::string& assetRelativeFilename, bool assertIfNotFound = true)    /* original C++ signature */
#     { return AssetFileFullPath(assetRelativeFilename, assertIfNotFound); }
def asset_file_full_path(
    asset_relative_filename: str, assert_if_not_found: bool = True
) -> str:
    pass

# void overrideAssetsFolder(const char* folder);     /* original C++ signature */
def override_assets_folder(folder: str) -> None:
    """synonym of SetAssetsFolder"""
    pass

# namespace HelloImGui

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_error.h included by hello_imgui.h                              //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_logger.h included by hello_imgui.h                             //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////
class LogLevel(enum.Enum):
    # Debug,    /* original C++ signature */
    debug = enum.auto()  # (= 0)
    # Info,    /* original C++ signature */
    info = enum.auto()  # (= 1)
    # Warning,    /* original C++ signature */
    warning = enum.auto()  # (= 2)
    # Error    /* original C++ signature */
    #     }
    error = enum.auto()  # (= 3)

# void Log(LogLevel level, char const* const format, ...);    /* original C++ signature */
def log(level: LogLevel, format: str) -> None:
    pass

# void LogClear();    /* original C++ signature */
def log_clear() -> None:
    pass

# void LogGui(ImVec2 size=ImVec2(0.f, 0.f));    /* original C++ signature */
# }
def log_gui(size: ImVec2 = ImVec2(0.0, 0.0)) -> None:
    pass

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/icons_font_awesome.h included by hello_imgui.h                             //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Generated by https://github.com/juliettef/IconFontCppHeaders script
# GenerateIconFontCppHeaders.py for language C89 from
# https://raw.githubusercontent.com/FortAwesome/Font-Awesome/master/metadata/icons.yml
# for use with
# https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-solid-900.ttf,
# https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-regular-400.ttf,

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/image_from_asset.h included by hello_imgui.h                               //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# @@md#HelloImGui::ImageFromAsset

#
# Images are loaded when first displayed, and then cached
# (they will be freed just before the application exits).
#
# For example, given this files structure:
# ```
# ├── CMakeLists.txt
# ├── assets/
# │         └── my_image.jpg
# └── my_app.main.cpp
# ```
#
# then, you can display "my_image.jpg", using:
#
#    ```cpp
#    HelloImGui::ImageFromAsset("my_image.jpg");
#    ```

# void ImageFromAsset(const char *assetPath, const ImVec2& size = ImVec2(0, 0),    /* original C++ signature */
#                     const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1,1),
#                     const ImVec4& tint_col = ImVec4(1,1,1,1),
#                     const ImVec4& border_col = ImVec4(0,0,0,0));
def image_from_asset(
    asset_path: str,
    size: ImVec2 = ImVec2(0, 0),
    uv0: ImVec2 = ImVec2(0, 0),
    uv1: ImVec2 = ImVec2(1, 1),
    tint_col: ImVec4 = ImVec4(1, 1, 1, 1),
    border_col: ImVec4 = ImVec4(0, 0, 0, 0),
) -> None:
    """`HelloImGui::ImageFromAsset(const char *assetPath, size, ...)`:
    will display a static image from the assets.
    """
    pass

# bool ImageButtonFromAsset(const char *assetPath, const ImVec2& size = ImVec2(0, 0),    /* original C++ signature */
#                           const ImVec2& uv0 = ImVec2(0, 0),  const ImVec2& uv1 = ImVec2(1,1),
#                           int frame_padding = -1,
#                           const ImVec4& bg_col = ImVec4(0,0,0,0),
#                           const ImVec4& tint_col = ImVec4(1,1,1,1));
def image_button_from_asset(
    asset_path: str,
    size: ImVec2 = ImVec2(0, 0),
    uv0: ImVec2 = ImVec2(0, 0),
    uv1: ImVec2 = ImVec2(1, 1),
    frame_padding: int = -1,
    bg_col: ImVec4 = ImVec4(0, 0, 0, 0),
    tint_col: ImVec4 = ImVec4(1, 1, 1, 1),
) -> bool:
    """`bool HelloImGui::ImageButtonFromAsset(const char *assetPath, size, ...)`:
    will display a button using an image from the assets.
    """
    pass

# ImTextureID ImTextureIdFromAsset(const char *assetPath);    /* original C++ signature */
def im_texture_id_from_asset(asset_path: str) -> ImTextureID:
    """`ImTextureID HelloImGui::ImTextureIdFromAsset(assetPath)`:
    will return a texture ID for an image loaded from the assets.
    """
    pass

# ImVec2 ImageSizeFromAsset(const char *assetPath);    /* original C++ signature */
def image_size_from_asset(asset_path: str) -> ImVec2:
    """`ImVec2 HelloImGui::ImageSizeFromAsset(assetPath)`:
    will return the size of an image loaded from the assets.
    """
    pass

# ImVec2 ImageProportionalSize(const ImVec2& askedSize, const ImVec2& imageSize);    /* original C++ signature */
def image_proportional_size(asked_size: ImVec2, image_size: ImVec2) -> ImVec2:
    """`ImVec2 HelloImGui::ImageProportionalSize(askedSize, imageSize)`:
    will return the displayed size of an image.
       - if askedSize.x or askedSize.y is 0, then the corresponding dimension
         will be computed from the image size, keeping the aspect ratio.
       - if askedSize.x>0 and askedSize.y> 0, then the image will be scaled to fit
         exactly the askedSize, thus potentially changing the aspect ratio.
    Note: this function is used internally by ImageFromAsset and ImageButtonFromAsset,
          so you don't need to call it directly.
    """
    pass

# @@md

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_theme.h included by hello_imgui.h                                    //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# Theme tweak utilities for ImGui.
# Reuse and adaptation of imgui_theme.h and imgui_theme.cpp file is granted for other projects,
# provided the origin of those files is stated in the copied version
# Some themes were adapted by themes posted by ImGui users at https://github.com/ocornut/imgui/issues/707
#

class ImGuiTheme_(enum.Enum):
    # ImGuiTheme_ImGuiColorsClassic = 0,    /* original C++ signature */
    imgui_colors_classic = enum.auto()  # (= 0)
    # ImGuiTheme_ImGuiColorsDark,    /* original C++ signature */
    imgui_colors_dark = enum.auto()  # (= 1)
    # ImGuiTheme_ImGuiColorsLight,    /* original C++ signature */
    imgui_colors_light = enum.auto()  # (= 2)
    # ImGuiTheme_MaterialFlat,    /* original C++ signature */
    material_flat = enum.auto()  # (= 3)
    # ImGuiTheme_PhotoshopStyle,    /* original C++ signature */
    photoshop_style = enum.auto()  # (= 4)
    # ImGuiTheme_GrayVariations,    /* original C++ signature */
    gray_variations = enum.auto()  # (= 5)
    # ImGuiTheme_GrayVariations_Darker,    /* original C++ signature */
    gray_variations_darker = enum.auto()  # (= 6)
    # ImGuiTheme_MicrosoftStyle,    /* original C++ signature */
    microsoft_style = enum.auto()  # (= 7)
    # ImGuiTheme_Cherry,    /* original C++ signature */
    cherry = enum.auto()  # (= 8)
    # ImGuiTheme_Darcula,    /* original C++ signature */
    darcula = enum.auto()  # (= 9)
    # ImGuiTheme_DarculaDarker,    /* original C++ signature */
    darcula_darker = enum.auto()  # (= 10)
    # ImGuiTheme_LightRounded,    /* original C++ signature */
    light_rounded = enum.auto()  # (= 11)
    # ImGuiTheme_SoDark_AccentBlue,    /* original C++ signature */
    so_dark_accent_blue = enum.auto()  # (= 12)
    # ImGuiTheme_SoDark_AccentYellow,    /* original C++ signature */
    so_dark_accent_yellow = enum.auto()  # (= 13)
    # ImGuiTheme_SoDark_AccentRed,    /* original C++ signature */
    so_dark_accent_red = enum.auto()  # (= 14)
    # ImGuiTheme_BlackIsBlack,    /* original C++ signature */
    black_is_black = enum.auto()  # (= 15)
    # ImGuiTheme_WhiteIsWhite,    /* original C++ signature */
    white_is_white = enum.auto()  # (= 16)
    # ImGuiTheme_Count    /* original C++ signature */
    #     }
    count = enum.auto()  # (= 17)

# const char* ImGuiTheme_Name(ImGuiTheme_ theme);    /* original C++ signature */
def imgui_theme_name(theme: ImGuiTheme_) -> str:
    pass

# ImGuiTheme_ ImGuiTheme_FromName(const char* themeName);    /* original C++ signature */
def imgui_theme_from_name(theme_name: str) -> ImGuiTheme_:
    pass

# ImGuiStyle ThemeToStyle(ImGuiTheme_ theme);    /* original C++ signature */
def theme_to_style(theme: ImGuiTheme_) -> ImGuiStyle:
    pass

# void ApplyTheme(ImGuiTheme_ theme);    /* original C++ signature */
def apply_theme(theme: ImGuiTheme_) -> None:
    pass

class ImGuiThemeTweaks:
    # float Rounding = -1.f;    /* original C++ signature */
    # Common rounding for widgets. If < 0, this is ignored.
    rounding: float = -1.0
    # float RoundingScrollbarRatio = 4.f;    /* original C++ signature */
    # If rounding is applied, scrollbar rounding needs to be adjusted to be visually pleasing in conjunction with other widgets roundings. Only applied if Rounding > 0.)
    rounding_scrollbar_ratio: float = 4.0
    # float AlphaMultiplier = -1.f;    /* original C++ signature */
    # Change the alpha that will be applied to windows, popups, etc. If < 0, this is ignored.
    alpha_multiplier: float = -1.0

    # float Hue = -1.f;    /* original C++ signature */
    #
    # HSV Color tweaks
    #
    # Change the hue of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.
    hue: float = -1.0
    # float SaturationMultiplier = -1.f;    /* original C++ signature */
    # Multiply the saturation of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.
    saturation_multiplier: float = -1.0
    # float ValueMultiplierFront = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of all front widgets. If < 0, this is ignored.
    value_multiplier_front: float = -1.0
    # float ValueMultiplierBg = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of all backgrounds. If < 0, this is ignored.
    value_multiplier_bg: float = -1.0
    # float ValueMultiplierText = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of text. If < 0, this is ignored.
    value_multiplier_text: float = -1.0
    # float ValueMultiplierFrameBg = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of FrameBg. If < 0, this is ignored.
    # (Background of checkbox, radio button, plot, slider, text input)
    value_multiplier_frame_bg: float = -1.0

    # ImGuiThemeTweaks() {}    /* original C++ signature */
    def __init__(self) -> None:
        pass

class ImGuiTweakedTheme:
    # ImGuiTheme_ Theme = ImGuiTheme_DarculaDarker;    /* original C++ signature */
    theme: ImGuiTheme_ = ImGuiTheme_.darcula_darker
    # ImGuiThemeTweaks Tweaks = ImGuiThemeTweaks();    /* original C++ signature */
    tweaks: ImGuiThemeTweaks = ImGuiThemeTweaks()
    # ImGuiTweakedTheme(ImGuiTheme_ Theme = ImGuiTheme_DarculaDarker, ImGuiThemeTweaks Tweaks = ImGuiThemeTweaks());    /* original C++ signature */
    def __init__(
        self,
        theme: ImGuiTheme_ = ImGuiTheme_.darcula_darker,
        tweaks: ImGuiThemeTweaks = ImGuiThemeTweaks(),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# ImGuiStyle TweakedThemeThemeToStyle(const ImGuiTweakedTheme& tweaked_theme);    /* original C++ signature */
def tweaked_theme_theme_to_style(tweaked_theme: ImGuiTweakedTheme) -> ImGuiStyle:
    pass

# void ApplyTweakedTheme(const ImGuiTweakedTheme& tweaked_theme);    /* original C++ signature */
def apply_tweaked_theme(tweaked_theme: ImGuiTweakedTheme) -> None:
    pass

# bool ShowThemeTweakGui(ImGuiTweakedTheme *tweaked_theme);    /* original C++ signature */
def show_theme_tweak_gui(tweaked_theme: ImGuiTweakedTheme) -> bool:
    """Show the theme selection listbox, the theme tweak widgets, as well as ImGui::ShowStyleEditor. Returns True if modified (Warning, when using ShowStyleEditor, no info about modification is transmitted)"""
    pass

# Some tweakable themes
# ImGuiStyle SoDark(float hue);    /* original C++ signature */
def so_dark(hue: float) -> ImGuiStyle:
    pass

# ImGuiStyle ShadesOfGray(float rounding=0.f, float value_multiplier_front=1.f, float value_multiplier_bg=1.f);    /* original C++ signature */
def shades_of_gray(
    rounding: float = 0.0,
    value_multiplier_front: float = 1.0,
    value_multiplier_bg: float = 1.0,
) -> ImGuiStyle:
    pass

# ImGuiStyle Darcula(    /* original C++ signature */
#         float rounding=1.f,
#         float hue=-1.f,
#         float saturation_multiplier=1.f,
#         float value_multiplier_front=1.f,
#         float value_multiplier_bg=1.f,
#         float alpha_bg_transparency=1.f
#     );
def darcula(
    rounding: float = 1.0,
    hue: float = -1.0,
    saturation_multiplier: float = 1.0,
    value_multiplier_front: float = 1.0,
    value_multiplier_bg: float = 1.0,
    alpha_bg_transparency: float = 1.0,
) -> ImGuiStyle:
    pass

# namespace ImGuiTheme
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_font.h included by hello_imgui.h                               //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FontLoadingParams:
    """@@md#Fonts

    When loading fonts, use HelloImGui::LoadFont(fontFilename, fontSize, fontLoadingParams)

    Font loading parameters: several options are available (color, merging, range, ...)
    """

    # bool adjustSizeToDpi = true;    /* original C++ signature */
    # if True, the font size will be adjusted automatically to account for HighDPI
    adjust_size_to_dpi: bool = True

    # bool useFullGlyphRange = false;    /* original C++ signature */
    # if True, the font will be loaded with the full glyph range
    use_full_glyph_range: bool = False
    # bool reduceMemoryUsageIfFullGlyphRange = true;    /* original C++ signature */
    # if set, fontConfig.GlyphRanges, and
    #   fontConfig.OversampleH / fontConfig.OversampleV will be set to 1
    #   when useFullGlyphRange is True (this is useful to save memory)
    reduce_memory_usage_if_full_glyph_range: bool = True

    # bool mergeToLastFont = false;    /* original C++ signature */
    # if True, the font will be merged to the last font
    merge_to_last_font: bool = False

    # bool loadColor = false;    /* original C++ signature */
    # if True, the font will be loaded using colors
    # (requires freetype, enabled by IMGUI_ENABLE_FREETYPE)
    load_color: bool = False

    # bool insideAssets = true;    /* original C++ signature */
    # if True, the font will be loaded using HelloImGui asset system.
    # Otherwise, it will be loaded from the filesystem
    inside_assets: bool = True

    # std::vector<ImWcharPair> glyphRanges = {};    /* original C++ signature */
    # the ranges of glyphs to load:
    #    - if empty, the default glyph range will be used
    #    - you can specify several ranges
    #    - intervals bounds are inclusive
    # (will be translated and stored as a static ImWChar* inside fontConfig)
    glyph_ranges: List[ImWcharPair] = List[ImWcharPair]()

    # ImFontConfig fontConfig = ImFontConfig();    /* original C++ signature */
    # ImGui native font config to use
    font_config: ImFontConfig = ImFontConfig()

    # if True, the font will be loaded and then FontAwesome icons will be merged to it
    # (deprecated, use mergeToLastFont instead, and load in two steps)
    # bool mergeFontAwesome = false;    /* original C++ signature */
    merge_font_awesome: bool = False
    # ImFontConfig fontConfigFontAwesome = ImFontConfig();    /* original C++ signature */
    font_config_font_awesome: ImFontConfig = ImFontConfig()
    # void blah(bool adjustSizeToDpi = true, bool useFullGlyphRange = false, bool reduceMemoryUsageIfFullGlyphRange = true, bool mergeToLastFont = false, bool loadColor = false, bool insideAssets = true, std::vector<ImWcharPair> glyphRanges = __srcmlcpp_brace_init__(), ImFontConfig fontConfig = ImFontConfig(), bool mergeFontAwesome = false, ImFontConfig fontConfigFontAwesome = ImFontConfig());    /* original C++ signature */
    def __init__(
        self,
        adjust_size_to_dpi: bool = True,
        use_full_glyph_range: bool = False,
        reduce_memory_usage_if_full_glyph_range: bool = True,
        merge_to_last_font: bool = False,
        load_color: bool = False,
        inside_assets: bool = True,
        glyph_ranges: List[ImWcharPair] = List[ImWcharPair](),
        font_config: ImFontConfig = ImFontConfig(),
        merge_font_awesome: bool = False,
        font_config_font_awesome: ImFontConfig = ImFontConfig(),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# ImFont* LoadFont(const std::string & fontFilename, float fontSize,    /* original C++ signature */
#                      const FontLoadingParams & params = __srcmlcpp_brace_init__());
def load_font(
    font_filename: str,
    font_size: float,
    params: FontLoadingParams = FontLoadingParams(),
) -> ImFont:
    pass

# @@md

#
# Deprecated API below, kept for compatibility (uses LoadFont internally)
#
# ImFont* LoadFontTTF(    /* original C++ signature */
#         const std::string & fontFilename,
#         float fontSize,
#         bool useFullGlyphRange = false,
#         ImFontConfig config = ImFontConfig()
#         );
def load_font_ttf(
    font_filename: str,
    font_size: float,
    use_full_glyph_range: bool = False,
    config: ImFontConfig = ImFontConfig(),
) -> ImFont:
    pass

# ImFont* LoadFontTTF_WithFontAwesomeIcons(    /* original C++ signature */
#         const std::string & fontFilename,
#         float fontSize,
#         bool useFullGlyphRange = false,
#         ImFontConfig configFont = ImFontConfig(),
#         ImFontConfig configIcons = ImFontConfig()
#         );
def load_font_ttf_with_font_awesome_icons(
    font_filename: str,
    font_size: float,
    use_full_glyph_range: bool = False,
    config_font: ImFontConfig = ImFontConfig(),
    config_icons: ImFontConfig = ImFontConfig(),
) -> ImFont:
    pass

# ImFont* MergeFontAwesomeToLastFont(float fontSize, ImFontConfig config = ImFontConfig());    /* original C++ signature */
def merge_font_awesome_to_last_font(
    font_size: float, config: ImFontConfig = ImFontConfig()
) -> ImFont:
    pass

# bool DidCallHelloImGuiLoadFontTTF();    /* original C++ signature */
# }
def did_call_hello_imgui_load_font_ttf() -> bool:
    """indicates that fonts were loaded using HelloImGui::LoadFont. In that case, fonts may have been resized to
    account for HighDPI (on macOS and emscripten)
    """
    pass

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_params.h included by hello_imgui.h                                  //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/app_window_params.h included by hello_imgui/runner_params.h                //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/screen_bounds.h included by hello_imgui/app_window_params.h                //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Note: note related to DPI and high resolution screens:
# ScreenPosition and ScreenSize are in "Screen Coordinates":
# Screen coordinates *might* differ from real pixel on high dpi screens; but this depends on the OS.
# - For example, on apple a retina screenpixel size 3456x2052 might be seen as 1728x1026 in screen coordinates
# - Under windows, ScreenCoordinates correspond to pixels, even on high density screens

class ScreenBounds:
    # ScreenPosition position = DefaultScreenPosition;    /* original C++ signature */
    position: ScreenPosition = DefaultScreenPosition
    # ScreenSize size = DefaultWindowSize;    /* original C++ signature */
    size: ScreenSize = DefaultWindowSize

    # ScreenPosition TopLeftCorner() const{ return position; }    /* original C++ signature */
    def top_left_corner(self) -> ScreenPosition:
        pass
    # ScreenPosition BottomRightCorner() const{ return { position[0] + size[0], position[1] + size[1] }; }    /* original C++ signature */
    def bottom_right_corner(self) -> ScreenPosition:
        pass
    # ScreenPosition Center() const{ return { position[0] + size[0] / 2, position[1] + size[1] / 2 }; }    /* original C++ signature */
    def center(self) -> ScreenPosition:
        pass
    # bool Contains(ScreenPosition pixel) const;    /* original C++ signature */
    def contains(self, pixel: ScreenPosition) -> bool:
        pass
    # ScreenPosition WinPositionCentered(ScreenSize windowSize) const;    /* original C++ signature */
    def win_position_centered(self, window_size: ScreenSize) -> ScreenPosition:
        pass
    # int DistanceFromPixel(ScreenPosition point) const;    /* original C++ signature */
    def distance_from_pixel(self, point: ScreenPosition) -> int:
        pass
    # ScreenBounds EnsureWindowFitsThisMonitor(ScreenBounds windowBoundsOriginal) const;    /* original C++ signature */
    def ensure_window_fits_this_monitor(
        self, window_bounds_original: HelloImGui.ScreenBounds
    ) -> HelloImGui.ScreenBounds:
        pass
    # bool operator==(const ScreenBounds& other) const;    /* original C++ signature */
    def __eq__(self, other: HelloImGui.ScreenBounds) -> bool:
        pass
    # ScreenBounds(ScreenPosition position = DefaultScreenPosition, ScreenSize size = DefaultWindowSize);    /* original C++ signature */
    def __init__(
        self,
        position: ScreenPosition = DefaultScreenPosition,
        size: ScreenSize = DefaultWindowSize,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# namespace BackendApi

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/app_window_params.h continued                                              //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FullScreenMode(enum.Enum):
    # NoFullScreen,    /* original C++ signature */
    no_full_screen = enum.auto()  # (= 0)
    # FullScreen,                        /* original C++ signature */
    full_screen = enum.auto()  # (= 1)  # Full screen with specified resolution
    # FullScreenDesktopResolution,       /* original C++ signature */
    full_screen_desktop_resolution = (
        enum.auto()
    )  # (= 2)  # Full screen with current desktop mode & resolution
    # FullMonitorWorkArea                /* original C++ signature */
    full_monitor_work_area = (
        enum.auto()
    )  # (= 3)  # Fake full screen, maximized window on the selected monitor

class WindowSizeState(enum.Enum):
    # Standard,    /* original C++ signature */
    standard = enum.auto()  # (= 0)
    # Minimized,    /* original C++ signature */
    minimized = enum.auto()  # (= 1)
    # Maximized    /* original C++ signature */
    # }
    maximized = enum.auto()  # (= 2)

class WindowPositionMode(enum.Enum):
    # OsDefault,    /* original C++ signature */
    os_default = enum.auto()  # (= 0)
    # MonitorCenter,    /* original C++ signature */
    monitor_center = enum.auto()  # (= 1)
    # FromCoords,    /* original C++ signature */
    # }
    from_coords = enum.auto()  # (= 2)

class WindowSizeMeasureMode(enum.Enum):
    # ScreenCoords,    /* original C++ signature */
    # ScreenCoords: measure window size in screen coords.
    #     Note: screen coordinates *might* differ from real pixel on high dpi screens; but this depends on the OS.
    #         - For example, on apple a retina screenpixel size 3456x2052 might be seen as 1728x1026 in screen
    #           coordinates
    #         - Under windows, and if the application is DPI aware, ScreenCoordinates correspond to real pixels,
    #           even on high density screens
    screen_coords = enum.auto()  # (= 0)

    # RelativeTo96Ppi    /* original C++ signature */
    # }
    # RelativeTo96Ppi enables to give screen size that are independant from the screen density.
    # For example, a window size expressed as 800x600 will correspond to a size
    #    800x600 (in screen coords) if the monitor dpi is 96
    #    1600x120 (in screen coords) if the monitor dpi is 192
    relative_to96_ppi = enum.auto()  # (= 1)

class WindowGeometry:
    """@@md#WindowGeometry

    WindowGeometry is a struct that defines the window geometry.
    """

    # --------------- Window Size ------------------

    # ScreenSize size = DefaultWindowSize;    /* original C++ signature */
    # Size of the application window
    # used if fullScreenMode==NoFullScreen and sizeAuto==False. Default=(800, 600)
    size: ScreenSize = DefaultWindowSize

    # bool sizeAuto = false;    /* original C++ signature */
    # If sizeAuto=True, adapt the app window size to the presented widgets.
    # After the first frame was displayed, HelloImGui will measure its size, and the
    # application window will be resized.
    # As a consequence, the application window may change between the 1st and 2nd frame.
    # If True, adapt the app window size to the presented widgets. This is done at startup
    size_auto: bool = False

    # WindowSizeState windowSizeState = WindowSizeState::Standard;    /* original C++ signature */
    # `windowSizeState`: _WindowSizeState, default=Standard_
    #  You can choose between several window size states:
    #      Standard,
    #      Minimized,
    #      Maximized
    window_size_state: WindowSizeState = WindowSizeState.standard

    # WindowSizeMeasureMode windowSizeMeasureMode = WindowSizeMeasureMode::RelativeTo96Ppi;    /* original C++ signature */
    # `windowSizeMeasureMode`: _WindowSizeMeasureMode_, default=RelativeTo96Ppi
    # Define how the window size is specified:
    #      * RelativeTo96Ppi enables to give a screen size whose physical result
    #      (in millimeters) is independent of the screen density.
    #         For example, a window size expressed as 800x600 will correspond to a size
    #            - 800x600 (in screen coords) if the monitor dpi is 96
    #            - 1600x120 (in screen coords) if the monitor dpi is 192
    #          (this works with Glfw. With SDL, it only works under windows)
    #      * ScreenCoords: measure window size in screen coords
    #        (Note: screen coordinates might differ from real pixels on high dpi screen)
    window_size_measure_mode: WindowSizeMeasureMode = (
        WindowSizeMeasureMode.relative_to96_ppi
    )

    # --------------- Position ------------------

    # WindowPositionMode positionMode = WindowPositionMode::OsDefault;    /* original C++ signature */
    # `positionMode`: you can choose between several window position modes:
    #      OsDefault,
    #      MonitorCenter,
    #      FromCoords,
    position_mode: WindowPositionMode = WindowPositionMode.os_default

    # ScreenPosition position = DefaultScreenPosition;    /* original C++ signature */
    # `position`: used if windowPositionMode==FromCoords, default=(40, 40)
    position: ScreenPosition = DefaultScreenPosition

    # int monitorIdx = 0;    /* original C++ signature */
    # `monitorIdx`: index of the monitor to use, default=0
    #  used if positionMode==MonitorCenter or if fullScreenMode!=NoFullScreen
    monitor_idx: int = 0

    # --------------- Full screen ------------------

    # FullScreenMode fullScreenMode = FullScreenMode::NoFullScreen;    /* original C++ signature */
    # `fullScreenMode`: you can choose between several full screen modes:
    #      NoFullScreen,
    #      FullScreen,                  // Full screen with specified resolution
    #      FullScreenDesktopResolution, // Full screen with current desktop mode & resolution
    #      FullMonitorWorkArea          // Fake full screen (maximized window) on the selected monitor
    full_screen_mode: FullScreenMode = FullScreenMode.no_full_screen

    # --------------- Auto Resize ------------------

    # bool resizeAppWindowAtNextFrame = false;    /* original C++ signature */
    # `resizeAppWindowAtNextFrame`: _bool_, default=False;
    #  If you set this to flag to True at any point during the execution, the application
    #  window will then try to resize based on its content on the next displayed frame,
    #  and this flag will subsequently be set to False.
    #  Example:
    #   ```cpp
    # // Will resize the app window at next displayed frame
    #   HelloImGui::GetRunnerParams()->appWindowParams.windowGeometry.resizeAppWindowAtNextFrame = True;
    #   ```
    #  Note: this flag is intended to be used during execution, not at startup
    #  (use sizeAuto at startup).
    resize_app_window_at_next_frame: bool = False
    # WindowGeometry(ScreenSize size = DefaultWindowSize, bool sizeAuto = false, WindowSizeState windowSizeState = WindowSizeState::Standard, WindowSizeMeasureMode windowSizeMeasureMode = WindowSizeMeasureMode::RelativeTo96Ppi, WindowPositionMode positionMode = WindowPositionMode::OsDefault, ScreenPosition position = DefaultScreenPosition, int monitorIdx = 0, FullScreenMode fullScreenMode = FullScreenMode::NoFullScreen, bool resizeAppWindowAtNextFrame = false);    /* original C++ signature */
    def __init__(
        self,
        size: ScreenSize = DefaultWindowSize,
        size_auto: bool = False,
        window_size_state: WindowSizeState = WindowSizeState.standard,
        window_size_measure_mode: WindowSizeMeasureMode = WindowSizeMeasureMode.relative_to96_ppi,
        position_mode: WindowPositionMode = WindowPositionMode.os_default,
        position: ScreenPosition = DefaultScreenPosition,
        monitor_idx: int = 0,
        full_screen_mode: FullScreenMode = FullScreenMode.no_full_screen,
        resize_app_window_at_next_frame: bool = False,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

class EdgeInsets:
    """If there is a notch on the iPhone, you should not display inside these insets"""

    # double top = 0.;    /* original C++ signature */
    top: float = 0.0  # Typically around 47
    # double left = 0.;    /* original C++ signature */
    left: float = 0.0  # Typically 0
    # double bottom = 0.;    /* original C++ signature */
    bottom: float = 0.0  # Typically around 34
    # double right = 0.;    /* original C++ signature */
    right: float = 0.0  # Typically 0
    # EdgeInsets(double top = 0., double left = 0., double bottom = 0., double right = 0.);    /* original C++ signature */
    def __init__(
        self,
        top: float = 0.0,
        left: float = 0.0,
        bottom: float = 0.0,
        right: float = 0.0,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class AppWindowParams:
    """@@md#AppWindowParams

     AppWindowParams is a struct that defines the application window display params.
    See https://raw.githubusercontent.com/pthom/hello_imgui/master/src/hello_imgui/doc_src/hello_imgui_diagram.png
     for details.
    """

    # --------------- Standard params ------------------

    # std::string windowTitle;    /* original C++ signature */
    # `windowTitle`: _string, default=""_. Title of the application window
    window_title: str

    # WindowGeometry windowGeometry;    /* original C++ signature */
    # `windowGeometry`: _WindowGeometry_
    #  Enables to precisely set the window geometry (position, monitor, size,
    #  full screen, fake full screen, etc.)
    #   _Note: on a mobile device, the application will always be full screen._
    window_geometry: WindowGeometry

    # bool restorePreviousGeometry = false;    /* original C++ signature */
    # `restorePreviousGeometry`: _bool, default=false_.
    # If True, then save & restore windowGeometry from last run (the geometry
    # will be written in imgui_app_window.ini)
    restore_previous_geometry: bool = False

    # bool resizable = true;    /* original C++ signature */
    # `resizable`: _bool, default = false_. Should the window be resizable.
    # This is taken into account at creation.
    resizable: bool = True
    # bool hidden = false;    /* original C++ signature */
    # `hidden`: _bool, default = false_. Should the window be hidden.
    # This is taken into account dynamically (you can show/hide the window with this).
    # Full screen windows cannot be hidden.
    hidden: bool = False

    # --------------- Borderless window params ------------------

    # bool   borderless = false;    /* original C++ signature */
    # `borderless`: _bool, default = false_. Should the window have borders.
    # This is taken into account at creation.
    borderless: bool = False
    # bool   borderlessMovable = true;    /* original C++ signature */
    # `borderlessMovable`: if the window is borderless, should it be movable.
    #   If so, a drag zone is displayed at the top of the window when the mouse is over it.
    borderless_movable: bool = True
    # bool   borderlessResizable = true;    /* original C++ signature */
    # `borderlessResizable`: if the window is borderless, should it be resizable.
    #  If so, a drag zone is displayed at the bottom-right of the window
    #  when the mouse is over it.
    borderless_resizable: bool = True
    # bool   borderlessClosable = true;    /* original C++ signature */
    # `borderlessClosable`: if the window is borderless, should it have a close button.
    #  If so, a close button is displayed at the top-right of the window
    #  when the mouse is over it.
    borderless_closable: bool = True
    # ImVec4 borderlessHighlightColor = ImVec4(0.2f, 0.4f, 1.f, 0.3f);    /* original C++ signature */
    # `borderlessHighlightColor`:
    #   Color of the highlight displayed on resize/move zones.
    #   If borderlessHighlightColor.w==0, then the highlightColor will be automatically
    #   set to ImGui::GetColorU32(ImGuiCol_TitleBgActive, 0.6)
    borderless_highlight_color: ImVec4 = ImVec4(0.2, 0.4, 1.0, 0.3)

    # --------------- iOS Notch ------------------

    # EdgeInsets edgeInsets;    /* original C++ signature */
    # `edgeInsets`: _EdgeInsets_. iOS only, out values filled by HelloImGui.
    # If there is a notch on the iPhone, you should not display inside these insets.
    # HelloImGui handles this automatically, if handleEdgeInsets is True and
    # if runnerParams.imGuiWindowParams.defaultImGuiWindowType is not NoDefaultWindow.
    # (warning, these values are updated only after a few frames,
    #  they are typically 0 for the first 4 frames)
    edge_insets: EdgeInsets
    # bool       handleEdgeInsets = true;    /* original C++ signature */
    # `handleEdgeInsets`: _bool, default = true_. iOS only.
    # If True, HelloImGui will handle the edgeInsets on iOS.
    handle_edge_insets: bool = True
    # AppWindowParams(std::string windowTitle = std::string(), WindowGeometry windowGeometry = WindowGeometry(), bool restorePreviousGeometry = false, bool resizable = true, bool hidden = false, bool borderless = false, bool borderlessMovable = true, bool borderlessResizable = true, bool borderlessClosable = true, ImVec4 borderlessHighlightColor = ImVec4(0.2f, 0.4f, 1.f, 0.3f), EdgeInsets edgeInsets = EdgeInsets(), bool handleEdgeInsets = true);    /* original C++ signature */
    def __init__(
        self,
        window_title: str = "",
        window_geometry: WindowGeometry = WindowGeometry(),
        restore_previous_geometry: bool = False,
        resizable: bool = True,
        hidden: bool = False,
        borderless: bool = False,
        borderless_movable: bool = True,
        borderless_resizable: bool = True,
        borderless_closable: bool = True,
        borderless_highlight_color: ImVec4 = ImVec4(0.2, 0.4, 1.0, 0.3),
        edge_insets: EdgeInsets = EdgeInsets(),
        handle_edge_insets: bool = True,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

class DefaultImGuiWindowType(enum.Enum):
    """@@md#DefaultImGuiWindowType
    `DefaultImGuiWindowType` is an enum class that defines whether a full screen background
    window is provided or not
    """

    # ProvideFullScreenWindow,    /* original C++ signature */
    # `ProvideFullScreenWindow`: a full window is provided in the background
    provide_full_screen_window = enum.auto()  # (= 0)
    # ProvideFullScreenDockSpace,    /* original C++ signature */
    # `ProvideFullScreenDockSpace`: a full screen dockspace is provided in the background
    provide_full_screen_dock_space = enum.auto()  # (= 1)
    # NoDefaultWindow    /* original C++ signature */
    # }
    # `NoDefaultWindow`: No default window is provided
    # (except for ImGui's default "debug" window)
    no_default_window = enum.auto()  # (= 2)

# @@md

# @@md#ImGuiWindowParams

class ImGuiWindowParams:
    """`ImGuiWindowParams` is a struct that defines the ImGui inner windows params
    These settings affect the imgui inner windows inside the application window.
    In order to change the application window settings, change the `AppWindowsParams`
    """

    # ------------ Main Options  -------------------------------------------------------

    # DefaultImGuiWindowType defaultImGuiWindowType =    /* original C++ signature */
    #         DefaultImGuiWindowType::ProvideFullScreenWindow;
    # defaultImGuiWindowType: (enum DefaultImGuiWindowType)
    # Choose between:
    #    - ProvideFullScreenWindow (default)
    #      a full window is provided in the background
    #      You can still add windows on top of it, since the Z-order
    #      of this background window is always behind
    #    - ProvideFullScreenDockSpace:
    #      a full screen dockspace is provided in the background
    #      (use this if you intend to use docking)
    #    - NoDefaultWindow:
    #      no default window is provided
    default_imgui_window_type: DefaultImGuiWindowType = (
        DefaultImGuiWindowType.provide_full_screen_window
    )

    # bool enableViewports = false;    /* original C++ signature */
    # enableViewports: Enable multiple viewports (i.e. multiple native windows)
    # If True, you can drag windows outside the main window,
    # in order to put their content into new native windows.
    enable_viewports: bool = False

    # bool configWindowsMoveFromTitleBarOnly = true;    /* original C++ signature */
    # Make windows only movable from the title bar
    config_windows_move_from_title_bar_only: bool = True

    # ------------ Menus & Status bar --------------------------------------------------

    # std::string menuAppTitle = "";    /* original C++ signature */
    # Set the title of the App menu. If empty, the menu name will use
    # the "windowTitle" from AppWindowParams//
    menu_app_title: str = ""

    # bool showMenuBar = false;    /* original C++ signature */
    # Show Menu bar on top of imgui main window.
    # In order to fully customize the menu, set showMenuBar to True, and set showMenu_App
    # and showMenu_View params to False. Then, implement the callback
    # `RunnerParams.callbacks.ShowMenus`
    # which can optionally call `HelloImGui::ShowViewMenu` and `HelloImGui::ShowAppMenu`.
    show_menu_bar: bool = False

    # bool showMenu_App = true;    /* original C++ signature */
    #  If menu bar is shown, include or not the default app menu
    show_menu_app: bool = True

    # bool showMenu_App_Quit = true;    /* original C++ signature */
    # Include or not a "Quit" item in the default app menu.
    # Set this to False if you intend to provide your own quit callback
    # with possible user confirmation
    # (and implement it inside RunnerCallbacks.ShowAppMenuItems)
    show_menu_app_quit: bool = True

    # bool showMenu_View = true;    /* original C++ signature */
    # If menu bar is shown, include or not the default _View_ menu, that enables
    # to change the layout and set the docked windows and status bar visibility)
    show_menu_view: bool = True

    # bool showMenu_View_Themes = true;    /* original C++ signature */
    # Show theme selection in view menu
    show_menu_view_themes: bool = True
    # bool rememberTheme = true;    /* original C++ signature */
    # `rememberTheme`: _bool, default=true_. Remember selected theme
    remember_theme: bool = True

    # bool showStatusBar = false;    /* original C++ signature */
    # Flag that enable to show a Status bar at the bottom. You can customize
    # the status bar via RunnerCallbacks.ShowStatus()
    show_status_bar: bool = False

    # bool showStatus_Fps = true;    /* original C++ signature */
    # If set, display the FPS in the status bar.
    show_status_fps: bool = True
    # bool rememberStatusBarSettings = true;    /* original C++ signature */
    # If set, showStatusBar and showStatus_Fps are stored in the application settings.
    remember_status_bar_settings: bool = True

    # ------------ Change the dockspace or background window size -----------------------

    # If defaultImGuiWindowType = ProvideFullScreenWindow or ProvideFullScreenDockSpace,
    # you can set the position and size of the background window:
    #    - fullScreenWindow_MarginTopLeft is the window position
    #    - fullScreenWindow_MarginBottomRight is the margin between
    #      the "application window" bottom right corner
    #      and the "imgui background window" bottom right corner
    # Important note:
    #     In order to be Dpi aware, those sizes are in *em units*, not in pixels,
    #     i.e. in multiples of the font size! (See HelloImGui::EmToVec2)
    # ImVec2 fullScreenWindow_MarginTopLeft     = ImVec2(0.f, 0.f);    /* original C++ signature */
    full_screen_window_margin_top_left: ImVec2 = ImVec2(0.0, 0.0)
    # ImVec2 fullScreenWindow_MarginBottomRight = ImVec2(0.f, 0.f);    /* original C++ signature */
    full_screen_window_margin_bottom_right: ImVec2 = ImVec2(0.0, 0.0)

    # ------------ Theme ---------------------------------------------------------------

    # ImGuiTheme::ImGuiTweakedTheme tweakedTheme;    /* original C++ signature */
    # tweakedTheme: (enum ImGuiTheme::ImGuiTweakedTheme)
    # Changes the ImGui theme. Several themes are available, you can query the list
    # by calling HelloImGui::AvailableThemes()
    tweaked_theme: ImGuiTheme.ImGuiTweakedTheme

    # ImVec4 backgroundColor = ImVec4(0.f, 0.f, 0.f, 0.f);    /* original C++ signature */
    # backgroundColor:
    # This is the "clearColor", visible if defaultImGuiWindowType!=ProvideFullScreenWindow.
    # Alternatively, you can set your own RunnerCallbacks.CustomBackground to have full
    # control over what is drawn behind the Gui.
    background_color: ImVec4 = ImVec4(0.0, 0.0, 0.0, 0.0)

    # ImGuiWindowParams(DefaultImGuiWindowType defaultImGuiWindowType = DefaultImGuiWindowType::ProvideFullScreenWindow, bool enableViewports = false, bool configWindowsMoveFromTitleBarOnly = true, std::string menuAppTitle = "", bool showMenuBar = false, bool showMenu_App = true, bool showMenu_App_Quit = true, bool showMenu_View = true, bool showMenu_View_Themes = true, bool rememberTheme = true, bool showStatusBar = false, bool showStatus_Fps = true, bool rememberStatusBarSettings = true, ImVec2 fullScreenWindow_MarginTopLeft = ImVec2(0.f, 0.f), ImVec2 fullScreenWindow_MarginBottomRight = ImVec2(0.f, 0.f), ImGuiTheme::ImGuiTweakedTheme tweakedTheme = ImGuiTheme::ImGuiTweakedTheme(), ImVec4 backgroundColor = ImVec4(0.f, 0.f, 0.f, 0.f));    /* original C++ signature */
    def __init__(
        self,
        default_imgui_window_type: DefaultImGuiWindowType = DefaultImGuiWindowType.provide_full_screen_window,
        enable_viewports: bool = False,
        config_windows_move_from_title_bar_only: bool = True,
        menu_app_title: str = "",
        show_menu_bar: bool = False,
        show_menu_app: bool = True,
        show_menu_app_quit: bool = True,
        show_menu_view: bool = True,
        show_menu_view_themes: bool = True,
        remember_theme: bool = True,
        show_status_bar: bool = False,
        show_status_fps: bool = True,
        remember_status_bar_settings: bool = True,
        full_screen_window_margin_top_left: ImVec2 = ImVec2(0.0, 0.0),
        full_screen_window_margin_bottom_right: ImVec2 = ImVec2(0.0, 0.0),
        tweaked_theme: ImGuiTheme.ImGuiTweakedTheme = ImGuiTheme.ImGuiTweakedTheme(),
        background_color: ImVec4 = ImVec4(0.0, 0.0, 0.0, 0.0),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_callbacks.h included by hello_imgui/runner_params.h                 //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_default_settings.h included by hello_imgui/runner_callbacks.h        //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_callbacks.h continued                                               //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# *
# @@md#VoidFunction_AnyEventCallback
#
# **VoidFunctionPointer** can hold any None(None) function.
# ```cpp
# using VoidFunction = std::function<None(None)>
# ```
#
# **AnyEventCallback** can hold any bool(None *) function.
#  It is designed to handle callbacks for a specific backend.
# ```cpp
# using AnyEventCallback = std::function<bool(None * backendEvent)>
# ```
#
# **AppendCallback** can compose two callbacks. Use this when you want to set a callback and keep the (maybe) preexisting one.
# @@md
# *
# VoidFunction AppendCallback(const VoidFunction& previousCallback, const VoidFunction& newCallback);    /* original C++ signature */
def append_callback(
    previous_callback: VoidFunction, new_callback: VoidFunction
) -> VoidFunction:
    pass

# inline VoidFunction EmptyVoidFunction() { return {}; }    /* original C++ signature */
def empty_void_function() -> VoidFunction:
    pass

# inline AnyEventCallback EmptyEventCallback() {return {}; }    /* original C++ signature */
def empty_event_callback() -> AnyEventCallback:
    pass

class MobileCallbacks:
    """@@md#MobileCallbacks

    MobileCallbacks is a struct that contains callbacks that are called by the application
    when running under "Android, iOS and WinRT".
    These events are specific to mobile and embedded devices that have different
    requirements from your usual desktop application.
    These events must be handled quickly, since often the OS needs an immediate response
    and will terminate your process shortly after sending the event
    if you do not handle them appropriately.
    On mobile devices, it is not possible to "Quit" an application,
    it can only be put on Pause.
    """

    # VoidFunction OnDestroy = EmptyVoidFunction();    /* original C++ signature */
    # `OnDestroy`: The application is being terminated by the OS.
    on_destroy: VoidFunction = EmptyVoidFunction()

    # VoidFunction OnLowMemory = EmptyVoidFunction();    /* original C++ signature */
    # `OnLowMemory`: _VoidFunction, default=empty_.
    # When the application is low on memory, free memory if possible.
    on_low_memory: VoidFunction = EmptyVoidFunction()

    # VoidFunction OnPause = EmptyVoidFunction();    /* original C++ signature */
    # `OnPause`: The application is about to enter the background.
    on_pause: VoidFunction = EmptyVoidFunction()

    # VoidFunction OnResume = EmptyVoidFunction();    /* original C++ signature */
    # `OnResume`: The application came to foreground and is now interactive.
    # Note: 'OnPause' and 'OnResume' are called twice consecutively under iOS
    # (before and after entering background or foreground).
    on_resume: VoidFunction = EmptyVoidFunction()
    # MobileCallbacks(VoidFunction OnDestroy = EmptyVoidFunction(), VoidFunction OnLowMemory = EmptyVoidFunction(), VoidFunction OnPause = EmptyVoidFunction(), VoidFunction OnResume = EmptyVoidFunction());    /* original C++ signature */
    def __init__(
        self,
        on_destroy: VoidFunction = EmptyVoidFunction(),
        on_low_memory: VoidFunction = EmptyVoidFunction(),
        on_pause: VoidFunction = EmptyVoidFunction(),
        on_resume: VoidFunction = EmptyVoidFunction(),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

class RunnerCallbacks:
    """@@md#RunnerCallbacks

    RunnerCallbacks is a struct that contains the callbacks
    that are called by the application

    """

    # --------------- GUI Callbacks -------------------

    # VoidFunction ShowGui = EmptyVoidFunction();    /* original C++ signature */
    # `ShowGui`: Fill it with a function that will add your widgets.
    show_gui: VoidFunction = EmptyVoidFunction()

    # VoidFunction ShowMenus = EmptyVoidFunction();    /* original C++ signature */
    # `ShowMenus`: Fill it with a function that will add ImGui menus by calling:
    #       ImGui::BeginMenu(...) / ImGui::MenuItem(...) / ImGui::EndMenu()
    #   Notes:
    #   * you do not need to call ImGui::BeginMenuBar and ImGui::EndMenuBar
    #   * Some default menus can be provided:
    #     see ImGuiWindowParams options:
    #         _showMenuBar, showMenu_App_QuitAbout, showMenu_View_
    show_menus: VoidFunction = EmptyVoidFunction()

    # VoidFunction ShowAppMenuItems = EmptyVoidFunction();    /* original C++ signature */
    # `ShowAppMenuItems`: A function that will render items that will be placed
    # in the App menu. They will be placed before the "Quit" MenuItem,
    # which is added automatically by HelloImGui.
    #  This will be displayed only if ImGuiWindowParams.showMenu_App is True
    show_app_menu_items: VoidFunction = EmptyVoidFunction()

    # VoidFunction ShowStatus = EmptyVoidFunction();    /* original C++ signature */
    # `ShowStatus`: A function that will add items to the status bar.
    #  Use small items (ImGui::Text for example), since the height of the status is 30.
    #  Also, remember to call ImGui::SameLine() between items.
    show_status: VoidFunction = EmptyVoidFunction()

    # --------------- Startup sequence callbacks -------------------

    # VoidFunction PostInit = EmptyVoidFunction();    /* original C++ signature */
    # `PostInit`: You can here add a function that will be called once after OpenGL
    #  and ImGui are inited, but before the backend callback are initialized.
    #  If you, for instance, want to add your own glfw callbacks,
    #  you should use this function to do so.
    post_init: VoidFunction = EmptyVoidFunction()

    # VoidFunction LoadAdditionalFonts =    /* original C++ signature */
    #         (VoidFunction)(ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons);
    # `LoadAdditionalFonts`: default=_LoadDefaultFont_WithFontAwesome*.
    #  A function that is called once, when fonts are ready to be loaded.
    #  By default, _LoadDefaultFont_WithFontAwesome_ is called,
    #  but you can copy and customize it.
    #  (LoadDefaultFont_WithFontAwesome will load fonts from assets/fonts/
    #  but reverts to the ImGui embedded font if not found)
    load_additional_fonts: VoidFunction = (VoidFunction)(
        ImGuiDefaultSettings.LoadDefaultFont_WithFontAwesomeIcons
    )

    # VoidFunction SetupImGuiConfig =    /* original C++ signature */
    #         (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiConfig);
    # `SetupImGuiConfig`: default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.
    #  If needed, change ImGui config via SetupImGuiConfig
    #  (enable docking, gamepad, etc)
    setup_imgui_config: VoidFunction = (VoidFunction)(
        ImGuiDefaultSettings.SetupDefaultImGuiConfig
    )

    # VoidFunction SetupImGuiStyle =    /* original C++ signature */
    #         (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiStyle);
    # `SetupImGuiStyle`: default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.
    #  If needed, set your own style by providing your own SetupImGuiStyle callback
    setup_imgui_style: VoidFunction = (VoidFunction)(
        ImGuiDefaultSettings.SetupDefaultImGuiStyle
    )

    # VoidFunction RegisterTests = EmptyVoidFunction();    /* original C++ signature */
    # `RegisterTests`: A function that is called once ImGuiTestEngine is ready
    # to be filled with tests and automations definitions.
    register_tests: VoidFunction = EmptyVoidFunction()

    # --------------- Exit sequence callbacks -------------------

    # VoidFunction BeforeExit = EmptyVoidFunction();    /* original C++ signature */
    # `BeforeExit`: You can here add a function that will be called once before exiting
    #  (when OpenGL and ImGui are still inited)
    before_exit: VoidFunction = EmptyVoidFunction()

    # VoidFunction BeforeExit_PostCleanup = EmptyVoidFunction();    /* original C++ signature */
    # `BeforeExit_PostCleanup`: You can here add a function that will be called once
    # before exiting (after OpenGL and ImGui have been stopped)
    before_exit_post_cleanup: VoidFunction = EmptyVoidFunction()

    # --------------- Callbacks in the render loop -------------------

    # VoidFunction PreNewFrame = EmptyVoidFunction();    /* original C++ signature */
    # `PreNewFrame`: You can here add a function that will be called at each frame,
    #  and before the call to ImGui::NewFrame().
    #  It is a good place to dynamically add new fonts, or new dockable windows.
    pre_new_frame: VoidFunction = EmptyVoidFunction()

    # VoidFunction BeforeImGuiRender = EmptyVoidFunction();    /* original C++ signature */
    # `BeforeImGuiRender`: You can here add a function that will be called at each frame,
    #  after the user Gui code, and just before the call to
    #  ImGui::Render() (which will also call ImGui::EndFrame()).
    before_imgui_render: VoidFunction = EmptyVoidFunction()

    # VoidFunction AfterSwap = EmptyVoidFunction();    /* original C++ signature */
    # `AfterSwap`: You can here add a function that will be called at each frame,
    #  after the Gui was rendered and swapped to the screen.
    after_swap: VoidFunction = EmptyVoidFunction()

    # VoidFunction CustomBackground = EmptyVoidFunction();    /* original C++ signature */
    # `CustomBackground`:
    #  By default, the background is cleared using ImGuiWindowParams.backgroundColor.
    #  If set, this function gives you full control over the background that is drawn
    #  behind the Gui. An example use case is if you have a 3D application
    #  like a mesh editor, or game, and just want the Gui to be drawn
    #  on top of that content.
    custom_background: VoidFunction = EmptyVoidFunction()

    # AnyEventCallback AnyBackendEventCallback = EmptyEventCallback();    /* original C++ signature */
    # `AnyBackendEventCallback`:
    #  Callbacks for events from a specific backend. _Only implemented for SDL.
    #  where the event will be of type 'SDL_Event *'_
    #  This callback should return True if the event was handled
    #  and shall not be processed further.
    #  Note: in the case of GLFW, you should use register them in `PostInit`
    any_backend_event_callback: AnyEventCallback = EmptyEventCallback()

    # --------------- Mobile callbacks -------------------
    # RunnerCallbacks(VoidFunction ShowGui = EmptyVoidFunction(), VoidFunction ShowMenus = EmptyVoidFunction(), VoidFunction ShowAppMenuItems = EmptyVoidFunction(), VoidFunction ShowStatus = EmptyVoidFunction(), VoidFunction PostInit = EmptyVoidFunction(), VoidFunction LoadAdditionalFonts = (VoidFunction)(ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons), VoidFunction SetupImGuiConfig = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiConfig), VoidFunction SetupImGuiStyle = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiStyle), VoidFunction RegisterTests = EmptyVoidFunction(), VoidFunction BeforeExit = EmptyVoidFunction(), VoidFunction BeforeExit_PostCleanup = EmptyVoidFunction(), VoidFunction PreNewFrame = EmptyVoidFunction(), VoidFunction BeforeImGuiRender = EmptyVoidFunction(), VoidFunction AfterSwap = EmptyVoidFunction(), VoidFunction CustomBackground = EmptyVoidFunction(), AnyEventCallback AnyBackendEventCallback = EmptyEventCallback());    /* original C++ signature */
    def __init__(
        self,
        show_gui: VoidFunction = EmptyVoidFunction(),
        show_menus: VoidFunction = EmptyVoidFunction(),
        show_app_menu_items: VoidFunction = EmptyVoidFunction(),
        show_status: VoidFunction = EmptyVoidFunction(),
        post_init: VoidFunction = EmptyVoidFunction(),
        load_additional_fonts: VoidFunction = (VoidFunction)(
            ImGuiDefaultSettings.LoadDefaultFont_WithFontAwesomeIcons
        ),
        setup_imgui_config: VoidFunction = (VoidFunction)(
            ImGuiDefaultSettings.SetupDefaultImGuiConfig
        ),
        setup_imgui_style: VoidFunction = (VoidFunction)(
            ImGuiDefaultSettings.SetupDefaultImGuiStyle
        ),
        register_tests: VoidFunction = EmptyVoidFunction(),
        before_exit: VoidFunction = EmptyVoidFunction(),
        before_exit_post_cleanup: VoidFunction = EmptyVoidFunction(),
        pre_new_frame: VoidFunction = EmptyVoidFunction(),
        before_imgui_render: VoidFunction = EmptyVoidFunction(),
        after_swap: VoidFunction = EmptyVoidFunction(),
        custom_background: VoidFunction = EmptyVoidFunction(),
        any_backend_event_callback: AnyEventCallback = EmptyEventCallback(),
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

# namespace HelloImGui

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/docking_params.h included by hello_imgui/runner_params.h                   //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# *
# @@md#DockingIntro
#
# HelloImGui makes it easy to use dockable windows
# (based on ImGui [docking branch](https://github.com/ocornut/imgui/tree/docking)).
#
# You can define several layouts and switch between them:  each layout which will remember
# the user modifications and the list of opened windows
#
# HelloImGui will then provide a "View" menu with options to show/hide the dockable windows,
# restore the default layout, switch between layouts, etc.
#
#![demo docking](https://traineq.org/ImGuiBundle/HelloImGuiLayout.gif)
#
# * Source for this example: https://github.com/pthom/hello_imgui/tree/master/src/hello_imgui_demos/hello_imgui_demodocking
# * [Video explanation on YouTube](https://www.youtube.com/watch?v=XKxmz__F4ow) (5 minutes)
#
#
# The different available layouts are provided inside RunnerParams via the two members below:
# ```cpp
# struct RunnerParams
# {
#    ...
#    // default layout of the application
#    DockingParams dockingParams;
#
#    // optional alternative layouts
#    std::vector<DockingParams> alternativeDockingLayouts;
#
#    ...
# };
# ```
#
# And `DockingParams` contains members that define a layout:
#
# ```cpp
# struct DockingParams
# {
#    // displayed name of the layout
#    std::string layoutName = "Default";
#
#    // list of splits
#    // (which define spaces where the windows will be placed)
#    std::vector<DockingSplit> dockingSplits;
#
#    // list of windows
#    // (with their gui code, and specifying in which space they will be placed)
#    std::vector<DockableWindow> dockableWindows;
#
#    ...
# };
# ```
#
# Inside DockingParams, the member `dockingSplits` specifies the layout, and the member `dockableWindows`
# specifies the list of dockable windows, along with their default location, and their code (given by lambdas).
#
# @@md
#
#
# @@md#DockingExample
#
# Below is an example that shows how to instantiate a layout:
#
# 1. First, define the docking splits:
#
# ```cpp
# std::vector<HelloImGui::DockingSplit> CreateDefaultDockingSplits()
# {
#    //   Here, we want to split "MainDockSpace" (which is provided automatically)
#    //   into three zones, like this:
#    //    ___________________________________________
#    //    |        |                                |
#    //    | Command|                                |
#    //    | Space  |    MainDockSpace               |
#    //    |        |                                |
#    //    |        |                                |
#    //    |        |                                |
#    //    -------------------------------------------
#    //    |     MiscSpace                           |
#    //    -------------------------------------------
#    //
#
#    // add a space named "MiscSpace" whose height is 25% of the app height.
#    // This will split the preexisting default dockspace "MainDockSpace" in two parts.
#    HelloImGui::DockingSplit splitMainMisc;
#    splitMainMisc.initialDock = "MainDockSpace";
#    splitMainMisc.newDock = "MiscSpace";
#    splitMainMisc.direction = ImGuiDir_Down;
#    splitMainMisc.ratio = 0.25;
#
#    // Then, add a space to the left which occupies a column
#    // whose width is 25% of the app width
#    HelloImGui::DockingSplit splitMainCommand;
#    splitMainCommand.initialDock = "MainDockSpace";
#    splitMainCommand.newDock = "CommandSpace";
#    splitMainCommand.direction = ImGuiDir_Left;
#    splitMainCommand.ratio = 0.25;
#
#    std::vector<HelloImGui::DockingSplit> splits {splitMainMisc, splitMainCommand};
#    return splits;
# }
# ```
#
# 2. Then, define the dockable windows:
#
# ```cpp
# std::vector<HelloImGui::DockableWindow> CreateDockableWindows(AppState& appState)
# {
#    // A Command panel named "Commands" will be placed in "CommandSpace".
#    // Its Gui is provided calls "CommandGui"
#    HelloImGui::DockableWindow commandsWindow;
#    commandsWindow.label = "Commands";
#    commandsWindow.dockSpaceName = "CommandSpace";
#    commandsWindow.GuiFunction = [&] { CommandGui(appState); };
#
#    // A Log window named "Logs" will be placed in "MiscSpace".
#    // It uses the HelloImGui logger gui
#    HelloImGui::DockableWindow logsWindow;
#    logsWindow.label = "Logs";
#    logsWindow.dockSpaceName = "MiscSpace";
#    logsWindow.GuiFunction = [] { HelloImGui::LogGui(); };
#
#    ...
# }
# ```
#
# 3. Finally, fill the RunnerParams
#
# ```cpp
# HelloImGui::RunnerParams runnerParams;
# runnerParams.imGuiWindowParams.defaultImGuiWindowType =
#    HelloImGui::DefaultImGuiWindowType::ProvideFullScreenDockSpace;
#
# runnerParams.dockingParams.dockingSplits = CreateDefaultDockingSplits();
# runnerParams.dockingParams.dockableWindows = CreateDockableWindows();
#
#
# HelloImGui::Run(runnerParams);
# ```
#
# @@md
#

# ***************************************************************************

# @@md#DockingSplit

class DockingSplit:
    """DockingSplit is a struct that defines the way the docking splits should
    be applied on the screen in order to create new Dock Spaces.
    DockingParams contains a
        vector<DockingSplit>
    in order to partition the screen at your will.
    """

    # DockSpaceName initialDock;    /* original C++ signature */
    # `initialDock`: _DockSpaceName (aka string)_
    #  id of the space that should be split.
    #  At the start, there is only one Dock Space named "MainDockSpace".
    #  You should start by partitioning this space, in order to create a new dock space.
    initial_dock: DockSpaceName

    # DockSpaceName newDock;    /* original C++ signature */
    # `newDock`: _DockSpaceName (aka string)_.
    #  id of the new dock space that will be created.
    new_dock: DockSpaceName

    # ImGuiDir_ direction;    /* original C++ signature */
    # `direction`: *ImGuiDir_*
    #  (enum with ImGuiDir_Down, ImGuiDir_Down, ImGuiDir_Left, ImGuiDir_Right)*
    #  Direction where this dock space should be created.
    direction: ImGuiDir_

    # float ratio = 0.25f;    /* original C++ signature */
    # `ratio`: _float, default=0.25_.
    #  Ratio of the initialDock size that should be used by the new dock space.
    ratio: float = 0.25

    # ImGuiDockNodeFlags nodeFlags = ImGuiDockNodeFlags_None;    /* original C++ signature */
    # `nodeFlags`: *ImGuiDockNodeFlags_ (enum)*.
    #  Flags to apply to the new dock space
    #  (enable/disable resizing, splitting, tab bar, etc.)
    node_flags: ImGuiDockNodeFlags = ImGuiDockNodeFlags_None

    # DockingSplit(const DockSpaceName& initialDock_ = "", const DockSpaceName& newDock_ = "",    /* original C++ signature */
    #                  ImGuiDir_ direction_ = ImGuiDir_Down, float ratio_ = 0.25f,
    #                  ImGuiDockNodeFlags nodeFlags_ = ImGuiDockNodeFlags_None)
    #         : initialDock(initialDock_), newDock(newDock_), direction(direction_), ratio(ratio_), nodeFlags(nodeFlags_) {}
    def __init__(
        self,
        initial_dock_: DockSpaceName = "",
        new_dock_: DockSpaceName = "",
        direction_: ImGuiDir_ = ImGuiDir_Down,
        ratio_: float = 0.25,
        node_flags_: ImGuiDockNodeFlags = ImGuiDockNodeFlags_None,
    ) -> None:
        """Constructor"""
        pass

# @@md

# @@md#DockableWindow

class DockableWindow:
    """DockableWindow is a struct that represents a window that can be docked."""

    # --------------- Main params -------------------

    # std::string label;    /* original C++ signature */
    # `label`: _string_. Title of the window.
    label: str

    # DockSpaceName dockSpaceName;    /* original C++ signature */
    # `dockSpaceName`: _DockSpaceName (aka string)_.
    #  Id of the dock space where this window should initially be placed
    dock_space_name: DockSpaceName

    # VoidFunction GuiFunction = EmptyVoidFunction();    /* original C++ signature */
    # `GuiFunction`: _VoidFunction_.
    # Any function that will render this window's Gui
    gui_function: VoidFunction = EmptyVoidFunction()

    # --------------- Options --------------------------

    # bool isVisible = true;    /* original C++ signature */
    # `isVisible`: _bool, default=true_.
    #  Flag that indicates whether this window is visible or not.
    is_visible: bool = True

    # bool rememberIsVisible = true;    /* original C++ signature */
    # `rememberIsVisible`: _bool, default=true_.
    #  Flag that indicates whether the window visibility should be saved in settings.
    remember_is_visible: bool = True

    # bool canBeClosed = true;    /* original C++ signature */
    # `canBeClosed`: _bool, default=true_.
    #  Flag that indicates whether the user can close this window.
    can_be_closed: bool = True

    # bool callBeginEnd = true;    /* original C++ signature */
    # `callBeginEnd`: _bool, default=true_.
    #  Flag that indicates whether ImGui::Begin and ImGui::End
    #  calls should be added automatically (with the given "label").
    #  Set to False if you want to call ImGui::Begin/End yourself
    call_begin_end: bool = True

    # bool includeInViewMenu = true;    /* original C++ signature */
    # `includeInViewMenu`: _bool, default=true_.
    #  Flag that indicates whether this window should be mentioned in the view menu.
    include_in_view_menu: bool = True

    # ImGuiWindowFlags imGuiWindowFlags = 0;    /* original C++ signature */
    # `imGuiWindowFlags`: _ImGuiWindowFlags, default=0_.
    #  Window flags, see enum ImGuiWindowFlags_
    imgui_window_flags: ImGuiWindowFlags = 0

    # --------------- Focus window -----------------------------

    # bool focusWindowAtNextFrame = false;    /* original C++ signature */
    # `focusWindowAtNextFrame`: _bool, default = false_.
    #  If set to True this window will be focused at the next frame.
    focus_window_at_next_frame: bool = False

    # --------------- Size & Position --------------------------
    #              (only if not docked)

    # ImVec2 windowSize = ImVec2(0.f, 0.f);    /* original C++ signature */
    # `windowSize`: _ImVec2, default=(0., 0.) (i.e let the app decide)_.
    #  Window size (unused if docked)
    window_size: ImVec2 = ImVec2(0.0, 0.0)

    # ImGuiCond  windowSizeCondition = ImGuiCond_FirstUseEver;    /* original C++ signature */
    # `windowSizeCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_.
    #  When to apply the window size.
    window_size_condition: ImGuiCond = ImGuiCond_FirstUseEver

    # ImVec2 windowPosition = ImVec2(0.f, 0.f);    /* original C++ signature */
    # `windowPos`: _ImVec2, default=(0., 0.) (i.e let the app decide)_.
    #  Window position (unused if docked)
    window_position: ImVec2 = ImVec2(0.0, 0.0)

    # ImGuiCond  windowPositionCondition = ImGuiCond_FirstUseEver;    /* original C++ signature */
    # `windowPosCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_.
    #  When to apply the window position.
    window_position_condition: ImGuiCond = ImGuiCond_FirstUseEver

    # DockableWindow(    /* original C++ signature */
    #         const std::string & label_ = "",
    #         const DockSpaceName & dockSpaceName_ = "",
    #         const VoidFunction guiFunction_ = EmptyVoidFunction(),
    #         bool isVisible_ = true,
    #         bool canBeClosed_ = true)
    #         : label(label_), dockSpaceName(dockSpaceName_),
    #           GuiFunction(guiFunction_),
    #           isVisible(isVisible_),
    #           canBeClosed(canBeClosed_) {}
    def __init__(
        self,
        label_: str = "",
        dock_space_name_: DockSpaceName = "",
        gui_function_: VoidFunction = EmptyVoidFunction(),
        is_visible_: bool = True,
        can_be_closed_: bool = True,
    ) -> None:
        """--------------- Constructor ------------------------------
        Constructor
        """
        pass

# @@md

class DockingLayoutCondition(enum.Enum):
    # FirstUseEver,    /* original C++ signature */
    first_use_ever = enum.auto()  # (= 0)
    # ApplicationStart,    /* original C++ signature */
    application_start = enum.auto()  # (= 1)
    # Never    /* original C++ signature */
    # }
    never = enum.auto()  # (= 2)

# @@md#DockingParams

class DockingParams:
    """DockingParams contains all the settings concerning the docking:
    - list of splits
    - list of dockable windows
    """

    # --------------- Main params -----------------------------

    # std::vector<DockingSplit>   dockingSplits;    /* original C++ signature */
    # `dockingSplits`: _vector[DockingSplit]_.
    #  Defines the way docking splits should be applied on the screen
    #  in order to create new Dock Spaces
    docking_splits: List[DockingSplit]

    # std::vector<DockableWindow> dockableWindows;    /* original C++ signature */
    # `dockableWindows`: _vector[DockableWindow]_.
    #  List of the dockable windows, together with their Gui code
    dockable_windows: List[DockableWindow]

    # std::string layoutName = "Default";    /* original C++ signature */
    # `layoutName`: _string, default="default"_.
    #  Displayed name of the layout.
    #  Only used in advanced cases, when several layouts are available.
    layout_name: str = "Default"

    # --------------- Options -----------------------------

    # ImGuiDockNodeFlags mainDockSpaceNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode;    /* original C++ signature */
    # `mainDockSpaceNodeFlags`: _ImGuiDockNodeFlags (enum),
    #      default=ImGuiDockNodeFlags_PassthruCentralNode_
    #  Flags to apply to the main dock space
    #  (enable/disable resizing, splitting, tab bar, etc.).
    #  Most flags are inherited by children dock spaces.
    #  You can also set flags for specific dock spaces via `DockingSplit.nodeFlags`
    main_dock_space_node_flags: ImGuiDockNodeFlags = (
        ImGuiDockNodeFlags_PassthruCentralNode
    )

    # --------------- Layout handling -----------------------------

    # DockingLayoutCondition layoutCondition = DockingLayoutCondition::FirstUseEver;    /* original C++ signature */
    # `layoutCondition`: _enum DockingLayoutCondition, default=FirstUseEver_.
    #  When to apply the docking layout. Choose between
    #      FirstUseEver (apply once, then keep user preference),
    #      ApplicationStart (always reapply at application start)
    #      Never
    layout_condition: DockingLayoutCondition = DockingLayoutCondition.first_use_ever

    # bool layoutReset = false;    /* original C++ signature */
    # `layoutReset`: _bool, default=false_.
    #  Reset layout on next frame, i.e. drop the layout customizations which were
    #  applied manually by the user. layoutReset will be reset to False after this.
    layout_reset: bool = False

    # --------------- Helper Methods -----------------------------

    # DockableWindow * dockableWindowOfName(const std::string& name);    /* original C++ signature */
    def dockable_window_of_name(self, name: str) -> DockableWindow:
        """`DockableWindow * dockableWindowOfName(const std::string & name)`:
        returns a pointer to a dockable window
        """
        pass
    # bool focusDockableWindow(const std::string& windowName);    /* original C++ signature */
    def focus_dockable_window(self, window_name: str) -> bool:
        """`bool focusDockableWindow(const std::string& name)`:
        will focus a dockable window (and make its tab visible if needed)
        """
        pass
    # std::optional<ImGuiID> dockSpaceIdFromName(const std::string& dockSpaceName);    /* original C++ signature */
    def dock_space_id_from_name(self, dock_space_name: str) -> Optional[ImGuiID]:
        """`optional<ImGuiID> dockSpaceIdFromName(const std::string& dockSpaceName)`:
        may return the ImGuiID corresponding to the dockspace with this name.
        **Warning**: this will work reliably only if
            layoutCondition = DockingLayoutCondition::ApplicationStart.
        In other cases, the ID may be cached by ImGui himself at the first run,
        and HelloImGui will *not* know it on subsequent runs!
        """
        pass
    # DockingParams(std::vector<DockingSplit> dockingSplits = std::vector<DockingSplit>(), std::vector<DockableWindow> dockableWindows = std::vector<DockableWindow>(), std::string layoutName = "Default", ImGuiDockNodeFlags mainDockSpaceNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode, DockingLayoutCondition layoutCondition = DockingLayoutCondition::FirstUseEver, bool layoutReset = false);    /* original C++ signature */
    def __init__(
        self,
        docking_splits: List[DockingSplit] = List[DockingSplit](),
        dockable_windows: List[DockableWindow] = List[DockableWindow](),
        layout_name: str = "Default",
        main_dock_space_node_flags: ImGuiDockNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode,
        layout_condition: DockingLayoutCondition = DockingLayoutCondition.first_use_ever,
        layout_reset: bool = False,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/backend_pointers.h included by hello_imgui/runner_params.h                 //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

class BackendPointers:
    """@@md#BackendPointers

    BackendPointers is a struct that contains optional pointers to the
    backend implementations (for SDL and GLFW).

    These pointers will be filled when the application starts, and you can use them
    to customize your application behavior using the selected backend.

    Note: If using the Metal, Vulkan or DirectX rendering backend, you can find
    some interesting pointers inside
        `src/hello_imgui/internal/backend_impls/rendering_metal.h`
        `src/hello_imgui/internal/backend_impls/rendering_vulkan.h`
        `src/hello_imgui/internal/backend_impls/rendering_dx11.h`
        `src/hello_imgui/internal/backend_impls/rendering_dx12.h`
    """

    # * `glfwWindow`: Pointer to the main GLFW window (of type `GLFWwindow*`).
    #  Only filled if the backend is GLFW.
    # void* glfwWindow     = nullptr;    /* original C++ signature */
    glfw_window: Any = None  # GLFWwindow*

    # * `sdlWindow`: Pointer to the main SDL window (of type `SDL_Window*`).
    #  Only filled if the backend is SDL (or emscripten + sdl)
    # void* sdlWindow      = nullptr;    /* original C++ signature */
    sdl_window: Any = None  # SDL_Window*

    # * `sdlGlContext`: Pointer to SDL's GlContext (of type `SDL_GLContext`).
    #  Only filled if the backend is SDL (or emscripten + sdl)
    # void* sdlGlContext   = nullptr;    /* original C++ signature */
    sdl_gl_context: Any = None  # SDL_GLContext
    # BackendPointers();    /* original C++ signature */
    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

# @@md

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_params.h continued                                                  //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

class BackendType(enum.Enum):
    """Platform backend type (SDL, GLFW)"""

    # FirstAvailable,    /* original C++ signature */
    first_available = enum.auto()  # (= 0)
    # Sdl,    /* original C++ signature */
    sdl = enum.auto()  # (= 1)
    # Glfw,    /* original C++ signature */
    # }
    glfw = enum.auto()  # (= 2)

# @@md#IniFolderType

class IniFolderType(enum.Enum):
    """IniFolderType is an enum which describle where is the base path to store
    the ini file for the application settings.

    You can use IniFolderLocation(iniFolderType) to get the corresponding path.

    RunnerParams contains the following members, which are used to compute
    the ini file location:
        iniFolderType           (IniFolderType::CurrentFolder by default)
        iniFilename             (empty string by default)
        iniFilename_useAppWindowTitle
            (True by default: iniFilename is derived from
             appWindowParams.windowTitle)

    iniFilename may contain a subfolder
    (which will be created inside the iniFolderType folder if needed)

    """

    # CurrentFolder,    /* original C++ signature */
    # CurrentFolder: the folder where the application is executed
    # (convenient for development, but not recommended for production)
    current_folder = enum.auto()  # (= 0)

    # AppUserConfigFolder,    /* original C++ signature */
    # AppUserConfigFolder:
    #      AppData under Windows (Example: C:\Users\[Username]\AppData\Roaming under windows)
    #      ~/.config under Linux
    #      "~/Library/Application Support" under macOS
    # (recommended for production, if settings do not need to be easily accessible by the user)
    app_user_config_folder = enum.auto()  # (= 1)

    # AppExecutableFolder,    /* original C++ signature */
    # AppExecutableFolder: the folder where the application executable is located
    # (this may be different from CurrentFolder if the application is launched from a shortcut)
    # (convenient for development, but not recommended for production)
    app_executable_folder = enum.auto()  # (= 2)

    # HomeFolder,    /* original C++ signature */
    # HomeFolder: the user home folder
    # (recommended for production, if settings need to be easily accessible by the user)
    home_folder = enum.auto()  # (= 3)

    # DocumentsFolder,    /* original C++ signature */
    # DocumentsFolder: the user documents folder
    documents_folder = enum.auto()  # (= 4)

    # TempFolder    /* original C++ signature */
    # }
    # TempFolder: the system temp folder
    temp_folder = enum.auto()  # (= 5)

# std::string IniFolderLocation(IniFolderType iniFolderType);    /* original C++ signature */
def ini_folder_location(ini_folder_type: IniFolderType) -> str:
    """Returns the path corresponding to the given IniFolderType"""
    pass

# @@md

class FpsIdling:
    """@@md#FpsIdling

    FpsIdling is a struct that contains Fps Idling parameters
    """

    # float fpsIdle = 9.f;    /* original C++ signature */
    # `fpsIdle`: _float, default=9_.
    #  ImGui applications can consume a lot of CPU, since they update the screen
    #  very frequently. In order to reduce the CPU usage, the FPS is reduced when
    #  no user interaction is detected.
    #  This is ok most of the time but if you are displaying animated widgets
    #  (for example a live video), you may want to ask for a faster refresh:
    #  either increase fpsIdle, or set it to 0 for maximum refresh speed
    #  (you can change this value during the execution depending on your application
    #  refresh needs)
    fps_idle: float = 9.0

    # bool  enableIdling = true;    /* original C++ signature */
    # `enableIdling`: _bool, default=true_.
    #  Set this to False to disable idling
    #  (this can be changed dynamically during execution)
    enable_idling: bool = True

    # bool  isIdling = false;    /* original C++ signature */
    # `isIdling`: bool (dynamically updated during execution)
    #  This bool will be updated during the application execution,
    #  and will be set to True when it is idling.
    is_idling: bool = False

    # bool  rememberEnableIdling = true;    /* original C++ signature */
    # `rememberEnableIdling`: _bool, default=true_.
    #  If True, the last value of enableIdling is restored from the settings at startup.
    remember_enable_idling: bool = True
    # FpsIdling(float fpsIdle = 9.f, bool enableIdling = true, bool isIdling = false, bool rememberEnableIdling = true);    /* original C++ signature */
    def __init__(
        self,
        fps_idle: float = 9.0,
        enable_idling: bool = True,
        is_idling: bool = False,
        remember_enable_idling: bool = True,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

class RunnerParams:
    """@@md#RunnerParams

    RunnerParams contains the settings and callbacks needed to run an application.

    """

    # --------------- Callbacks and Window params -------------------

    # RunnerCallbacks callbacks;    /* original C++ signature */
    # `callbacks`: _see runner_callbacks.h_
    # callbacks.ShowGui() will render the gui, ShowMenus() will show the menus, etc.
    callbacks: RunnerCallbacks

    # AppWindowParams appWindowParams;    /* original C++ signature */
    # `appWindowParams`: _see app_window_params.h_
    # application Window Params (position, size, title)
    app_window_params: AppWindowParams

    # ImGuiWindowParams imGuiWindowParams;    /* original C++ signature */
    # `imGuiWindowParams`: _see imgui_window_params.h_
    # imgui window params (use docking, showMenuBar, ProvideFullScreenWindow, etc.)
    imgui_window_params: ImGuiWindowParams

    # --------------- Docking -------------------

    # DockingParams dockingParams;    /* original C++ signature */
    # `dockingParams`: _see docking_params.h_
    # dockable windows content and layout
    docking_params: DockingParams

    # std::vector<DockingParams> alternativeDockingLayouts;    /* original C++ signature */
    # `alternativeDockingLayouts`: _vector<DockingParams>, default=empty_
    # List of possible additional layout for the applications. Only used in advanced
    # cases when several layouts are available.
    alternative_docking_layouts: List[DockingParams]

    # bool rememberSelectedAlternativeLayout = true;    /* original C++ signature */
    # `rememberSelectedAlternativeLayout`: _bool, default=true_
    # Shall the application remember the last selected layout. Only used in advanced
    # cases when several layouts are available.
    remember_selected_alternative_layout: bool = True

    # --------------- Backends -------------------

    # BackendPointers backendPointers;    /* original C++ signature */
    # `backendPointers`: _see backend_pointers.h_
    # A struct that contains optional pointers to the backend implementations.
    # These pointers will be filled when the application starts
    backend_pointers: BackendPointers
    # BackendType backendType = BackendType::FirstAvailable;    /* original C++ signature */
    # `backendType`: _enum BackendType, default=BackendType::FirstAvailable_
    # Select the wanted platform backend type between `Sdl`, `Glfw`.
    # Only useful when multiple backend are compiled and available.
    backend_type: BackendType = BackendType.first_available

    # --------------- Settings -------------------

    # IniFolderType iniFolderType = IniFolderType::CurrentFolder;    /* original C++ signature */
    # `iniFolderType`: _IniFolderType, default = IniFolderType::CurrentFolder_
    # Sets the folder where imgui will save its params.
    # (possible values are:
    #     CurrentFolder, AppUserConfigFolder, DocumentsFolder,
    #     HomeFolder, TempFolder, AppExecutableFolder)
    # AppUserConfigFolder is
    #     [Home]/AppData/Roaming under Windows,
    #     ~/.config under Linux,
    #     ~/Library/Application Support under macOS
    ini_folder_type: IniFolderType = IniFolderType.current_folder
    # `iniFilename`: _string, default = ""_
    # Sets the ini filename under which imgui will save its params.
    # Its path is relative to the path given by iniFolderType, and can include
    # a subfolder (which will be created if needed).
    # If iniFilename empty, then it will be derived from
    # appWindowParams.windowTitle
    # (if both are empty, the ini filename will be imgui.ini).
    # std::string iniFilename = "";    /* original C++ signature */
    ini_filename: str = ""  # relative to iniFolderType
    # bool iniFilename_useAppWindowTitle = true;    /* original C++ signature */
    # `iniFilename_useAppWindowTitle`: _bool, default = true_.
    # Shall the iniFilename be derived from appWindowParams.windowTitle (if not empty)
    ini_filename_use_app_window_title: bool = True

    # --------------- Exit -------------------

    # bool appShallExit = false;    /* original C++ signature */
    # * `appShallExit`: _bool, default=false_.
    # During execution, set this to True to exit the app.
    # _Note: 'appShallExit' has no effect on Mobile Devices (iOS, Android)
    # and under emscripten, since these apps shall not exit._
    app_shall_exit: bool = False

    # --------------- Idling -------------------

    # FpsIdling fpsIdling;    /* original C++ signature */
    # `fpsIdling`: _FpsIdling_. Idling parameters
    # (set fpsIdling.enableIdling to False to disable Idling)
    fps_idling: FpsIdling

    # --------------- Misc -------------------

    # bool useImGuiTestEngine = false;    /* original C++ signature */
    # `useImGuiTestEngine`: _bool, default=false_.
    # Set this to True if you intend to use Dear ImGui Test & Automation Engine
    #     ( https://github.com/ocornut/imgui_test_engine )
    # HelloImGui must be compiled with the option -DHELLOIMGUI_WITH_TEST_ENGINE=ON
    # See demo in src/hello_imgui_demos/hello_imgui_demo_test_engine.
    # License:
    # imgui_test_engine is subject to a specific license:
    #     https://github.com/ocornut/imgui_test_engine/blob/main/imgui_test_engine/LICENSE.txt)
    # (TL;DR: free for individuals, educational, open-source and small businesses uses.
    #  Paid for larger businesses.)
    use_imgui_test_engine: bool = False

    # int emscripten_fps = 0;    /* original C++ signature */
    # `emscripten_fps`: _int, default = 0_.
    # Set the application refresh rate
    # (only used on emscripten: 0 stands for "let the app or the browser decide")
    emscripten_fps: int = 0
    # RunnerParams(RunnerCallbacks callbacks = RunnerCallbacks(), AppWindowParams appWindowParams = AppWindowParams(), ImGuiWindowParams imGuiWindowParams = ImGuiWindowParams(), DockingParams dockingParams = DockingParams(), std::vector<DockingParams> alternativeDockingLayouts = std::vector<DockingParams>(), bool rememberSelectedAlternativeLayout = true, BackendPointers backendPointers = BackendPointers(), BackendType backendType = BackendType::FirstAvailable, IniFolderType iniFolderType = IniFolderType::CurrentFolder, std::string iniFilename = "", bool iniFilename_useAppWindowTitle = true, bool appShallExit = false, FpsIdling fpsIdling = FpsIdling(), bool useImGuiTestEngine = false, int emscripten_fps = 0);    /* original C++ signature */
    def __init__(
        self,
        callbacks: RunnerCallbacks = RunnerCallbacks(),
        app_window_params: AppWindowParams = AppWindowParams(),
        imgui_window_params: ImGuiWindowParams = ImGuiWindowParams(),
        docking_params: DockingParams = DockingParams(),
        alternative_docking_layouts: List[DockingParams] = List[DockingParams](),
        remember_selected_alternative_layout: bool = True,
        backend_pointers: BackendPointers = BackendPointers(),
        backend_type: BackendType = BackendType.first_available,
        ini_folder_type: IniFolderType = IniFolderType.current_folder,
        ini_filename: str = "",
        ini_filename_use_app_window_title: bool = True,
        app_shall_exit: bool = False,
        fps_idling: FpsIdling = FpsIdling(),
        use_imgui_test_engine: bool = False,
        emscripten_fps: int = 0,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

# @@md#IniIniSettingsLocation

# std::string IniSettingsLocation(const RunnerParams& runnerParams);    /* original C++ signature */
def ini_settings_location(runner_params: RunnerParams) -> str:
    """IniSettingsLocation returns the path to the ini file for the application settings."""
    pass

# bool HasIniSettings(const RunnerParams& runnerParams);    /* original C++ signature */
def has_ini_settings(runner_params: RunnerParams) -> bool:
    """HasIniSettings returns True if the ini file for the application settings exists."""
    pass

# void DeleteIniSettings(const RunnerParams& runnerParams);    /* original C++ signature */
def delete_ini_settings(runner_params: RunnerParams) -> None:
    """DeleteIniSettings deletes the ini file for the application settings."""
    pass

# @@md

class SimpleRunnerParams:
    """@@md#SimpleRunnerParams

     SimpleRunnerParams is a struct that contains simpler params adapted for simple use cases.
    For example, this is sufficient to run an application:
        ```cpp
        None MyGui() {
            ImGui::Text("Hello, world");
            if (ImGui::Button("Exit"))
                HelloImGui::GetRunnerParams()->appShallExit = True;
        }

        int main(){
            auto params = HelloImGui::SimpleRunnerParams {
                .guiFunction = MyGui, .windowSizeAuto = True, .windowTitle = "Example"
            };
            HelloImGui::Run(params);
        }
        ```
    """

    # VoidFunction guiFunction = EmptyVoidFunction();    /* original C++ signature */
    # `guiFunction`: _VoidFunction_.
    #  Function that renders the Gui.
    gui_function: VoidFunction = EmptyVoidFunction()
    # std::string windowTitle = "";    /* original C++ signature */
    # `windowTitle`: _string, default=""_.
    #  Title of the application window
    window_title: str = ""

    # bool windowSizeAuto = false;    /* original C++ signature */
    # `windowSizeAuto`: _bool, default=false_.
    #  If True, the size of the window will be computed from its widgets.
    window_size_auto: bool = False

    # bool windowRestorePreviousGeometry = false;    /* original C++ signature */
    # `windowRestorePreviousGeometry`: _bool, default=true_.
    #  If True, restore the size and position of the window between runs.
    window_restore_previous_geometry: bool = False

    # ScreenSize windowSize = DefaultWindowSize;    /* original C++ signature */
    # `windowSize`: _ScreenSize, default={800, 600}_.
    #  Size of the window
    window_size: ScreenSize = DefaultWindowSize

    # float fpsIdle = 9.f;    /* original C++ signature */
    # `fpsIdle`: _float, default=9_.
    #  FPS of the application when idle (set to 0 for full speed).
    fps_idle: float = 9.0

    # bool  enableIdling = true;    /* original C++ signature */
    # `enableIdling`: _bool, default=true_.
    #  Set this to False to disable idling at startup
    enable_idling: bool = True

    # RunnerParams ToRunnerParams() const;    /* original C++ signature */
    def to_runner_params(self) -> RunnerParams:
        pass
    # SimpleRunnerParams(VoidFunction guiFunction = EmptyVoidFunction(), std::string windowTitle = "", bool windowSizeAuto = false, bool windowRestorePreviousGeometry = false, ScreenSize windowSize = DefaultWindowSize, float fpsIdle = 9.f, bool enableIdling = true);    /* original C++ signature */
    def __init__(
        self,
        gui_function: VoidFunction = EmptyVoidFunction(),
        window_title: str = "",
        window_size_auto: bool = False,
        window_restore_previous_geometry: bool = False,
        window_size: ScreenSize = DefaultWindowSize,
        fps_idle: float = 9.0,
        enable_idling: bool = True,
    ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# @@md

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_widgets.h included by hello_imgui.h                            //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Some additional widgets and utilities for ImGui

# void BeginGroupColumn();     /* original C++ signature */
def begin_group_column() -> None:
    """calls ImGui::BeginGroup()"""
    pass

# void EndGroupColumn();       /* original C++ signature */
def end_group_column() -> None:
    """calls ImGui::EndGroup() + ImGui::SameLine()"""
    pass

# ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui.h continued                                                                //
# //////////////////////////////////////////////////////////////////////////////////////////////////////////////

# =========================== HelloImGui::Run ==================================
# *
# @@md#HelloImGui::Run
#
# __HelloImGui::Run()__ will run an application with a single call.
#
# Three signatures are provided:
#
# * `HelloImGui::Run(RunnerParams &)`: full signature, the most customizable version.
#  Runs an application whose params and Gui are provided by runnerParams.
#
# * `HelloImGui::Run(const SimpleRunnerParams&)`:
#  Runs an application, using simpler params.
#
# * `HelloImGui::Run(guiFunction, windowTitle, windowSize, windowSizeAuto=False, restoreLastWindowGeometry=False, fpsIdle=10)`
#  Runs an application, by providing the Gui function, the window title, etc.
#
# Although the API is extremely simple, it is highly customizable, and you can set many options by filling
# the elements in the `RunnerParams` struct, or in the simpler  `SimpleRunnerParams`.
#
# __HelloImGui::GetRunnerParams()__  will return the runnerParams of the current application.
#
# @@md
#

# void Run(RunnerParams &runnerParams);    /* original C++ signature */
@overload
def run(runner_params: RunnerParams) -> None:
    """`HelloImGui::Run(RunnerParams &)`: full signature, the most customizable version.
    Runs an application whose params and Gui are provided by runnerParams.
    """
    pass

# void Run(const SimpleRunnerParams &simpleParams);    /* original C++ signature */
@overload
def run(simple_params: SimpleRunnerParams) -> None:
    """`HelloImGui::Run(const SimpleRunnerParams&)`:
    Runs an application, using simpler params.
    """
    pass

# void Run(    /* original C++ signature */
#     const VoidFunction &guiFunction,
#     const std::string &windowTitle = "",
#     bool windowSizeAuto = false,
#     bool windowRestorePreviousGeometry = false,
#     const ScreenSize &windowSize = DefaultWindowSize,
#     float fpsIdle = 10.f
# );
@overload
def run(
    gui_function: VoidFunction,
    window_title: str = "",
    window_size_auto: bool = False,
    window_restore_previous_geometry: bool = False,
    window_size: ScreenSize = DefaultWindowSize,
    fps_idle: float = 10.0,
) -> None:
    """Runs an application, by providing the Gui function, the window title, etc."""
    pass

# RunnerParams* GetRunnerParams();    /* original C++ signature */
def get_runner_params() -> RunnerParams:
    """`GetRunnerParams()`:  a convenience function that will return the runnerParams
    of the current application
    """
    pass

# ============================== Utility functions ===============================

# @@md#UtilityFunctions

# float FrameRate(float durationForMean = 0.5f);    /* original C++ signature */
def frame_rate(duration_for_mean: float = 0.5) -> float:
    """`FrameRate(durationForMean = 0.5)`: Returns the current FrameRate.
    May differ from ImGui::GetIO().FrameRate, since one can choose the duration
    for the calculation of the mean value of the fps
    Returns the current FrameRate. May differ from ImGui::GetIO().FrameRate,
    since one can choose the duration for the calculation of the mean value of the fps
    (Will only lead to accurate values if you call it at each frame)
    """
    pass

# ImGuiTestEngine* GetImGuiTestEngine();    /* original C++ signature */
def get_imgui_test_engine() -> ImGuiTestEngine:
    """`ImGuiTestEngine* GetImGuiTestEngine()`: returns a pointer to the global instance
    of ImGuiTestEngine that was initialized by HelloImGui
    (iif ImGui Test Engine is active).
    """
    pass

# @@md

# ============================== Layout Utils =============================

# @@md#HelloImGui::Layouts

# In advanced cases when several layouts are available, you can switch between layouts.
# See demo inside
#     https://github.com/pthom/hello_imgui/tree/master/src/hello_imgui_demos/hello_imgui_demodocking/hello_imgui_demodocking.main.cpp

# void           SwitchLayout(const std::string& layoutName);    /* original C++ signature */
def switch_layout(layout_name: str) -> None:
    """`SwitchLayout(layoutName)`
    Changes the application current layout. Only used in advanced cases
    when several layouts are available, i.e. if you filled
        runnerParams.alternativeDockingLayouts.
    """
    pass

# std::string    CurrentLayoutName();    /* original C++ signature */
def current_layout_name() -> str:
    """`CurrentLayoutName()`: returns the name of the current layout"""
    pass

# @@md

# ============================== User prefs Utils =============================

# @@md#HelloImGui::UserPref

# You may store additional user settings in the application settings.
# This is provided as a convenience only, and it is not intended to store large
# quantities of text data. Use sparingly.

# void        SaveUserPref(const std::string& userPrefName, const std::string& userPrefContent);    /* original C++ signature */
def save_user_pref(user_pref_name: str, user_pref_content: str) -> None:
    """`SaveUserPref(string userPrefName, string userPrefContent)`:
    Shall be called in the callback runnerParams.callbacks.BeforeExit
    """
    pass

# std::string LoadUserPref(const std::string& userPrefName);    /* original C++ signature */
def load_user_pref(user_pref_name: str) -> str:
    """`string LoadUserPref(string& userPrefName)`
    Shall be called in the callback runnerParams.callbacks.PostInit
    """
    pass

# @@md

# ============================== Menus defaults =============================

# *
# @@md#MenuIntro
#
# Hello ImGui provides a default menu and status bar, which you can customize by using the params:
#        `RunnerParams.imGuiWindowParams.` `showMenuBar` / `showMenu_App` / `showMenu_View`
#
# If you want to fully customize the menu:
# * set `showMenuBar` to True, then set `showMenu_App` and `showMenu_View` params to False
# * implement the callback `RunnerParams.callbacks.ShowMenus`:
#  it can optionally call `ShowViewMenu` and `ShowAppMenu` (see below).
#
# @@md
#
# @@md#MenuFunctions

# void ShowViewMenu(RunnerParams & runnerParams);    /* original C++ signature */
def show_view_menu(runner_params: RunnerParams) -> None:
    """`ShowViewMenu(RunnerParams & runnerParams)`:
    shows the View menu (where you can select the layout and docked windows visibility
    """
    pass

# void ShowAppMenu(RunnerParams & runnerParams);    /* original C++ signature */
def show_app_menu(runner_params: RunnerParams) -> None:
    """`ShowAppMenu(RunnerParams & runnerParams)`:
    shows the default App menu (including the Quit item)
    """
    pass

# @@md

# <submodule imgui_default_settings>
class imgui_default_settings:  # Proxy class that introduces typings for the *submodule* imgui_default_settings
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace ImGuiDefaultSettings"""
    # void LoadDefaultFont_WithFontAwesomeIcons();    /* original C++ signature */
    @staticmethod
    def load_default_font_with_font_awesome_icons() -> None:
        """LoadDefaultFont_WithFontAwesome will load from assets/fonts and reverts to the imgui embedded font if not found."""
        pass
    # void SetupDefaultImGuiConfig();    /* original C++ signature */
    @staticmethod
    def setup_default_imgui_config() -> None:
        pass
    # void SetupDefaultImGuiStyle();    /* original C++ signature */
    #     }
    @staticmethod
    def setup_default_imgui_style() -> None:
        pass

# </submodule imgui_default_settings>
####################    </generated_from:hello_imgui_amalgamation.h>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

def final_app_window_screenshot() -> np.ndarray:
    """Return a screenshot of the final screen of the last (exited) app"""
    pass
