"""Hello, Dear ImGui: cross-platform Gui apps for Windows / Mac / Linux / iOS / Android / Emscripten with the simplicity of a "Hello World" app
https://github.com/pthom/hello_imgui
"""

from typing import List, Any, Callable, Tuple, Optional
import numpy as np
import enum

# Manual code
import imgui_bundle.imgui
ImGuiID = int

DockSpaceName = str
from imgui_bundle.imgui import (
    ImVec2, ImVec4,
    ImFontConfig, ImFont,
    ImTextureID,
    Dir_,
    Cond_,
)

VoidFunction = Callable[[], None]
AnyEventCallback = Callable[[Any], None]
ScreenSize = Tuple[int, int]
ScreenPosition = Tuple[int, int]
ImGuiCond_FirstUseEver = Cond_.first_use_ever

DefaultScreenSize = (800, 600)
DefaultWindowSize = (800, 600)
DefaultScreenPosition = (40, 40)

ImGuiCond = imgui_bundle.imgui.Cond
ImGuiDir_Down = Dir_.down
ImGuiTheme = imgui_bundle.hello_imgui
ImGuiStyle = imgui_bundle.imgui.Style
ImGuiDir_ = imgui_bundle.imgui.Dir_
ImGuiWindowFlags = imgui_bundle.imgui.WindowFlags


def EmptyVoidFunction() -> VoidFunction:
    pass


def EmptyEventCallback() -> AnyEventCallback:
    pass


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:hello_imgui_amalgamation.h>    ####################
# THIS FILE WAS GENERATED AUTOMATICALLY. DO NOT EDIT.

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui.h                                                                          //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#*
#@@md#AssetsStructure
#
#Assets located beside the application CMakeLists are embedded automatically.
#
#For example, you can have the following project structure:
#```
#my_app/
#├── CMakeLists.txt        # Your app's CMakeLists
#├── assets/               # Its assets: for mobile devices and emscripten
#│         └── fonts/            # they are embedded automatically by hello_imgui_add_app.cmake
#│             └── my_font.ttf
#├── my_app.main.cpp       # Its source code
#```
#
#Then you can load the asset "fonts/my_font.ttf", on all platforms.
#
#@@md
#


class AssetFileData:
    """*
    @@md#LoadAssetFileData

    * `AssetFileData LoadAssetFileData(const char *assetPath)` will load an entire asset file into memory.
     This works on all platforms, including android.
     ```cpp
        struct AssetFileData
        {
            None * data = None;
            size_t dataSize = 0;
        };
     ```
    * `FreeAssetFileData(AssetFileData * assetFileData)` will free the memory.

      Note about ImGui: "ImGui::GetIO().Fonts->AddFontFromMemoryTTF" takes ownership of the data
      and will free the memory for you.

    @@md
    *
    """
    # void * data = nullptr;    /* original C++ signature */
    data: Any = None
    # size_t dataSize = 0;    /* original C++ signature */
    data_size: int = 0
    # AssetFileData(size_t dataSize = 0);    /* original C++ signature */
    def __init__(self, data_size: int = 0) -> None:
        """Auto-generated default constructor with named params"""
        pass

# AssetFileData LoadAssetFileData(const char *assetPath);    /* original C++ signature */
def load_asset_file_data(asset_path: str) -> AssetFileData:
    pass
# void FreeAssetFileData(AssetFileData * assetFileData);    /* original C++ signature */
def free_asset_file_data(asset_file_data: AssetFileData) -> None:
    pass



# std::string AssetFileFullPath(const std::string& assetRelativeFilename);    /* original C++ signature */
def asset_file_full_path(asset_relative_filename: str) -> str:
    """*
    @@md#assetFileFullPath

    `std::string AssetFileFullPath(const std::string& assetRelativeFilename)` will return the path to assets.

    This works under all platforms __except Android__.
    For compatibility with Android and other platforms, prefer to use `LoadAssetFileData` whenever possible.

    * Under iOS it will give a path in the app bundle (/private/XXX/....)
    * Under emscripten, it will be stored in the virtual filesystem at "/"
    * Under Android, assetFileFullPath is *not* implemented, and will throw an error:
      assets can be compressed under android, and you cannot use standard file operations!
      Use LoadAssetFileData instead

    @@md

    """
    pass
# inline std::string assetFileFullPath(const std::string& assetRelativeFilename) { return AssetFileFullPath(assetRelativeFilename); }    /* original C++ signature */
def asset_file_full_path(asset_relative_filename: str) -> str:
    pass

# bool AssetExists(const std::string& assetRelativeFilename);    /* original C++ signature */
def asset_exists(asset_relative_filename: str) -> bool:
    """ Returns True if this asset file exists"""
    pass


# Sets the assets folder location
# (when using this, automatic assets installation on mobile platforms may not work)
# void SetAssetsFolder(const char* folder);    /* original C++ signature */
def set_assets_folder(folder: str) -> None:
    pass
# void SetAssetsFolder(const std::string& folder);    /* original C++ signature */
def set_assets_folder(folder: str) -> None:
    pass
# void overrideAssetsFolder(const char* folder);     /* original C++ signature */
def override_assets_folder(folder: str) -> None:
    """ synonym"""
    pass


# namespace HelloImGui

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_error.h included by hello_imgui.h                              //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////




#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/icons_font_awesome.h included by hello_imgui.h                             //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Generated by https://github.com/juliettef/IconFontCppHeaders script
# GenerateIconFontCppHeaders.py for language C89 from
# https://raw.githubusercontent.com/FortAwesome/Font-Awesome/master/metadata/icons.yml
# for use with
# https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-solid-900.ttf,
# https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-regular-400.ttf,


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/image_gl.h included by hello_imgui.h                                       //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/image_from_asset.h included by hello_imgui.h                               //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#*
#@@md#HelloImGui::ImageFromAsset
#
#* `HelloImGui::ImageFromAsset(const char *assetPath, size, ...)`: will display a static image from the assets.
#* `bool HelloImGui::ImageButtonFromAsset(const char *assetPath, size, ...)`: will display a button using an image from the assets.
#* `ImTextureID HelloImGui::ImTextureIdFromAsset(const char *assetPath)`: will return a texture ID for an image loaded from the assets.
#
#Images are loaded when first displayed, and then cached (they will be freed just before the application exits).
#
#For example, given this files structure:
#```
#├── CMakeLists.txt
#├── assets/
#│   └── my_image.jpg
#└── my_app.main.cpp
#```
#
#then, you can display "my_image.jpg", using:
#
#```cpp
#HelloImGui::ImageFromAsset("my_image.jpg");
#```
#
#*Note: HelloImGui::ImageFromAsset only works with OpenGL backends. It will throw an exception on other backends*
#
#@@md
#

# void ImageFromAsset(const char *assetPath, const ImVec2& size = ImVec2(0, 0), const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));    /* original C++ signature */
def image_from_asset(
    asset_path: str,
    size: ImVec2 = ImVec2(0, 0),
    uv0: ImVec2 = ImVec2(0, 0),
    uv1: ImVec2 = ImVec2(1,1),
    tint_col: ImVec4 = ImVec4(1,1,1,1),
    border_col: ImVec4 = ImVec4(0,0,0,0)
    ) -> None:
    pass
# bool ImageButtonFromAsset(const char *assetPath, const ImVec2& size = ImVec2(0, 0), const ImVec2& uv0 = ImVec2(0, 0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    /* original C++ signature */
def image_button_from_asset(
    asset_path: str,
    size: ImVec2 = ImVec2(0, 0),
    uv0: ImVec2 = ImVec2(0, 0),
    uv1: ImVec2 = ImVec2(1,1),
    frame_padding: int = -1,
    bg_col: ImVec4 = ImVec4(0,0,0,0),
    tint_col: ImVec4 = ImVec4(1,1,1,1)
    ) -> bool:
    pass
# ImTextureID ImTextureIdFromAsset(const char *assetPath);    /* original C++ signature */
def im_texture_id_from_asset(asset_path: str) -> ImTextureID:
    pass



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_params.h included by hello_imgui.h                                  //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/app_window_params.h included by hello_imgui/runner_params.h                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/screen_bounds.h included by hello_imgui/app_window_params.h                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////





""" namespace BackendApi"""

# Note: note related to DPI and high resolution screens:
# ScreenPosition and ScreenSize are in "Screen Coordinates":
# Screen coordinates *might* differ from real pixel on high dpi screens; but this depends on the OS.
# - For example, on apple a retina screenpixel size 3456x2052 might be seen as 1728x1026 in screen coordinates
# - Under windows, ScreenCoordinates correspond to pixels, even on high density screens

class ScreenBounds:
    # ScreenPosition position = DefaultScreenPosition;    /* original C++ signature */
    position: ScreenPosition = DefaultScreenPosition
    # ScreenSize size = DefaultWindowSize;    /* original C++ signature */
    size: ScreenSize = DefaultWindowSize

    # ScreenPosition TopLeftCorner() const{ return position; }    /* original C++ signature */
    def top_left_corner(self) -> ScreenPosition:
        pass
    # ScreenPosition BottomRightCorner() const{ return { position[0] + size[0], position[1] + size[1] }; }    /* original C++ signature */
    def bottom_right_corner(self) -> ScreenPosition:
        pass
    # ScreenPosition Center() const{ return { position[0] + size[0] / 2, position[1] + size[1] / 2 }; }    /* original C++ signature */
    def center(self) -> ScreenPosition:
        pass

    # bool Contains(ScreenPosition pixel) const;    /* original C++ signature */
    def contains(self, pixel: ScreenPosition) -> bool:
        pass
    # ScreenPosition WinPositionCentered(ScreenSize windowSize) const;    /* original C++ signature */
    def win_position_centered(self, window_size: ScreenSize) -> ScreenPosition:
        pass
    # int DistanceFromPixel(ScreenPosition point) const;    /* original C++ signature */
    def distance_from_pixel(self, point: ScreenPosition) -> int:
        pass
    # ScreenBounds EnsureWindowFitsThisMonitor(ScreenBounds windowBoundsOriginal) const;    /* original C++ signature */
    def ensure_window_fits_this_monitor(
        self,
        window_bounds_original: HelloImGui.ScreenBounds
        ) -> HelloImGui.ScreenBounds:
        pass
    # bool operator==(const ScreenBounds& other) const;    /* original C++ signature */
    def __eq__(self, other: HelloImGui.ScreenBounds) -> bool:
        pass
    # ScreenBounds(ScreenPosition position = DefaultScreenPosition, ScreenSize size = DefaultWindowSize);    /* original C++ signature */
    def __init__(
        self,
        position: ScreenPosition = DefaultScreenPosition,
        size: ScreenSize = DefaultWindowSize
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass


# std::string IntPairToString(std::array<int, 2> v);    /* original C++ signature */
def int_pair_to_string(v: List[int]) -> str:
    pass
# std::optional<std::array<int, 2>> StringToIntPair(const std::string& s);    /* original C++ signature */
def string_to_int_pair(s: str) -> Optional[List[int]]:
    pass



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/app_window_params.h continued                                              //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////




class FullScreenMode(enum.Enum):
    # NoFullScreen,    /* original C++ signature */
    no_full_screen = enum.auto()                 # (= 0)
    # FullScreen,                        /* original C++ signature */
    full_screen = enum.auto()                    # (= 1)  # Full screen with specified resolution
    # FullScreenDesktopResolution,       /* original C++ signature */
    full_screen_desktop_resolution = enum.auto() # (= 2)  # Full screen with current desktop mode & resolution
    # FullMonitorWorkArea                /* original C++ signature */
    full_monitor_work_area = enum.auto()         # (= 3)  # Fake full screen, maximized window on the selected monitor


class WindowSizeState(enum.Enum):
    # Standard,    /* original C++ signature */
    standard = enum.auto()  # (= 0)
    # Minimized,    /* original C++ signature */
    minimized = enum.auto() # (= 1)
    # Maximized    /* original C++ signature */
    # }
    maximized = enum.auto() # (= 2)


class WindowPositionMode(enum.Enum):
    # OsDefault,    /* original C++ signature */
    os_default = enum.auto()     # (= 0)
    # MonitorCenter,    /* original C++ signature */
    monitor_center = enum.auto() # (= 1)
    # FromCoords,    /* original C++ signature */
    # }
    from_coords = enum.auto()    # (= 2)


class WindowSizeMeasureMode(enum.Enum):
    # ScreenCoords,    /* original C++ signature */
    # ScreenCoords: measure window size in screen coords.
    #     Note: screen coordinates *might* differ from real pixel on high dpi screens; but this depends on the OS.
    #         - For example, on apple a retina screenpixel size 3456x2052 might be seen as 1728x1026 in screen
    #           coordinates
    #         - Under windows, and if the application is DPI aware, ScreenCoordinates correspond to real pixels,
    #           even on high density screens
    screen_coords = enum.auto()     # (= 0)

    # RelativeTo96Ppi    /* original C++ signature */
    # }
    # RelativeTo96Ppi enables to give screen size that are independant from the screen density.
    # For example, a window size expressed as 800x600 will correspond to a size
    #    800x600 (in screen coords) if the monitor dpi is 96
    #    1600x120 (in screen coords) if the monitor dpi is 192
    relative_to96_ppi = enum.auto() # (= 1)


class WindowGeometry:
    """*
    @@md#WindowGeometry

    __WindowGeometry__ is a struct that defines the window geometry.

    Members:
    * `size`: _int[2], default="{800, 600}"_. Size of the application window
      used if fullScreenMode==NoFullScreen and sizeAuto==False
    * `sizeAuto`: _bool, default=false_
      If True, adapt the app window size to the presented widgets.
      After the first frame was displayed, HelloImGui will measure its size,
      and the backend application window will be resized. As a consequence, the application window size may
      vary between the first and the second frame.

    * `fullScreenMode`: _FullScreenMode, default=NoFullScreen_.
       You can choose between several full screen modes:
       ```cpp
            NoFullScreen,
            FullScreen,                    // Full screen with specified resolution
            FullScreenDesktopResolution,   // Full screen with current desktop mode & resolution
            FullMonitorWorkArea            // Fake full screen, maximized window on the selected monitor
        ```
    * `positionMode`: _WindowPositionMode, default = OsDefault_.
       You can choose between several window position modes:
       ```cpp
            OsDefault,
            MonitorCenter,
            FromCoords,
        ```
    * `monitorIdx`: _int, default = 0_.
      used if positionMode==MonitorCenter or if fullScreenMode!=NoFullScreen
    * `windowSizeState`: _WindowSizeState, default=Standard_
       You can choose between several window size states:
       ```cpp
            Standard,
            Minimized,
            Maximized
        ```
    * `windowSizeMeasureMode`: _WindowSizeMeasureMode_, default=RelativeTo96Ppi
      how the window size is specified:
      * RelativeTo96Ppi enables to give screen size that are independant from the screen density.
         For example, a window size expressed as 800x600 will correspond to a size
            - 800x600 (in screen coords) if the monitor dpi is 96
            - 1600x120 (in screen coords) if the monitor dpi is 192
          (this works with Glfw. With SDL, it only works under windows)
      * ScreenCoords: measure window size in screen coords
        (Note: screen coordinates might differ from real pixels on high dpi screen)

    * `resizeAppWindowAtNextFrame`: _bool_, default=False;
      If you set this to flag to True at any point during the execution, the application window
      will then try to resize based on its content on the next displayed frame,
      and this flag will subsequently be set to False.
      Example:
      ```cpp
      // Will resize the app window at next displayed frame
      HelloImGui::GetRunnerParams()->appWindowParams.windowGeometry.resizeAppWindowAtNextFrame = True;
      ```

      :::Note: this flag is intended to be used during execution, not at startup (use sizeAuto at startup):::
    @@md
    *
    """
    # ScreenSize size = DefaultWindowSize;    /* original C++ signature */
    # used if fullScreenMode==NoFullScreen and sizeAuto==False. Value=(800, 600)
    size: ScreenSize = DefaultWindowSize

    # bool sizeAuto = false;    /* original C++ signature */
    # If True, adapt the app window size to the presented widgets. This is done at startup
    size_auto: bool = False

    # FullScreenMode fullScreenMode = FullScreenMode::NoFullScreen;    /* original C++ signature */
    full_screen_mode: FullScreenMode = FullScreenMode.no_full_screen

    # WindowPositionMode positionMode = WindowPositionMode::OsDefault;    /* original C++ signature */
    position_mode: WindowPositionMode = WindowPositionMode.os_default

    # ScreenPosition position = DefaultScreenPosition;    /* original C++ signature */
    # used if windowPositionMode==FromCoords, default=(40, 40)
    position: ScreenPosition = DefaultScreenPosition

    # int monitorIdx = 0;    /* original C++ signature */
    # used if positionMode==MonitorCenter or if fullScreenMode!=NoFullScreen
    monitor_idx: int = 0

    # WindowSizeState windowSizeState = WindowSizeState::Standard;    /* original C++ signature */
    window_size_state: WindowSizeState = WindowSizeState.standard

    # WindowSizeMeasureMode windowSizeMeasureMode = WindowSizeMeasureMode::RelativeTo96Ppi;    /* original C++ signature */
    window_size_measure_mode: WindowSizeMeasureMode = WindowSizeMeasureMode.relative_to96_ppi

    # bool resizeAppWindowAtNextFrame = false;    /* original C++ signature */
    # If True, the application window will try to resize based on its content on the next displayed frame
    resize_app_window_at_next_frame: bool = False
    # WindowGeometry(ScreenSize size = DefaultWindowSize, bool sizeAuto = false, FullScreenMode fullScreenMode = FullScreenMode::NoFullScreen, WindowPositionMode positionMode = WindowPositionMode::OsDefault, ScreenPosition position = DefaultScreenPosition, int monitorIdx = 0, WindowSizeState windowSizeState = WindowSizeState::Standard, WindowSizeMeasureMode windowSizeMeasureMode = WindowSizeMeasureMode::RelativeTo96Ppi, bool resizeAppWindowAtNextFrame = false);    /* original C++ signature */
    def __init__(
        self,
        size: ScreenSize = DefaultWindowSize,
        size_auto: bool = False,
        full_screen_mode: FullScreenMode = FullScreenMode.no_full_screen,
        position_mode: WindowPositionMode = WindowPositionMode.os_default,
        position: ScreenPosition = DefaultScreenPosition,
        monitor_idx: int = 0,
        window_size_state: WindowSizeState = WindowSizeState.standard,
        window_size_measure_mode: WindowSizeMeasureMode = WindowSizeMeasureMode.relative_to96_ppi,
        resize_app_window_at_next_frame: bool = False
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass


class AppWindowParams:
    """*
    @@md#AppWindowParams

    __AppWindowParams__ is a struct that defines the application window display params.
    See [doc_src/hello_imgui_diagram.png](https://raw.githubusercontent.com/pthom/hello_imgui/master/src/hello_imgui/doc_src/hello_imgui_diagram.png)
    for details.

    Members:
    * `windowTitle`: _string, default=""_. Title of the application window
    * `windowGeometry`: _WindowGeometry_
      Enables to precisely set the window geometry (position, monitor, size, full screen, fake full screen, etc.)
       _Note: on a mobile device, the application will always be full screen._
    * `restorePreviousGeometry`: _bool, default=false_.
      If True, then save & restore windowGeometry from last run (the geometry will be written in imgui_app_window.ini)
    * `borderless`: _bool, default = false_. Should the window have borders. This is taken into account at
    creation.
    * `resizable`: _bool, default = false_. Should the window have borders. This is taken into account at
    creation.
    * `hidden`: _bool, default = false_. Should the window be hidden. This is taken into account dynamically (you
    can show/hide the window with this). Full screen windows cannot be hidden.@@md
    *
    """
    # std::string windowTitle;    /* original C++ signature */
    window_title: str

    # WindowGeometry windowGeometry;    /* original C++ signature */
    window_geometry: WindowGeometry

    # bool restorePreviousGeometry = false;    /* original C++ signature */
    # if True, then save & restore from last run
    restore_previous_geometry: bool = False

    # bool borderless = false;    /* original C++ signature */
    borderless: bool = False
    # bool resizable = true;    /* original C++ signature */
    resizable: bool = True
    # bool hidden = false;    /* original C++ signature */
    hidden: bool = False
    # AppWindowParams(std::string windowTitle = std::string(), WindowGeometry windowGeometry = WindowGeometry(), bool restorePreviousGeometry = false, bool borderless = false, bool resizable = true, bool hidden = false);    /* original C++ signature */
    def __init__(
        self,
        window_title: str = "",
        window_geometry: WindowGeometry = WindowGeometry(),
        restore_previous_geometry: bool = False,
        borderless: bool = False,
        resizable: bool = True,
        hidden: bool = False
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_theme.h included by hello_imgui/imgui_window_params.h                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# Theme tweak utilities for ImGui.
# Reuse and adaptation of imgui_theme.h and imgui_theme.cpp file is granted for other projects,
# provided the origin of those files is stated in the copied version
# Some themes were adapted by themes posted by ImGui users at https://github.com/ocornut/imgui/issues/707
#

""" namespace ImGuiTheme"""
class ImGuiTheme_(enum.Enum):
    # ImGuiTheme_ImGuiColorsClassic = 0,    /* original C++ signature */
    imgui_colors_classic = enum.auto()   # (= 0)
    # ImGuiTheme_ImGuiColorsDark,    /* original C++ signature */
    imgui_colors_dark = enum.auto()      # (= 1)
    # ImGuiTheme_ImGuiColorsLight,    /* original C++ signature */
    imgui_colors_light = enum.auto()     # (= 2)
    # ImGuiTheme_MaterialFlat,    /* original C++ signature */
    material_flat = enum.auto()          # (= 3)
    # ImGuiTheme_PhotoshopStyle,    /* original C++ signature */
    photoshop_style = enum.auto()        # (= 4)
    # ImGuiTheme_GrayVariations,    /* original C++ signature */
    gray_variations = enum.auto()        # (= 5)
    # ImGuiTheme_GrayVariations_Darker,    /* original C++ signature */
    gray_variations_darker = enum.auto() # (= 6)
    # ImGuiTheme_MicrosoftStyle,    /* original C++ signature */
    microsoft_style = enum.auto()        # (= 7)
    # ImGuiTheme_Cherry,    /* original C++ signature */
    cherry = enum.auto()                 # (= 8)
    # ImGuiTheme_Darcula,    /* original C++ signature */
    darcula = enum.auto()                # (= 9)
    # ImGuiTheme_DarculaDarker,    /* original C++ signature */
    darcula_darker = enum.auto()         # (= 10)
    # ImGuiTheme_LightRounded,    /* original C++ signature */
    light_rounded = enum.auto()          # (= 11)
    # ImGuiTheme_SoDark_AccentBlue,    /* original C++ signature */
    so_dark_accent_blue = enum.auto()    # (= 12)
    # ImGuiTheme_SoDark_AccentYellow,    /* original C++ signature */
    so_dark_accent_yellow = enum.auto()  # (= 13)
    # ImGuiTheme_SoDark_AccentRed,    /* original C++ signature */
    so_dark_accent_red = enum.auto()     # (= 14)
    # ImGuiTheme_BlackIsBlack,    /* original C++ signature */
    black_is_black = enum.auto()         # (= 15)
    # ImGuiTheme_WhiteIsWhite,    /* original C++ signature */
    white_is_white = enum.auto()         # (= 16)
    # ImGuiTheme_Count    /* original C++ signature */
    #     }
    count = enum.auto()                  # (= 17)
# const char* ImGuiTheme_Name(ImGuiTheme_ theme);    /* original C++ signature */
def imgui_theme_name(theme: ImGuiTheme_) -> str:
    pass
# ImGuiTheme_ ImGuiTheme_FromName(const char* themeName);    /* original C++ signature */
def imgui_theme_from_name(theme_name: str) -> ImGuiTheme_:
    pass
# ImGuiStyle ThemeToStyle(ImGuiTheme_ theme);    /* original C++ signature */
def theme_to_style(theme: ImGuiTheme_) -> ImGuiStyle:
    pass
# void ApplyTheme(ImGuiTheme_ theme);    /* original C++ signature */
def apply_theme(theme: ImGuiTheme_) -> None:
    pass


class ImGuiThemeTweaks:
    # float Rounding = -1.f;    /* original C++ signature */
    # Common rounding for widgets. If < 0, this is ignored.
    rounding: float = -1.
    # float RoundingScrollbarRatio = 4.f;    /* original C++ signature */
    # If rounding is applied, scrollbar rounding needs to be adjusted to be visually pleasing in conjunction with other widgets roundings. Only applied if Rounding > 0.)
    rounding_scrollbar_ratio: float = 4.
    # float AlphaMultiplier = -1.f;    /* original C++ signature */
    # Change the alpha that will be applied to windows, popups, etc. If < 0, this is ignored.
    alpha_multiplier: float = -1.

    # float Hue = -1.f;    /* original C++ signature */
    #
    # HSV Color tweaks
    #
    # Change the hue of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.
    hue: float = -1.
    # float SaturationMultiplier = -1.f;    /* original C++ signature */
    # Multiply the saturation of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.
    saturation_multiplier: float = -1.
    # float ValueMultiplierFront = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of all front widgets. If < 0, this is ignored.
    value_multiplier_front: float = -1.
    # float ValueMultiplierBg = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of all backgrounds. If < 0, this is ignored.
    value_multiplier_bg: float = -1.
    # float ValueMultiplierText = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of text. If < 0, this is ignored.
    value_multiplier_text: float = -1.
    # float ValueMultiplierFrameBg = -1.f;    /* original C++ signature */
    # Multiply the value (luminance) of FrameBg. If < 0, this is ignored.
    # (Background of checkbox, radio button, plot, slider, text input)
    value_multiplier_frame_bg: float = -1.

    # ImGuiThemeTweaks() {}    /* original C++ signature */
    def __init__(self) -> None:
        pass

class ImGuiTweakedTheme:
    # ImGuiTheme_ Theme = ImGuiTheme_DarculaDarker;    /* original C++ signature */
    theme: ImGuiTheme_ = ImGuiTheme_.darcula_darker
    # ImGuiThemeTweaks Tweaks = ImGuiThemeTweaks();    /* original C++ signature */
    tweaks: ImGuiThemeTweaks = ImGuiThemeTweaks()
    # ImGuiTweakedTheme(ImGuiTheme_ Theme = ImGuiTheme_DarculaDarker, ImGuiThemeTweaks Tweaks = ImGuiThemeTweaks());    /* original C++ signature */
    def __init__(
        self,
        theme: ImGuiTheme_ = ImGuiTheme_.darcula_darker,
        tweaks: ImGuiThemeTweaks = ImGuiThemeTweaks()
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass

# ImGuiStyle TweakedThemeThemeToStyle(const ImGuiTweakedTheme& tweaked_theme);    /* original C++ signature */
def tweaked_theme_theme_to_style(
    tweaked_theme: ImGuiTweakedTheme
    ) -> ImGuiStyle:
    pass
# void ApplyTweakedTheme(const ImGuiTweakedTheme& tweaked_theme);    /* original C++ signature */
def apply_tweaked_theme(tweaked_theme: ImGuiTweakedTheme) -> None:
    pass

# bool ShowThemeTweakGui(ImGuiTweakedTheme *tweaked_theme);    /* original C++ signature */
def show_theme_tweak_gui(tweaked_theme: ImGuiTweakedTheme) -> bool:
    """ Show the theme selection listbox, the theme tweak widgets, as well as ImGui::ShowStyleEditor. Returns True if modified (Warning, when using ShowStyleEditor, no info about modification is transmitted)"""
    pass

# Some tweakable themes
# ImGuiStyle SoDark(float hue);    /* original C++ signature */
def so_dark(hue: float) -> ImGuiStyle:
    pass
# ImGuiStyle ShadesOfGray(float rounding=0.f, float value_multiplier_front=1.f, float value_multiplier_bg=1.f);    /* original C++ signature */
def shades_of_gray(
    rounding: float = 0.,
    value_multiplier_front: float = 1.,
    value_multiplier_bg: float = 1.
    ) -> ImGuiStyle:
    pass
# ImGuiStyle Darcula(    /* original C++ signature */
#         float rounding=1.f,
#         float hue=-1.f,
#         float saturation_multiplier=1.f,
#         float value_multiplier_front=1.f,
#         float value_multiplier_bg=1.f,
#         float alpha_bg_transparency=1.f
#     );
def darcula(
    rounding: float = 1.,
    hue: float = -1.,
    saturation_multiplier: float = 1.,
    value_multiplier_front: float = 1.,
    value_multiplier_bg: float = 1.,
    alpha_bg_transparency: float = 1.
    ) -> ImGuiStyle:
    pass





#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_window_params.h continued                                            //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""
class DefaultImGuiWindowType(enum.Enum):
    """*
    @@md#DefaultImGuiWindowType

    __DefaultImGuiWindowType__ is an enum class that defines whether or not a full screen background window is provided.

     Values:
      * _ProvideFullScreenWindow_: a full window is provided in the background
      * _ProvideFullScreenDockSpace_: a full screen dockspace is provided in the background
      * _NoDefaultWindow_: No default window is provided (except for ImGui's default "debug" window)

    @@md

    """
    # ProvideFullScreenWindow,    /* original C++ signature */
    provide_full_screen_window = enum.auto()     # (= 0)
    # ProvideFullScreenDockSpace,    /* original C++ signature */
    provide_full_screen_dock_space = enum.auto() # (= 1)
    # NoDefaultWindow    /* original C++ signature */
    # }
    no_default_window = enum.auto()              # (= 2)

class ImGuiWindowParams:
    """*
    @@md#ImGuiWindowParams

    __ImGuiWindowParams__ is a struct that defines the ImGui inner windows params
    These settings affect the imgui inner windows inside the application window.
    In order to change the application window settings, change the _AppWindowsParams_

     Members:

      * `defaultImGuiWindowType`: _DefaultImGuiWindowType, default=ProvideFullScreenWindow_.
          By default, a full window is provided in the background. You can still
          add windows on top of it, since the Z-order of this background window is always behind

      * `backgroundColor`: _ImVec4, default=ImVec4(0.45, 0.55, 0.60, 1.00)_.
          This is the "clearColor", only visible is defaultImGuiWindowType is NoDefaultWindow.

      * `showMenuBar`: _bool, default=false_.
        Show Menu bar on top of imgui main window
        You can customize the menu via `RunnerCallbacks.ShowMenus()`

      * `showMenu_App`: _bool, default=true_.
        If menu bar is shown, include or not the default app menu

       * `showMenu_App_Quit`: _bool, default=true_.
        Include or not a "Quit" item in the default app menu.
        Set this to False if you intend to provide your own quit callback with possible user confirmation
        (and implement it inside RunnerCallbacks.ShowAppMenuItems)

      * `showMenu_View`: _bool, default=true_.
        If menu bar is shown, include or not the default _View_ menu, that enables to change the layout and
        set the docked windows and status bar visibility)

      * `showStatusBar`: _bool, default=false_.
        Flag that enable to show a Status bar at the bottom. You can customize the status bar
        via RunnerCallbacks.ShowStatus()
      * `showStatus_Fps`: _bool, default=true_. If set, display the FPS in the status bar.
      * `rememberStatusBarSettings`: _bool, default=true_. If set, showStatusBar and showStatus_Fps are stored in the application settings.

      * `configWindowsMoveFromTitleBarOnly`: _bool, default=true_.
        Make windows only movable from the title bar

      * `enableViewports`: _bool, default=false_. Enable multiple viewports (i.e multiple native windows)
        If True, you can drag windows outside out the main window in order to put their content into new native windows.

       * `menuAppTitle`: _string, default=""_. Set the title of the App menu. If empty, this menu name will use
         the "windowTitle" from AppWindowParams

      * `tweakedTheme`: _ImGuiTheme::ImGuiTweakedTheme_.
        Change the ImGui theme. Several themes are available, you can query the list by calling
        HelloImGui::AvailableThemes()
      * `showMenu_View_Themes`: _bool, default=true_.
        Show theme selection in view menu
      * `rememberTheme`: _bool, default=true_.
        Remember selected theme
    @@md

    """
    # DefaultImGuiWindowType defaultImGuiWindowType = DefaultImGuiWindowType::ProvideFullScreenWindow;    /* original C++ signature */
    default_imgui_window_type: DefaultImGuiWindowType = DefaultImGuiWindowType.provide_full_screen_window

    # ImVec4 backgroundColor = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);    /* original C++ signature */
    background_color: ImVec4 = ImVec4(0.45, 0.55, 0.60, 1.00)

    # bool showMenuBar = false;    /* original C++ signature */
    show_menu_bar: bool = False
    # bool showMenu_App = true;    /* original C++ signature */
    show_menu_app: bool = True
    # bool showMenu_App_Quit = true;    /* original C++ signature */
    show_menu_app_quit: bool = True
    # bool showMenu_View = true;    /* original C++ signature */
    show_menu_view: bool = True

    # bool showStatusBar = false;    /* original C++ signature */
    show_status_bar: bool = False
    # bool showStatus_Fps = true;    /* original C++ signature */
    show_status_fps: bool = True
    # bool rememberStatusBarSettings = true;    /* original C++ signature */
    remember_status_bar_settings: bool = True

    # bool configWindowsMoveFromTitleBarOnly = true;    /* original C++ signature */
    config_windows_move_from_title_bar_only: bool = True

    # bool enableViewports = false;    /* original C++ signature */
    enable_viewports: bool = False

    # std::string menuAppTitle = "";    /* original C++ signature */
    menu_app_title: str = ""

    # ImGuiTheme::ImGuiTweakedTheme tweakedTheme;    /* original C++ signature */
    tweaked_theme: ImGuiTheme.ImGuiTweakedTheme
    # bool showMenu_View_Themes = true;    /* original C++ signature */
    show_menu_view_themes: bool = True
    # bool rememberTheme = true;    /* original C++ signature */
    remember_theme: bool = True
    # ImGuiWindowParams(DefaultImGuiWindowType defaultImGuiWindowType = DefaultImGuiWindowType::ProvideFullScreenWindow, ImVec4 backgroundColor = ImVec4(0.45f, 0.55f, 0.60f, 1.00f), bool showMenuBar = false, bool showMenu_App = true, bool showMenu_App_Quit = true, bool showMenu_View = true, bool showStatusBar = false, bool showStatus_Fps = true, bool rememberStatusBarSettings = true, bool configWindowsMoveFromTitleBarOnly = true, bool enableViewports = false, std::string menuAppTitle = "", ImGuiTheme::ImGuiTweakedTheme tweakedTheme = ImGuiTheme::ImGuiTweakedTheme(), bool showMenu_View_Themes = true, bool rememberTheme = true);    /* original C++ signature */
    def __init__(
        self,
        default_imgui_window_type: DefaultImGuiWindowType = DefaultImGuiWindowType.provide_full_screen_window,
        background_color: ImVec4 = ImVec4(0.45, 0.55, 0.60, 1.00),
        show_menu_bar: bool = False,
        show_menu_app: bool = True,
        show_menu_app_quit: bool = True,
        show_menu_view: bool = True,
        show_status_bar: bool = False,
        show_status_fps: bool = True,
        remember_status_bar_settings: bool = True,
        config_windows_move_from_title_bar_only: bool = True,
        enable_viewports: bool = False,
        menu_app_title: str = "",
        tweaked_theme: ImGuiTheme.ImGuiTweakedTheme = ImGuiTheme.ImGuiTweakedTheme(),
        show_menu_view_themes: bool = True,
        remember_theme: bool = True
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_callbacks.h included by hello_imgui/runner_params.h                 //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#*
#@@md#VoidFunction_AnyEventCallback
#
#**VoidFunctionPointer** can hold any None(None) function.
#```cpp
#using VoidFunction = std::function<None(None)>
#```
#
#**AnyEventCallback** can hold any bool(None *) function.
#  It is designed to handle callbacks for a specific backend.
#```cpp
#using AnyEventCallback = std::function<bool(None * backendEvent)>
#```
#
#**AppendCallback** can compose two callbacks. Use this when you want to set a callback and keep the (maybe) preexisting one.
#@@md
#*
# VoidFunction AppendCallback(const VoidFunction& previousCallback, const VoidFunction& newCallback);    /* original C++ signature */
def append_callback(
    previous_callback: VoidFunction,
    new_callback: VoidFunction
    ) -> VoidFunction:
    pass


# inline VoidFunction EmptyVoidFunction() { return {}; }    /* original C++ signature */
def empty_void_function() -> VoidFunction:
    pass
# inline AnyEventCallback EmptyEventCallback() {return {}; }    /* original C++ signature */
def empty_event_callback() -> AnyEventCallback:
    pass





#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_default_settings.h included by hello_imgui/runner_callbacks.h        //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""
# ImFont* LoadFontTTF(const std::string & fontFilename, float fontSize, bool useFullGlyphRange = false, ImFontConfig config = ImFontConfig());    /* original C++ signature */
def load_font_ttf(
    font_filename: str,
    font_size: float,
    use_full_glyph_range: bool = False,
    config: ImFontConfig = ImFontConfig()
    ) -> ImFont:
    pass
# ImFont* LoadFontTTF_WithFontAwesomeIcons(const std::string & fontFilename, float fontSize, bool useFullGlyphRange = false, ImFontConfig configFont = ImFontConfig(), ImFontConfig configIcons = ImFontConfig());    /* original C++ signature */
def load_font_ttf_with_font_awesome_icons(
    font_filename: str,
    font_size: float,
    use_full_glyph_range: bool = False,
    config_font: ImFontConfig = ImFontConfig(),
    config_icons: ImFontConfig = ImFontConfig()
    ) -> ImFont:
    pass
# ImFont* MergeFontAwesomeToLastFont(float fontSize, ImFontConfig config = ImFontConfig());    /* original C++ signature */
def merge_font_awesome_to_last_font(
    font_size: float,
    config: ImFontConfig = ImFontConfig()
    ) -> ImFont:
    pass




#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_callbacks.h continued                                               //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

class MobileCallbacks:
    """*
    @@md#MobileCallbacks

    **MobileCallbacks** is a struct that contains callbacks that are called by the application
     when running under "Android, iOS and WinRT".
     These events are specific to mobile and embedded devices that have different requirements
     than your usual desktop application. These events must be handled quickly,
     since often the OS needs an immediate response and will terminate your process shortly
     after sending the event if you do not handle them apprpriately.

     Note: on mobile devices, it is not possible to "Quit" an application, it can only be put on Pause.

     * `OnDestroy`: _VoidFunction, default=empty_. The application is being terminated by the OS.
     * `OnLowMemory`: _VoidFunction, default=empty_. The application is low on memory, free memory if possible.
     * `OnPause`: _VoidFunction, default=empty_. The application is about to enter the background.
     * `OnResume`: _VoidFunction, default=empty_. The application is has come to foreground and is now interactive.

     Note: 'OnPause' and 'OnResume' are called twice consecutively under iOS (before and after entering background
     or foreground).

    @@md

    """
    # VoidFunction OnDestroy = EmptyVoidFunction();    /* original C++ signature */
    on_destroy: VoidFunction = EmptyVoidFunction()
    # VoidFunction OnLowMemory = EmptyVoidFunction();    /* original C++ signature */
    on_low_memory: VoidFunction = EmptyVoidFunction()
    # VoidFunction OnPause = EmptyVoidFunction();    /* original C++ signature */
    on_pause: VoidFunction = EmptyVoidFunction()
    # VoidFunction OnResume = EmptyVoidFunction();    /* original C++ signature */
    on_resume: VoidFunction = EmptyVoidFunction()
    # MobileCallbacks(VoidFunction OnDestroy = EmptyVoidFunction(), VoidFunction OnLowMemory = EmptyVoidFunction(), VoidFunction OnPause = EmptyVoidFunction(), VoidFunction OnResume = EmptyVoidFunction());    /* original C++ signature */
    def __init__(
        self,
        on_destroy: VoidFunction = EmptyVoidFunction(),
        on_low_memory: VoidFunction = EmptyVoidFunction(),
        on_pause: VoidFunction = EmptyVoidFunction(),
        on_resume: VoidFunction = EmptyVoidFunction()
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class RunnerCallbacks:
    """*
     @@md#RunnerCallbacks

     **RunnerCallbacks** is a struct that contains the callbacks that are called by the application

     _Members_

    * `ShowGui`: *VoidFunction, default=empty*.
      Fill it with a function that will add your widgets.

    * `ShowMenus`: *VoidFunction, default=empty*.
        A function that will render your menus. Fill it with a function that will add ImGui menus by calling:
        _ImGui::BeginMenu(...) / ImGui::MenuItem(...) / ImGui::EndMenu()_

        _Notes:_
        * you do not need to call _ImGui::BeginMenuBar_ and _ImGui::EndMenuBar_
        * Some default menus can be provided: see _ImGuiWindowParams_ options
          (_showMenuBar, showMenu_App_QuitAbout, showMenu_View_)

    * `ShowAppMenuItems`: *VoidFunction, default=empty*.
      A function that will render items that will be placed in the App menu.
      They will be placed before the "Quit" MenuItem, which is added automatically by HelloImGui.
      This will be displayed only if ImGuiWindowParams.showMenu_App is True

    * `ShowStatus`: *VoidFunction, default=empty*.
      A function that will add items to the status bar. Use small items (ImGui::Text for example),
      since the height of the status is 30. Also, remember to call ImGui::SameLine() between items.

    * `PostInit`: *VoidFunction, default=empty*.
        You can here add a function that will be called once after OpenGL and ImGui are inited, but before
        the backend callback are initialized.
        If you, for instance, want to add your own glfw callbacks, you should use this function to do so."

    * `BeforeExit`: *VoidFunction, default=empty*.
        You can here add a function that will be called once before exiting (when OpenGL and ImGui are
        still inited)

     * `PreNewFrame`: *VoidFunction, default=empty*.
        You can here add a function that will be called at each frame, and before the call to ImGui::NewFrame().
        It is a good place to dynamically add new fonts, or dynamically add new dockable windows.

    * `AnyBackendEventCallback`: *AnyBackendCallback, default=empty*.
      Callbacks for events from a specific backend. _Only implemented for SDL, where the event
      will be of type 'SDL_Event *'_
      This callback should return True if the event was handled and shall not be processed further.
      Note: in the case of GLFW, you should use register them in `PostInit`

    * `LoadAdditionalFonts`: *VoidFunction, default=_LoadDefaultFont_WithFontAwesome*.
       A function that is called once, when fonts are ready to be loaded.
       By default, _LoadDefaultFont_WithFontAwesome_ is called but you can copy and customize it.
       (LoadDefaultFont_WithFontAwesome will load from assets/fonts/ but reverts to the ImGui embedded font if not found)

    * `SetupImGuiConfig`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.
        If needed, change ImGui config via SetupImGuiConfig (enable docking, gamepad, etc)

    * `SetupImGuiStyle`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.
        If needed, setup your own style by providing your own SetupImGuiStyle callback


    * `mobileCallbacks`: *_MobileCallbacks_*. Callbacks that are called by the application
        when running under "Android, iOS and WinRT".
    Notes:
      * 'mobileCallbacks' is present only if the target device is a mobile device (iOS, Android).
         Use `#ifdef HELLOIMGUI_MOBILEDEVICE` to detect this.
      * These events are currently handled only with SDL backend.

    @@md

    """
    # VoidFunction ShowGui = EmptyVoidFunction();    /* original C++ signature */
    show_gui: VoidFunction = EmptyVoidFunction()
    # VoidFunction ShowMenus = EmptyVoidFunction();    /* original C++ signature */
    show_menus: VoidFunction = EmptyVoidFunction()
    # VoidFunction ShowAppMenuItems = EmptyVoidFunction();    /* original C++ signature */
    show_app_menu_items: VoidFunction = EmptyVoidFunction()
    # VoidFunction ShowStatus = EmptyVoidFunction();    /* original C++ signature */
    show_status: VoidFunction = EmptyVoidFunction()
    # VoidFunction PostInit = EmptyVoidFunction();    /* original C++ signature */
    post_init: VoidFunction = EmptyVoidFunction()
    # VoidFunction BeforeExit = EmptyVoidFunction();    /* original C++ signature */
    before_exit: VoidFunction = EmptyVoidFunction()
    # VoidFunction PreNewFrame = EmptyVoidFunction();    /* original C++ signature */
    pre_new_frame: VoidFunction = EmptyVoidFunction()

    # AnyEventCallback AnyBackendEventCallback = EmptyEventCallback();    /* original C++ signature */
    any_backend_event_callback: AnyEventCallback = EmptyEventCallback()

    # VoidFunction LoadAdditionalFonts = (VoidFunction)(ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons);    /* original C++ signature */
    load_additional_fonts: VoidFunction = (VoidFunction)(ImGuiDefaultSettings.LoadDefaultFont_WithFontAwesomeIcons)
    # VoidFunction SetupImGuiConfig = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiConfig);    /* original C++ signature */
    setup_imgui_config: VoidFunction = (VoidFunction)(ImGuiDefaultSettings.SetupDefaultImGuiConfig)
    # VoidFunction SetupImGuiStyle = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiStyle);    /* original C++ signature */
    setup_imgui_style: VoidFunction = (VoidFunction)(ImGuiDefaultSettings.SetupDefaultImGuiStyle)

    # RunnerCallbacks(VoidFunction ShowGui = EmptyVoidFunction(), VoidFunction ShowMenus = EmptyVoidFunction(), VoidFunction ShowAppMenuItems = EmptyVoidFunction(), VoidFunction ShowStatus = EmptyVoidFunction(), VoidFunction PostInit = EmptyVoidFunction(), VoidFunction BeforeExit = EmptyVoidFunction(), VoidFunction PreNewFrame = EmptyVoidFunction(), AnyEventCallback AnyBackendEventCallback = EmptyEventCallback(), VoidFunction LoadAdditionalFonts = (VoidFunction)(ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons), VoidFunction SetupImGuiConfig = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiConfig), VoidFunction SetupImGuiStyle = (VoidFunction)(ImGuiDefaultSettings::SetupDefaultImGuiStyle));    /* original C++ signature */
    def __init__(
        self,
        show_gui: VoidFunction = EmptyVoidFunction(),
        show_menus: VoidFunction = EmptyVoidFunction(),
        show_app_menu_items: VoidFunction = EmptyVoidFunction(),
        show_status: VoidFunction = EmptyVoidFunction(),
        post_init: VoidFunction = EmptyVoidFunction(),
        before_exit: VoidFunction = EmptyVoidFunction(),
        pre_new_frame: VoidFunction = EmptyVoidFunction(),
        any_backend_event_callback: AnyEventCallback = EmptyEventCallback(),
        load_additional_fonts: VoidFunction = (VoidFunction)(ImGuiDefaultSettings.LoadDefaultFont_WithFontAwesomeIcons),
        setup_imgui_config: VoidFunction = (VoidFunction)(ImGuiDefaultSettings.SetupDefaultImGuiConfig),
        setup_imgui_style: VoidFunction = (VoidFunction)(ImGuiDefaultSettings.SetupDefaultImGuiStyle)
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass


# namespace HelloImGui

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/docking_params.h included by hello_imgui/runner_params.h                   //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""
#*
#@@md#DockingIntro
#
#HelloImGui makes it easy to use dockable windows (based on ImGui [docking branch](https://github.com/ocornut/imgui/tree/docking)).
#
#You can define several layouts and switch between them:  each layout which will remember the user modifications and the list of opened windows
#
#HelloImGui will then provide a "View" menu with options to show/hide the dockable windows, restore the default layout, switch between layouts, etc.
#
#![demo docking](https://traineq.org/ImGuiBundle/HelloImGuiLayout.gif)
#
#* Source for this example: [src/hello_imgui_demos/hello_imgui_demodocking](../../src/hello_imgui_demos/hello_imgui_demodocking)
#* [Video explanation on YouTube](https://www.youtube.com/watch?v=XKxmz__F4ow) (5 minutes)
#
#
#The different available layouts are provided inside RunnerParams via the two members below:
#```cpp
#struct RunnerParams
#{
#    ...
#    DockingParams dockingParams;                            // default layout of the application
#    std::vector<DockingParams> alternativeDockingLayouts;   // optional alternative layouts
#    ...
#};
#```
#
#And `DockingParams` contains members that define a layout:
#
#```cpp
#struct DockingParams
#{
#    std::string layoutName = "Default";          // displayed name of the layout
#    std::vector<DockingSplit> dockingSplits;     // list of splits (which define spaces where the windows will be placed)
#    std::vector<DockableWindow> dockableWindows; // list of windows (with their gui code, and specifying in which space they will be placed)
#    ...
#};
#```
#
#Inside DockingParams, the member `dockingSplits` specifies the layout, and the member `dockableWindows`
# specifies the list of dockable windows, along with their default location, and their code (given by lambdas).
#
# @@md
#
#
#@@md#DockingExample
#
#Below is an example that shows how to instantiate a layout:
#
#1. First, define the docking splits:
#
#```cpp
#std::vector<HelloImGui::DockingSplit> CreateDefaultDockingSplits()
#{
#    //     Here, we want to split "MainDockSpace" (which is provided automatically) into three zones, like this:
#    //    ___________________________________________
#    //    |        |                                |
#    //    | Command|                                |
#    //    | Space  |    MainDockSpace               |
#    //    |        |                                |
#    //    |        |                                |
#    //    |        |                                |
#    //    -------------------------------------------
#    //    |     MiscSpace                           |
#    //    -------------------------------------------
#    //
#
#    // add a space named "MiscSpace" whose height is 25% of the app height.
#    // This will split the preexisting default dockspace "MainDockSpace" in two parts.
#    HelloImGui::DockingSplit splitMainMisc;
#    splitMainMisc.initialDock = "MainDockSpace";
#    splitMainMisc.newDock = "MiscSpace";
#    splitMainMisc.direction = ImGuiDir_Down;
#    splitMainMisc.ratio = 0.25;
#
#    // Then, add a space to the left which occupies a column whose width is 25% of the app width
#    HelloImGui::DockingSplit splitMainCommand;
#    splitMainCommand.initialDock = "MainDockSpace";
#    splitMainCommand.newDock = "CommandSpace";
#    splitMainCommand.direction = ImGuiDir_Left;
#    splitMainCommand.ratio = 0.25;
#
#    std::vector<HelloImGui::DockingSplit> splits {splitMainMisc, splitMainCommand};
#    return splits;
#}
#```
#
#2. Then, define the dockable windows:
#
#```cpp
#std::vector<HelloImGui::DockableWindow> CreateDockableWindows(AppState& appState)
#{
#    // A Command panel named "Commands" will be placed in "CommandSpace". Its Gui is provided calls "CommandGui"
#    HelloImGui::DockableWindow commandsWindow;
#    commandsWindow.label = "Commands";
#    commandsWindow.dockSpaceName = "CommandSpace";
#    commandsWindow.GuiFunction = [&] { CommandGui(appState); };
#
#    // A Log window named "Logs" will be placed in "MiscSpace". It uses the HelloImGui logger gui
#    HelloImGui::DockableWindow logsWindow;
#    logsWindow.label = "Logs";
#    logsWindow.dockSpaceName = "MiscSpace";
#    logsWindow.GuiFunction = [] { HelloImGui::LogGui(); };
#
#    ...
#}
#```
#
#3. Finally, fill the RunnerParams
#
#```cpp
#HelloImGui::RunnerParams runnerParams;
#runnerParams.imGuiWindowParams.defaultImGuiWindowType =
#    HelloImGui::DefaultImGuiWindowType::ProvideFullScreenDockSpace;
#
#runnerParams.dockingParams.dockingSplits = CreateDefaultDockingSplits();
#runnerParams.dockingParams.dockableWindows = CreateDockableWindows();
#
#
#HelloImGui::Run(runnerParams);
#```
#
#@@md
#

#***************************************************************************


class DockingSplit:
    """*
    @@md#DockingSplit

    **DockingSplit** is a struct that defines the way the docking splits should be applied on the screen
    in order to create new Dock Spaces. _DockingParams_ contains a _vector[DockingSplit]_,
    in order to partition the screen at your will.

    _Members:_

    * `initialDock`: _DockSpaceName (aka string)_

        id of the space that should be split.
        At the start, there is only one Dock Space named "MainDockSpace".
        You should start by partitioning this space, in order to create a new dock space.

    * `newDock`: _DockSpaceName (aka string)_. id of the new dock space that will be created.
    * `direction`: *ImGuiDir_ (enum with ImGuiDir_Down, ImGuiDir_Down, ImGuiDir_Left, ImGuiDir_Right)*.
    Direction where this dock space should be created.
    * `ratio`: _float, default=0.25_. Ratio of the initialDock size that should be used by the new dock space.
    * `nodeFlags`: *ImGuiDockNodeFlags_ (enum)*. Flags to apply to the new dock space (enable/disable resizing, splitting, tab bar, etc.)

    @@md

    """
    # DockingSplit(const DockSpaceName& initialDock_ = "", const DockSpaceName& newDock_ = "",    /* original C++ signature */
    #                  ImGuiDir_ direction_ = ImGuiDir_Down, float ratio_ = 0.25f,
    #                  ImGuiDockNodeFlags nodeFlags_ = ImGuiDockNodeFlags_None)
    #       : initialDock(initialDock_), newDock(newDock_), direction(direction_), ratio(ratio_), nodeFlags(nodeFlags_) {}
    def __init__(
        self,
        initial_dock_: DockSpaceName = "",
        new_dock_: DockSpaceName = "",
        direction_: ImGuiDir_ = ImGuiDir_Down,
        ratio_: float = 0.25,
        node_flags_: ImGuiDockNodeFlags = ImGuiDockNodeFlags_None
        ) -> None:
        pass

    # DockSpaceName initialDock;    /* original C++ signature */
    initial_dock: DockSpaceName
    # DockSpaceName newDock;    /* original C++ signature */
    new_dock: DockSpaceName
    # ImGuiDir_ direction;    /* original C++ signature */
    direction: ImGuiDir_
    # float ratio = 0.25f;    /* original C++ signature */
    ratio: float = 0.25
    # ImGuiDockNodeFlags nodeFlags = ImGuiDockNodeFlags_None;    /* original C++ signature */
    node_flags: ImGuiDockNodeFlags = ImGuiDockNodeFlags_None

class DockableWindow:
    """*
    @@md#DockableWindow

    **DockableWindow** is a struct that represents a window that can be docked.

    _Members:_

    * `label`: _string_. Title of the window.
    * `dockSpaceName`: _DockSpaceName (aka string)_. Id of the dock space where this window
       should initially be placed
    * `GuiFunction`: _VoidFunction_. Any function that will render this window's Gui.
    * `isVisible`: _bool, default=true_. Flag that indicates whether this window is visible or not.
    * `rememberIsVisible`: _bool, default=true_. Flag that indicates whether the window visibility should be saved in settings or not.
    * `canBeClosed`: _bool, default=true_. Flag that indicates whether the user can close this window.
    * `callBeginEnd`: _bool, default=true_. Flag that indicates whether ImGui::Begin and ImGui::End
       calls should be added automatically (with the given "label"). Set to False if you want to call
       ImGui::Begin/End yourself
    * `includeInViewMenu`: _bool, default=true_. Flag that indicates whether this window should be mentioned
       in the view menu.
    * `imGuiWindowFlags`: _ImGuiWindowFlags, default=0_. Window flags, see enum ImGuiWindowFlags_
    * `windowSize`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window size (unused if docked)
    * `windowSizeCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window size.
    * `windowPos`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window position (unused if docked)
    * `windowPosCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window position.
    * `focusWindowAtNextFrame`: _bool, default = false_. If set to True this window will be focused at the next frame.

    @@md
    *
    """
    # DockableWindow(    /* original C++ signature */
    #         const std::string & label_ = "",
    #         const DockSpaceName & dockSpaceName_ = "",
    #         const VoidFunction guiFunction_ = EmptyVoidFunction(),
    #         bool isVisible_ = true,
    #         bool canBeClosed_ = true)
    #     : label(label_), dockSpaceName(dockSpaceName_),
    #       GuiFunction(guiFunction_),
    #       isVisible(isVisible_),
    #       canBeClosed(canBeClosed_) {}
    def __init__(
        self,
        label_: str = "",
        dock_space_name_: DockSpaceName = "",
        gui_function_: VoidFunction = EmptyVoidFunction(),
        is_visible_: bool = True,
        can_be_closed_: bool = True
        ) -> None:
        pass

    # std::string label;    /* original C++ signature */
    label: str

    # DockSpaceName dockSpaceName;    /* original C++ signature */
    dock_space_name: DockSpaceName

    # VoidFunction GuiFunction = EmptyVoidFunction();    /* original C++ signature */
    gui_function: VoidFunction = EmptyVoidFunction()

    # bool isVisible = true;    /* original C++ signature */
    is_visible: bool = True
    # bool rememberIsVisible = true;    /* original C++ signature */
    remember_is_visible: bool = True

    # bool canBeClosed = true;    /* original C++ signature */
    can_be_closed: bool = True
    # bool callBeginEnd = true;    /* original C++ signature */
    call_begin_end: bool = True
    # bool includeInViewMenu = true;    /* original C++ signature */
    include_in_view_menu: bool = True
    # ImGuiWindowFlags imGuiWindowFlags = 0;    /* original C++ signature */
    imgui_window_flags: ImGuiWindowFlags = 0

    # ImVec2 windowSize = ImVec2(0.f, 0.f);    /* original C++ signature */
    window_size: ImVec2 = ImVec2(0., 0.)
    # ImGuiCond  windowSizeCondition = ImGuiCond_FirstUseEver;    /* original C++ signature */
    window_size_condition: ImGuiCond = ImGuiCond_FirstUseEver

    # ImVec2 windowPosition = ImVec2(0.f, 0.f);    /* original C++ signature */
    window_position: ImVec2 = ImVec2(0., 0.)
    # ImGuiCond  windowPositionCondition = ImGuiCond_FirstUseEver;    /* original C++ signature */
    window_position_condition: ImGuiCond = ImGuiCond_FirstUseEver

    # bool focusWindowAtNextFrame = false;    /* original C++ signature */
    focus_window_at_next_frame: bool = False


#*
#@@md#DockingParams
#
#**DockingParams** contains all the settings concerning the docking,
# together _with the Gui functions for the docked windows_.
#
# _Members:_
#
#* `dockingSplits`: _vector[DockingSplit]_.
#  Defines the way docking splits should be applied on the screen in order to create new Dock Spaces
#* `dockableWindows`: _vector[DockableWindow]_.
#  List of the dockable windows, together with their Gui code
#* `layoutName`: _string, default="default"_.
#  Displayed name of the layout. Only used in advanced cases when several layouts are available.
#* `layoutCondition`: _enum DockingLayoutCondition, default=DockingLayoutCondition::FirstUseEver_.
#  When to apply the docking layout. Choose between FirstUseEver (apply once, then keep user preference),
#  ApplicationStart (always reapply at application start), and Never.
#* `mainDockSpaceNodeFlags`: _ImGuiDockNodeFlags (enum), default=ImGuiDockNodeFlags_PassthruCentralNode_
#   Flags to apply to the main dock space (enable/disable resizing, splitting, tab bar, etc.).
#   Most flags are inherited by children dock spaces. You can also set flags for specific dock spaces via `DockingSplit.nodeFlags`
#* `layoutReset`: _bool, default=false_.
#  Reset layout on next frame, i.e. drop the layout customizations which were applied manually by the user.
#  (layoutReset will be set to False after applying)
#
# _Helpers:_
#
# * `DockableWindow * dockableWindowOfName(const std::string & name)`: returns a pointer to a dockable window
# * `bool focusDockableWindow(const std::string& name)`: will focus a dockable window (and make its tab visible if needed)
# * `optional<ImGuiID> dockSpaceIdFromName(const std::string& dockSpaceName)`: may return the ImGuiID corresponding
#   to the dockspace with this name.
#   **Warning**: this will work reliably only if layoutCondition = DockingLayoutCondition::ApplicationStart. In other
#   cases, the ID may be cached by ImGui himself at the first run, and HelloImGui will *not* know it on subsequent runs!
#@@md
#

class DockingLayoutCondition(enum.Enum):
    # FirstUseEver,    /* original C++ signature */
    first_use_ever = enum.auto()    # (= 0)
    # ApplicationStart,    /* original C++ signature */
    application_start = enum.auto() # (= 1)
    # Never    /* original C++ signature */
    # }
    never = enum.auto()             # (= 2)

class DockingParams:
    # std::vector<DockingSplit>   dockingSplits;    /* original C++ signature */
    docking_splits: List[DockingSplit]
    # std::vector<DockableWindow> dockableWindows;    /* original C++ signature */
    dockable_windows: List[DockableWindow]

    # std::string layoutName = "Default";    /* original C++ signature */
    layout_name: str = "Default"

    # DockingLayoutCondition layoutCondition = DockingLayoutCondition::FirstUseEver;    /* original C++ signature */
    layout_condition: DockingLayoutCondition = DockingLayoutCondition.first_use_ever
    # bool layoutReset = false;    /* original C++ signature */
    layout_reset: bool = False

    # ImGuiDockNodeFlags mainDockSpaceNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode;    /* original C++ signature */
    main_dock_space_node_flags: ImGuiDockNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode

    # Helpers
    # DockableWindow * dockableWindowOfName(const std::string& name);    /* original C++ signature */
    def dockable_window_of_name(self, name: str) -> DockableWindow:
        pass
    # bool focusDockableWindow(const std::string& windowName);    /* original C++ signature */
    def focus_dockable_window(self, window_name: str) -> bool:
        pass
    # std::optional<ImGuiID> dockSpaceIdFromName(const std::string& dockSpaceName);    /* original C++ signature */
    def dock_space_id_from_name(self, dock_space_name: str) -> Optional[ImGuiID]:
        pass
    # DockingParams(std::vector<DockingSplit> dockingSplits = std::vector<DockingSplit>(), std::vector<DockableWindow> dockableWindows = std::vector<DockableWindow>(), std::string layoutName = "Default", DockingLayoutCondition layoutCondition = DockingLayoutCondition::FirstUseEver, bool layoutReset = false, ImGuiDockNodeFlags mainDockSpaceNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode);    /* original C++ signature */
    def __init__(
        self,
        docking_splits: List[DockingSplit] = List[DockingSplit](),
        dockable_windows: List[DockableWindow] = List[DockableWindow](),
        layout_name: str = "Default",
        layout_condition: DockingLayoutCondition = DockingLayoutCondition.first_use_ever,
        layout_reset: bool = False,
        main_dock_space_node_flags: ImGuiDockNodeFlags = ImGuiDockNodeFlags_PassthruCentralNode
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/backend_pointers.h included by hello_imgui/runner_params.h                 //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""

class BackendPointers:
    """*
     @@md#BackendPointers

    **BackendPointers** is a struct that contains optional pointers to the backend implementations (for SDL and GLFW).

    These pointers will be filled when the application starts, and you can use them to customize
    your application behavior using the selected backend.

     Members:
    * `glfwWindow`: _void *, default=nullptr_. Pointer to the main GLFW window (of type `GLFWwindow*`).
      Only filled if the backend is GLFW.
    * `sdlWindow`: _void *, default=nullptr_. Pointer to the main SDL window (of type `SDL_Window*`).
      Only filled if the backend is SDL (or emscripten + sdl)
    * `sdlGlContext`: _void *, default=nullptr_. Pointer to SDL's GlContext (of type `SDL_GLContext`).
      Only filled if the backend is SDL (or emscripten + sdl)

    @@md

    """
    # GLFWwindow*
    # void* glfwWindow     = nullptr;    /* original C++ signature */
    glfw_window: Any = None

    # SDL_Window*
    # void* sdlWindow      = nullptr;    /* original C++ signature */
    sdl_window: Any = None
    # SDL_GLContext
    # void* sdlGlContext   = nullptr;    /* original C++ signature */
    sdl_gl_context: Any = None
    # BackendPointers();    /* original C++ signature */
    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_params.h continued                                                  //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


""" namespace HelloImGui"""

class BackendType(enum.Enum):
    # FirstAvailable,    /* original C++ signature */
    first_available = enum.auto() # (= 0)
    # Sdl,    /* original C++ signature */
    sdl = enum.auto()             # (= 1)
    # Glfw,    /* original C++ signature */
    glfw = enum.auto()            # (= 2)
    # Qt    /* original C++ signature */
    # }
    qt = enum.auto()              # (= 3)

class FpsIdling:
    """*
     @@md#FpsIdling

    **FpsIdling** is a struct that contains Fps Idling parameters

    * `fpsIdle`: _float, default=9_.
      ImGui applications can consume a lot of CPU, since they update the screen very frequently.
      In order to reduce the CPU usage, the FPS is reduced when no user interaction is detected.
      This is ok most of the time but if you are displaying animated widgets (for example a live video),
      you may want to ask for a faster refresh: either increase fpsIdle, or set it to 0 for maximum refresh speed
      (you can change this value during the execution depending on your application refresh needs)
    * `enableIdling`: _bool, default=true_.
      Set this to False to disable idling (this can be changed dynamically during execution)
    * `isIdling`: bool (dynamically updated during execution)
      This bool will be updated during the application execution, and will be set to True when it is idling.
    * `rememberEnableIdling`: _bool, default=true_.
      If True, the last value of enableIdling is restored from the settings at startup.
    @@md

    """
    # float fpsIdle = 9.f;    /* original C++ signature */
    fps_idle: float = 9.
    # bool  enableIdling = true;    /* original C++ signature */
    enable_idling: bool = True
    # bool  isIdling = false;    /* original C++ signature */
    is_idling: bool = False
    # bool  rememberEnableIdling = true;    /* original C++ signature */
    remember_enable_idling: bool = True
    # FpsIdling(float fpsIdle = 9.f, bool enableIdling = true, bool isIdling = false, bool rememberEnableIdling = true);    /* original C++ signature */
    def __init__(
        self,
        fps_idle: float = 9.,
        enable_idling: bool = True,
        is_idling: bool = False,
        remember_enable_idling: bool = True
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass

class RunnerParams:
    """*
     @@md#RunnerParams

    **RunnerParams** is a struct that contains all the settings and callbacks needed to run an application.

     Members:
    * `callbacks`: _see [runner_callbacks.h](runner_callbacks.h)_.
       callbacks.ShowGui() will render the gui, ShowMenus() will show the menus, etc.
    * `appWindowParams`: _see [app_window_params.h](app_window_params.h)_.
       application Window Params (position, size, title)
    * `imGuiWindowParams`: _see [imgui_window_params.h](imgui_window_params.h)_.
       imgui window params (use docking, showMenuBar, ProvideFullScreenWindow, etc)
    * `dockingParams`: _see [docking_params.h](docking_params.h)_.
       dockable windows content and layout
    * `alternativeDockingLayouts`: _vector<DockingParams>, default=empty_
       List of possible additional layout for the applications. Only used in advanced cases when several layouts are available.
    * `rememberSelectedAlternativeLayout`: _bool, default=true_
       Shall the application remember the last selected layout. Only used in advanced cases when several layouts are available.
    * `backendPointers`: _see [backend_pointers.h](backend_pointers.h)_.
       A struct that contains optional pointers to the backend implementations. These pointers will be filled
       when the application starts
    * `backendType`: _enum BackendType, default=BackendType::FirstAvailable_
      Select the wanted backend type between `Sdl`, `Glfw` and `Qt`. Only useful when multiple backend are compiled
      and available.
    * `fpsIdling`: _FpsIdling_. Idling parameters (set fpsIdling.enableIdling to False to disable Idling)
    * `iniFilename`: _string, default = ""_
      Sets the ini filename under which imgui will save its params. Path is relative to the current app working dir.
      If empty, then the ini file name will be derived from appWindowParams.windowTitle (if both are empty, the ini filename will be imgui.ini).
      Note: if appWindowParams.restorePreviousGeometry is True, then HelloImGui will also store the app window size and position into "iniFilename + _appWindow.ini"
    * `iniFilename_useAppWindowTitle`: _bool, default = true_.
      Shall the iniFilename be derived from appWindowParams.windowTitle if empty
    * `appShallExit`: _bool, default=false_.
       During execution, set this to True to exit the app.
       _Note: 'appShallExit' has no effect on Mobile Devices (iOS, Android) and under emscripten, since these apps
       shall not exit._
    * `emscripten_fps`: _int, default = 0_.
      Set the application refresh rate (only used on emscripten: 0 stands for "let the app or the browser decide")
    @@md

    """
    # RunnerCallbacks callbacks;    /* original C++ signature */
    callbacks: RunnerCallbacks
    # AppWindowParams appWindowParams;    /* original C++ signature */
    app_window_params: AppWindowParams
    # ImGuiWindowParams imGuiWindowParams;    /* original C++ signature */
    imgui_window_params: ImGuiWindowParams

    # DockingParams dockingParams;    /* original C++ signature */
    docking_params: DockingParams
    # std::vector<DockingParams> alternativeDockingLayouts;    /* original C++ signature */
    alternative_docking_layouts: List[DockingParams]
    # bool rememberSelectedAlternativeLayout = true;    /* original C++ signature */
    remember_selected_alternative_layout: bool = True

    # BackendPointers backendPointers;    /* original C++ signature */
    backend_pointers: BackendPointers
    # BackendType backendType = BackendType::FirstAvailable;    /* original C++ signature */
    backend_type: BackendType = BackendType.first_available
    # FpsIdling fpsIdling;    /* original C++ signature */
    fps_idling: FpsIdling

    # std::string iniFilename = "";    /* original C++ signature */
    ini_filename: str = ""
    # bool iniFilename_useAppWindowTitle = true;    /* original C++ signature */
    ini_filename_use_app_window_title: bool = True

    # bool appShallExit = false;    /* original C++ signature */
    app_shall_exit: bool = False
    # int emscripten_fps = 0;    /* original C++ signature */
    emscripten_fps: int = 0
    # RunnerParams(RunnerCallbacks callbacks = RunnerCallbacks(), AppWindowParams appWindowParams = AppWindowParams(), ImGuiWindowParams imGuiWindowParams = ImGuiWindowParams(), DockingParams dockingParams = DockingParams(), std::vector<DockingParams> alternativeDockingLayouts = std::vector<DockingParams>(), bool rememberSelectedAlternativeLayout = true, BackendPointers backendPointers = BackendPointers(), BackendType backendType = BackendType::FirstAvailable, FpsIdling fpsIdling = FpsIdling(), std::string iniFilename = "", bool iniFilename_useAppWindowTitle = true, bool appShallExit = false, int emscripten_fps = 0);    /* original C++ signature */
    def __init__(
        self,
        callbacks: RunnerCallbacks = RunnerCallbacks(),
        app_window_params: AppWindowParams = AppWindowParams(),
        imgui_window_params: ImGuiWindowParams = ImGuiWindowParams(),
        docking_params: DockingParams = DockingParams(),
        alternative_docking_layouts: List[DockingParams] = List[DockingParams](),
        remember_selected_alternative_layout: bool = True,
        backend_pointers: BackendPointers = BackendPointers(),
        backend_type: BackendType = BackendType.first_available,
        fps_idling: FpsIdling = FpsIdling(),
        ini_filename: str = "",
        ini_filename_use_app_window_title: bool = True,
        app_shall_exit: bool = False,
        emscripten_fps: int = 0
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass


class SimpleRunnerParams:
    """*
     @@md#SimpleRunnerParams

    **SimpleRunnerParams** is a struct that contains simpler params adapted for simple use cases.

     Members:
    * `guiFunction`: _VoidFunction_.
       Function that renders the Gui.
    * `windowTitle`: _string, default=""_.
       Title of the application window
    * `windowSizeAuto`: _bool, default=false_.
       If True, the size of the window will be computed from its widgets.
    * `windowRestorePreviousGeometry`: _bool, default=true_.
       If True, restore the size and position of the window between runs.
    * `windowSize`: _ScreenSize, default={800, 600}_.
       Size of the window
    * `fpsIdle`: _float, default=9_.
       FPS of the application when idle (set to 0 for full speed).

    For example, this is sufficient to run an application:

    ```cpp
    None MyGui() {
        ImGui::Text("Hello, world");
        if (ImGui::Button("Exit"))
            HelloImGui::GetRunnerParams()->appShallExit = True;
    }

    int main(){
        auto params = HelloImGui::SimpleRunnerParams {.guiFunction = MyGui, .windowSizeAuto = True, .windowTitle = "Example"};
        HelloImGui::Run(params);
    }
    ```

    @@md

    """
    # VoidFunction guiFunction = EmptyVoidFunction();    /* original C++ signature */
    gui_function: VoidFunction = EmptyVoidFunction()
    # std::string windowTitle = "";    /* original C++ signature */
    window_title: str = ""

    # bool windowSizeAuto = false;    /* original C++ signature */
    window_size_auto: bool = False
    # bool windowRestorePreviousGeometry = false;    /* original C++ signature */
    window_restore_previous_geometry: bool = False
    # ScreenSize windowSize = DefaultWindowSize;    /* original C++ signature */
    window_size: ScreenSize = DefaultWindowSize

    # float fpsIdle = 9.f;    /* original C++ signature */
    fps_idle: float = 9.
    # bool  enableIdling = true;    /* original C++ signature */
    enable_idling: bool = True

    # RunnerParams ToRunnerParams() const;    /* original C++ signature */
    def to_runner_params(self) -> RunnerParams:
        pass
    # SimpleRunnerParams(VoidFunction guiFunction = EmptyVoidFunction(), std::string windowTitle = "", bool windowSizeAuto = false, bool windowRestorePreviousGeometry = false, ScreenSize windowSize = DefaultWindowSize, float fpsIdle = 9.f, bool enableIdling = true);    /* original C++ signature */
    def __init__(
        self,
        gui_function: VoidFunction = EmptyVoidFunction(),
        window_title: str = "",
        window_size_auto: bool = False,
        window_restore_previous_geometry: bool = False,
        window_size: ScreenSize = DefaultWindowSize,
        fps_idle: float = 9.,
        enable_idling: bool = True
        ) -> None:
        """Auto-generated default constructor with named params"""
        pass


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_logger.h included by hello_imgui.h                             //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
"""*
@@md#HelloImGui::Log

HelloImGui provides a simple Log utility that is able to collect message and display them with a specific widget.

* __HelloImGui::Log(LogLevel level, char const* const format, ... )__ will log a message (printf like format)
* __HelloImGui::LogClear()__ will clear the Log list
* __HelloImGui::LogGui()__ will display the Log widget

@@md

"""
class LogLevel(enum.Enum):
    # Debug,    /* original C++ signature */
    debug = enum.auto()   # (= 0)
    # Info,    /* original C++ signature */
    info = enum.auto()    # (= 1)
    # Warning,    /* original C++ signature */
    warning = enum.auto() # (= 2)
    # Error    /* original C++ signature */
    #     }
    error = enum.auto()   # (= 3)

# void Log(LogLevel level, char const* const format, ...);    /* original C++ signature */
def log(level: LogLevel, format: str) -> None:
    pass
# void LogClear();    /* original C++ signature */
def log_clear() -> None:
    pass
# void LogGui(ImVec2 size=ImVec2(0.f, 0.f));    /* original C++ signature */
# }
def log_gui(size: ImVec2 = ImVec2(0., 0.)) -> None:
    pass


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/dpi_aware.h included by hello_imgui.h                                      //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#*
#@@md#Dpi
#
#Special care must be taken in order to correctly handle screen with high DPI (for example, almost all recent laptops screens).
#Otherwise, widgets might be misplaced or too small, and font rendering might be blurry or too small.
#
#### How to position widgets on a window in a Dpi independent way
#
#Using ImVec2 with fixed values is *almost always a bad idea* if you intend your application to be used on high DPI screens.
#Instead you can:
#* either multiply those values by ImGui::GetFontSize()
#* or use `HelloImGui::EmToVec2(x, y)` which will do this multiplication for you. Em stand for the `em` measurements,
#   as used in CSS: 1em simply correspond to the current font height.
#
#
#### How to load fonts for a crisp font rendering and a correct size
#
#HelloImGui provides `HelloImGui::DpiFontLoadingFactor()` which corresponds to:
#    `DpiWindowSizeFactor() * 1. / ImGui::GetIO().FontGlobalScale`
#              where DpiWindowSizeFactor() is equal to `CurrentScreenPixelPerInch / 96` under windows and linux, 1 under macOS
#
#==> When loading fonts, multiply their size by this factor!
#
#### More details on DPI handling with different OS and backends
#
#Let's consider screen whose physical pixel resolution is 3600x2000, but which will displayed with a scaling factor of 200%,
# so that widgets do not look too small on it.
#
#The way it is handled depends on the OS:
#- On MacOS, the screen will be seen as having a resolution of 1800x1000, and the OS handles the resizing by itself.
#- On Linux, and on Windows if the application is DPI aware, the screen will be seen as having a resolution of 3600x2000.
#- On Windows if the application is not DPI aware, the screen will be seen as having a resolution of 1800x1000
#
#By default, if using the glfw backend, applications will be Dpi aware under windows.
#Sdl applications are normally not Dpi aware. However HelloImGui makes them Dpi aware when using the sdl backend.
#
#
#### HelloImGui Dpi aware C++ API
#
#`HelloImGui::EmSize()` (C++) and `hello_imgui.em_size()` (Python) return the visible font size on the screen.
#For reproducible results, even on HighDPI screens, always scale your widgets and windows relatively to this size.
# It is somewhat comparable to the [em CSS Unit](https://lyty.dev/css/css-unit.html).
#
#`HelloImGui::EmToVec2(x, y)` (C++) and `hello_imgui.em_to_vec2(x,y)` (Python) return an ImVec2 that you can use
# to size or place your widgets in a DPI independent way.
#
#`HelloImGui::EmSize(nbLines)` (C++) and `hello_imgui.em_size(nb_lines)` (Python) return a size corresponding to nbLines text lines
#
#`HelloImGui::DpiFontLoadingFactor()` (C++) and `hello_imgui.dpi_font_loading_factor()` (Python) return a factor by
# which you shall multiply your font sizes when loading fonts manually with _ImGui::GetIO().Fonts->AddFont..._
# HelloImGui::LoadFontTTF does this by default.
#
#`HelloImGui::ImGuiDefaultFontGlobalScale()` (C++) and `hello_imgui.imgui_default_font_global_scale()` (Python) returns the
# default value that should be stored inside `ImGui::GetIO().FontGlobalScale`.
# Under windows and linux, this is always 1: no rescaling should be done by ImGui. Under macOS and emscripten,
# this can be < 1 (for example it will be 0.5 if the dpi scaling is 200%)
#@@md
#

# float EmSize();    /* original C++ signature */
def em_size() -> float:
    """ __HelloImGui::EmSize()__ returns the visible font size on the screen. For good results on HighDPI screens, always scale your
     widgets and windows relatively to this size.
     It is somewhat comparable to the [em CSS Unit](https://lyty.dev/css/css-unit.html).
     EmSize() = ImGui::GetFontSize()
    """
    pass

# float EmSize(float nbLines);    /* original C++ signature */
def em_size(nb_lines: float) -> float:
    """ __HelloImGui::EmSize(nbLines)__ returns a size corresponding to nbLines text lines"""
    pass

# __HelloImGui::EmToVec2()__ returns an ImVec2 that you can use to size or place your widgets in a DPI independent way
# ImVec2 EmToVec2(float x, float y);    /* original C++ signature */
def em_to_vec2(x: float, y: float) -> ImVec2:
    pass
# ImVec2 EmToVec2(ImVec2 v);    /* original C++ signature */
def em_to_vec2(v: ImVec2) -> ImVec2:
    pass

# float DpiFontLoadingFactor();    /* original C++ signature */
def dpi_font_loading_factor() -> float:
    """ Multiply font sizes by this factor when loading fonts manually with ImGui::GetIO().Fonts->AddFont...
     (HelloImGui::LoadFontTTF does this by default)
    """
    pass

# float DpiWindowSizeFactor();    /* original C++ signature */
def dpi_window_size_factor() -> float:
    """ DpiWindowSizeFactor() is the factor by which window size should be multiplied to get a similar visible size on different OSes.
     It returns ApplicationScreenPixelPerInch / 96  under windows and linux. Under macOS, it will return 1.
    """
    pass

# float ImGuiDefaultFontGlobalScale();    /* original C++ signature */
# }
def imgui_default_font_global_scale() -> float:
    """ returns the default value that should be stored inside `ImGui::GetIO().FontGlobalScale`"""
    pass

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui.h continued                                                                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////





# void Run(RunnerParams &runnerParams);    /* original C++ signature */
def run(runner_params: RunnerParams) -> None:
    """*
    @@md#HelloImGui::Run

    __HelloImGui::Run()__ will run an application with a single call.

    Three signatures are provided:

    * `HelloImGui::Run(RunnerParams &)`: full signature, the most customizable version.
       Runs an application whose params and Gui are provided by runnerParams.

    * `HelloImGui::Run(const SimpleRunnerParams&)`:
       Runs an application, using simpler params.

    * `HelloImGui::Run(guiFunction, windowTitle, windowSize, windowSizeAuto=False, restoreLastWindowGeometry=False, fpsIdle=10)`


    __Other utilities:__

    * `HelloImGui::GetRunnerParams()`:
      a convenience function that will return the runnerParams of the current application

    * `FrameRate(durationForMean = 0.5)`: Returns the current FrameRate.
      May differ from ImGui::GetIO().FrameRate, since one can choose the duration for the calculation of the mean value of the fps
    @@md

    """
    pass

# void Run(const SimpleRunnerParams &simpleParams);    /* original C++ signature */
def run(simple_params: SimpleRunnerParams) -> None:
    pass

# void Run(    /* original C++ signature */
#         const VoidFunction &guiFunction,
#         const std::string &windowTitle = "",
#         bool windowSizeAuto = false,
#         bool windowRestorePreviousGeometry = false,
#         const ScreenSize &windowSize = DefaultWindowSize,
#         float fpsIdle = 10.f
#     );
def run(
    gui_function: VoidFunction,
    window_title: str = "",
    window_size_auto: bool = False,
    window_restore_previous_geometry: bool = False,
    window_size: ScreenSize = DefaultWindowSize,
    fps_idle: float = 10.
    ) -> None:
    pass

# RunnerParams *GetRunnerParams();    /* original C++ signature */
def get_runner_params() -> RunnerParams:
    pass

# float FrameRate(float durationForMean = 0.5f);    /* original C++ signature */
def frame_rate(duration_for_mean: float = 0.5) -> float:
    """ Returns the current FrameRate. May differ from ImGui::GetIO().FrameRate,
     since one can choose the duration for the calculation of the mean value of the fps
     (Will only lead to accurate values if you call it at each frame)
    """
    pass


#*
#@@md#HelloImGui::Layouts
#
# In advanced cases when several layouts are available, you can switch between layouts.
#(see demo inside [hello_imgui_demodocking.main.cpp](../hello_imgui_demos/hello_imgui_demodocking/hello_imgui_demodocking.main.cpp))
#
#* `SwitchLayout(layoutName)`
#  Changes the application current layout. Only used in advanced cases when several layouts are available,
#  i.e. if you filled runnerParams.alternativeDockingLayouts.
#* `CurrentLayoutName()`: returns the name of the current layout
#@@md
#
# void           SwitchLayout(const std::string& layoutName);    /* original C++ signature */
def switch_layout(layout_name: str) -> None:
    pass
# std::string    CurrentLayoutName();    /* original C++ signature */
def current_layout_name() -> str:
    pass


#*
#@@md#HelloImGui::UserPref
#
#You may store additional user settings in the application settings. This is provided as a convenience only,
#and it is not intended to store large quantities of text data. Use sparingly.
#
#* `SaveUserPref(string userPrefName, string userPrefContent)`:
#  Shall be called in the callback runnerParams.callbacks.BeforeExit
#
#* `string LoadUserPref(string& userPrefName)`
#  Shall be called in the callback runnerParams.callbacks.PostInit
#@@md
#
# void        SaveUserPref(const std::string& userPrefName, const std::string& userPrefContent);    /* original C++ signature */
def save_user_pref(user_pref_name: str, user_pref_content: str) -> None:
    pass
# std::string LoadUserPref(const std::string& userPrefName);    /* original C++ signature */
# }
def load_user_pref(user_pref_name: str) -> str:
    pass


# <submodule imgui_default_settings>
class imgui_default_settings:  # Proxy class that introduces typings for the *submodule* imgui_default_settings
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace ImGuiDefaultSettings"""
    # void LoadDefaultFont_WithFontAwesomeIcons();    /* original C++ signature */
    @staticmethod
    def load_default_font_with_font_awesome_icons() -> None:
        """ LoadDefaultFont_WithFontAwesome will load from assets/fonts and reverts to the imgui embedded font if not found."""
        pass

    # void SetupDefaultImGuiConfig();    /* original C++ signature */
    @staticmethod
    def setup_default_imgui_config() -> None:
        pass
    # void SetupDefaultImGuiStyle();    /* original C++ signature */
    @staticmethod
    def setup_default_imgui_style() -> None:
        pass

    # bool DidCallHelloImGuiLoadFontTTF();    /* original C++ signature */
    # }
    @staticmethod
    def did_call_hello_imgui_load_font_ttf() -> bool:
        """ indicates that fonts were loaded using HelloImGui::LoadFontTTF. In that case, fonts may have been resized to
         account for HighDPI (on macOS and emscripten)
        """
        pass

# </submodule imgui_default_settings>
####################    </generated_from:hello_imgui_amalgamation.h>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


import numpy as np


def final_app_window_screenshot() -> np.ndarray:
    """Return a screenshot of the final screen of the last (exited) app
    """
    pass
