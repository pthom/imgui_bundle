# type: ignore
from typing import List, Any, Callable, Tuple
import numpy as np
import enum

# Manual code
DockSpaceName = str
from imgui_bundle.imgui import (
    ImVec2, ImVec4,
    ImFontConfig, ImFont,
    ImTextureID,
    ImGuiDir_,
    ImGuiWindowFlags,
    ImGuiCond,
    ImGuiCond_,
)


VoidFunction = Callable[[None], None]
AnyEventCallback = Callable[[Any], None]
ScreenSize = Tuple[int, int]
WindowPosition = Tuple[int, int]
ImGuiCond_FirstUseEver = ImGuiCond_.first_use_ever


def get_glfw_window():
    """Returns a pointer to the app GLFW window (when using GLFW)"""
    pass


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:hello_imgui_amalgamation.h>    ####################
# THIS FILE WAS GENERATED AUTOMATICALLY. DO NOT EDIT.

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui.h                                                                          //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#*
#@@md#AssetsStructure
#
#Assets located beside the application CMakeLists are embedded automatically.
#
#For example, you can have the following project structure:
#````
#my_app/
#├── CMakeLists.txt        # Your app's CMakeLists
#├── assets/               # Its assets: for mobile devices and emscripten
#│   └── fonts/            # they are embedded automatically by hello_imgui_add_app.cmake
#│       └── my_font.ttf
#├── my_app.main.cpp       # Its source code
#````
#
#Then you can load the asset "fonts/my_font.ttf", on all platforms.
#
#@@md
#


class AssetFileData:
    """*
    @@md#LoadAssetFileData

    * `AssetFileData LoadAssetFileData(const char *assetPath)` will load an entire asset file into memory.
     This works on all platforms, including android.
     ````cpp
        struct AssetFileData
        {
            None * data = None;
            size_t dataSize = 0;
        };
     ````
    * `FreeAssetFileData(AssetFileData * assetFileData)` will free the memory.

      Note about ImGui: "ImGui::GetIO().Fonts->AddFontFromMemoryTTF" takes ownership of the data
      and will free the memory for you.

    @@md
    *
    """
    data: Any = None
    data_size: int = 0

def load_asset_file_data(asset_path: str) -> AssetFileData:
    pass
def free_asset_file_data(asset_file_data: AssetFileData) -> None:
    pass



def asset_file_full_path(asset_relative_filename: str) -> str:
    """*
    @@md#assetFileFullPath

    `std::string assetFileFullPath(const std::string& assetRelativeFilename)` will return the path to assets.

    This works under all platforms __except Android__.
    For compatibility with Android and other platforms, prefer to use `LoadAssetFileData` whenever possible.

    * Under iOS it will give a path in the app bundle (/private/XXX/....)
    * Under emscripten, it will be stored in the virtual filesystem at "/"
    * Under Android, assetFileFullPath is *not* implemented, and will throw an error:
      assets can be compressed under android, and you cannot use standard file operations!
      Use LoadAssetFileData instead

    @@md

    """
    pass



# Advanced: forces the assets folder location
# (when using this, automatic assets installation on mobile platforms may not work)
def override_assets_folder(folder: str) -> None:
    pass
def set_assets_folder(folder: str) -> None:
    pass


# namespace HelloImGui

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_error.h included by hello_imgui.h                              //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////




#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/icons_font_awesome.h included by hello_imgui.h                             //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Generated by https://github.com/juliettef/IconFontCppHeaders script
# GenerateIconFontCppHeaders.py for language C89 from
# https://raw.githubusercontent.com/FortAwesome/Font-Awesome/master/metadata/icons.yml
# for use with
# https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-solid-900.ttf,
# https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-regular-400.ttf,


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/image_gl.h included by hello_imgui.h                                       //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/image_from_asset.h included by hello_imgui.h                               //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#*
#@@md#HelloImGui::ImageFromAsset
#
#* `HelloImGui::ImageFromAsset(const char *assetPath, size, ...)`: will display a static image from the assets.
#* `bool HelloImGui::ImageButtonFromAsset(const char *assetPath, size, ...)`: will display a button using an image from the assets.
#* `ImTextureID HelloImGui::ImTextureIdFromAsset(const char *assetPath)`: will return a texture ID for an image loaded from the assets.
#
#Images are loaded when first displayed, and then cached (they will be freed just before the application exits).
#
#For example, given this files structure:
#````
#├── CMakeLists.txt
#├── assets/
#│   └── my_image.jpg
#└── my_app.main.cpp
#````
#
#then, you can display "my_image.jpg", using:
#
#````cpp
#HelloImGui::ImageFromAsset("my_image.jpg");
#````
#
#*Note: HelloImGui::ImageFromAsset only works with OpenGL backends. It will throw an exception on other backends*
#
#@@md
#

def image_from_asset(
    asset_path: str,
    size: ImVec2 = ImVec2(0, 0),
    uv0: ImVec2 = ImVec2(0, 0),
    uv1: ImVec2 = ImVec2(1,1),
    tint_col: ImVec4 = ImVec4(1,1,1,1),
    border_col: ImVec4 = ImVec4(0,0,0,0)
    ) -> None:
    pass
def image_button_from_asset(
    asset_path: str,
    size: ImVec2 = ImVec2(0, 0),
    uv0: ImVec2 = ImVec2(0, 0),
    uv1: ImVec2 = ImVec2(1,1),
    frame_padding: int = -1,
    bg_col: ImVec4 = ImVec4(0,0,0,0),
    tint_col: ImVec4 = ImVec4(1,1,1,1)
    ) -> bool:
    pass
def im_texture_id_from_asset(asset_path: str) -> ImTextureID:
    pass



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_params.h included by hello_imgui.h                                  //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/app_window_params.h included by hello_imgui/runner_params.h                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/screen_bounds.h included by hello_imgui/app_window_params.h                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////



""" namespace BackendApi"""


class ScreenBounds:
    position: ScreenPosition = {0, 0}
    size: ScreenSize = {100, 100}

    def top_left_corner(self) -> ScreenPosition:
        pass
    def bottom_right_corner(self) -> ScreenPosition:
        pass
    def center(self) -> ScreenPosition:
        pass

    def contains(self, pixel: ScreenPosition) -> bool:
        pass

    def win_position_centered(self, window_size: ScreenSize) -> ScreenPosition:
        pass

    def distance_from_pixel(self, point: ScreenPosition) -> int:
        pass

    def ensure_window_fits_this_monitor(
        self,
        window_bounds_original: ScreenBounds
        ) -> ScreenBounds:
        pass

    def __eq__(self, other: ScreenBounds) -> bool:
        pass


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/app_window_params.h continued                                              //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////




class FullScreenMode(enum.Enum):
    no_full_screen = enum.auto()                 # (= 0)
    full_screen = enum.auto()                    # (= 1)  # Full screen with specified resolution
    full_screen_desktop_resolution = enum.auto() # (= 2)  # Full screen with current desktop mode & resolution
    full_monitor_work_area = enum.auto()         # (= 3)  # Fake full screen, maximized window on the selected monitor


class WindowSizeState(enum.Enum):
    standard = enum.auto()  # (= 0)
    minimized = enum.auto() # (= 1)
    maximized = enum.auto() # (= 2)


class WindowPositionMode(enum.Enum):
    os_default = enum.auto()     # (= 0)
    monitor_center = enum.auto() # (= 1)
    from_coords = enum.auto()    # (= 2)



class WindowGeometry:
    """*
    @@md#WindowGeometry

    __WindowGeometry__ is a struct that defines the window geometry.

    Members:
    * `size`: _int[2], default="{800, 600}"_. Size of the application window
      used if fullScreenMode==NoFullScreen and sizeAuto==False
    * `sizeAuto`: _bool, default=false_
      If True, adapt the app window size to the presented widgets
    * `fullScreenMode`: _FullScreenMode, default=NoFullScreen_.
       You can choose between several full screen modes:
       ````cpp
            NoFullScreen,
            FullScreen,                    // Full screen with specified resolution
            FullScreenDesktopResolution,   // Full screen with current desktop mode & resolution
            FullMonitorWorkArea            // Fake full screen, maximized window on the selected monitor
        ````
    * `positionMode`: _WindowPositionMode, default = OsDefault_.
       You can choose between several window position modes:
       ````cpp
            OsDefault,
            MonitorCenter,
            FromCoords,
        ````
    * `monitorIdx`: _int, default = 0_.
      used if positionMode==MonitorCenter or if fullScreenMode!=NoFullScreen
    * `windowSizeState`: _WindowSizeState, default=Standard_
       You can choose between several window size states:
       ````cpp
            Standard,
            Minimized,
            Maximized
        ````
    @@md
    *
    """
    # used if fullScreenMode==NoFullScreen and sizeAuto==False, default=(800, 600)
    size: ScreenSize = DefaultScreenSize

    # If True, adapt the app window size to the presented widgets
    size_auto: bool = False

    full_screen_mode: FullScreenMode = FullScreenMode.no_full_screen

    position_mode: WindowPositionMode = WindowPositionMode.os_default

    # used if windowPositionMode==FromCoords, default=(40, 40)
    position: ScreenPosition = DefaultScreenPosition

    # used if positionMode==MonitorCenter or if fullScreenMode!=NoFullScreen
    monitor_idx: int = 0

    window_size_state: WindowSizeState = WindowSizeState.standard


class AppWindowParams:
    """*
    @@md#AppWindowParams

    __AppWindowParams__ is a struct that defines the application window display params.
    See [doc_src/hello_imgui_diagram.png](https://raw.githubusercontent.com/pthom/hello_imgui/master/src/hello_imgui/doc_src/hello_imgui_diagram.png)
    for details.

    Members:
    * `windowTitle`: _string, default=""_. Title of the application window
    * `windowGeometry`: _WindowGeometry_
      Enables to precisely set the window geometry (position, monitor, size, full screen, fake full screen, etc.)
       _Note: on a mobile device, the application will always be full screen._
    * `restorePreviousGeometry`: _bool, default=false_.
      If True, then save & restore windowGeometry from last run (the geometry will be written in imgui_app_window.ini)
    * `borderless`: _bool, default = false_.
    * `resizable`: _bool, default = false_.

    Output Member:
    * `outWindowDpiFactor`: _float, default = 1_.
       This value is filled by HelloImGui during the window initialisation. On Windows and Linux, it can be > 1
       on high resolution monitors (on MacOS, the scaling is handled by the system).
       When loading fonts, their size should be multiplied by this factor.
    @@md
    *
    """
    window_title: str

    window_geometry: WindowGeometry

    # if True, then save & restore from last run
    restore_previous_geometry: bool = False

    borderless: bool = False
    resizable: bool = True

    out_window_dpi_factor: float = 1.



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_theme.h included by hello_imgui/imgui_window_params.h                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#
# Theme tweak utilities for ImGui.
# Reuse and adaptation of imgui_theme.h and imgui_theme.cpp file is granted for other projects,
# provided the origin of those files is stated in the copied version
# Some themes were adapted by themes posted by ImGui users at https://github.com/ocornut/imgui/issues/707
#

""" namespace ImGuiTheme"""
class ImGuiTheme_(enum.Enum):
    imgui_colors_classic = enum.auto()   # (= 0)
    imgui_colors_dark = enum.auto()      # (= 1)
    imgui_colors_light = enum.auto()     # (= 2)
    material_flat = enum.auto()          # (= 3)
    photoshop_style = enum.auto()        # (= 4)
    gray_variations = enum.auto()        # (= 5)
    gray_variations_darker = enum.auto() # (= 6)
    microsoft_style = enum.auto()        # (= 7)
    cherry = enum.auto()                 # (= 8)
    darcula = enum.auto()                # (= 9)
    darcula_darker = enum.auto()         # (= 10)
    light_rounded = enum.auto()          # (= 11)
    so_dark_accent_blue = enum.auto()    # (= 12)
    so_dark_accent_yellow = enum.auto()  # (= 13)
    so_dark_accent_red = enum.auto()     # (= 14)
    black_is_black = enum.auto()         # (= 15)
    white_is_white = enum.auto()         # (= 16)
    count = enum.auto()                  # (= 17)
def imgui_theme_name(theme: ImGuiTheme_) -> str:
    pass
def theme_to_style(theme: ImGuiTheme_) -> ImGuiStyle:
    pass
def apply_theme(theme: ImGuiTheme_) -> None:
    pass


class ImGuiThemeTweaks:
    # Common rounding for widgets. If < 0, this is ignored.
    rounding: float = -1.
    # If rounding is applied, scrollbar rounding needs to be adjusted to be visually pleasing in conjunction with other widgets roundings. Only applied if Rounding > 0.)
    rounding_scrollbar_ratio: float = 4.
    # Change the alpha that will be applied to windows, popups, etc. If < 0, this is ignored.
    alpha_multiplier: float = -1.

    #
    # HSV Color tweaks
    #
    # Change the hue of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.
    hue: float = -1.
    # Multiply the saturation of all widgets (gray widgets will remain gray, since their saturation is zero). If < 0, this is ignored.
    saturation_multiplier: float = -1.
    # Multiply the value (luminance) of all front widgets. If < 0, this is ignored.
    value_multiplier_front: float = -1.
    # Multiply the value (luminance) of all backgrounds. If < 0, this is ignored.
    value_multiplier_bg: float = -1.
    # Multiply the value (luminance) of text. If < 0, this is ignored.
    value_multiplier_text: float = -1.
    # Multiply the value (luminance) of FrameBg. If < 0, this is ignored.
    # (Background of checkbox, radio button, plot, slider, text input)
    value_multiplier_frame_bg: float = -1.

class ImGuiTweakedTheme:
    theme: ImGuiTheme_ = ImGuiTheme_.darcula_darker
    tweaks: ImGuiThemeTweaks = {}

def tweaked_theme_theme_to_style(
    tweaked_theme: ImGuiTweakedTheme
    ) -> ImGuiStyle:
    pass
def apply_tweaked_theme(tweaked_theme: ImGuiTweakedTheme) -> None:
    pass

def show_theme_tweak_gui(tweaked_theme: ImGuiTweakedTheme) -> bool:
    """ Show the theme selection listbox, the theme tweak widgets, as well as ImGui::ShowStyleEditor. Returns True if modified (Warning, when using ShowStyleEditor, no info about modification is transmitted)"""
    pass

# Some tweakable themes
def so_dark(hue: float) -> ImGuiStyle:
    pass
def shades_of_gray(
    rounding: float = 0.,
    value_multiplier_front: float = 1.,
    value_multiplier_bg: float = 1.
    ) -> ImGuiStyle:
    pass
def darcula(
    rounding: float = 1.,
    hue: float = -1.,
    saturation_multiplier: float = 1.,
    value_multiplier_front: float = 1.,
    value_multiplier_bg: float = 1.,
    alpha_bg_transparency: float = 1.
    ) -> ImGuiStyle:
    pass





#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_window_params.h continued                                            //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""
class DefaultImGuiWindowType(enum.Enum):
    """*
    @@md#DefaultImGuiWindowType

    __DefaultImGuiWindowType__ is an enum class that defines whether or not a full screen background window is provided.

     Values:
      * _ProvideFullScreenWindow_: a full window is provided in the background
      * _ProvideFullScreenDockSpace_: a full screen dockspace is provided in the background
      * _NoDefaultWindow_: No default window is provided (except for ImGui's default "debug" window)

    @@md

    """
    provide_full_screen_window = enum.auto()     # (= 0)
    provide_full_screen_dock_space = enum.auto() # (= 1)
    no_default_window = enum.auto()              # (= 2)

class ImGuiWindowParams:
    """*
    @@md#ImGuiWindowParams

    __ImGuiWindowParams__ is a struct that defines the ImGui inner windows params
    These settings affect the imgui inner windows inside the application window.
    In order to change the application window settings, change the _AppWindowsParams_

     Members:

      * `defaultImGuiWindowType`: _DefaultImGuiWindowType, default=ProvideFullScreenWindow_.
          By default, a full window is provided in the background. You can still
          add windows on top of it, since the Z-order of this background window is always behind

      * `backgroundColor`: _ImVec4, default=ImVec4(0.45, 0.55, 0.60, 1.00)_.
          This is the "clearColor", only visible is defaultImGuiWindowType is NoDefaultWindow.

      * `showMenuBar`: _bool, default=false_.
        Show Menu bar on top of imgui main window
        You can customize the menu via `RunnerCallbacks.ShowMenus()`

      * `showMenu_App`: _bool, default=true_.
        If menu bar is shown, include or not the default app menu (with Quit button)

      * `showMenu_View`: _bool, default=true_.
        If menu bar is shown, include or not the default _View_ menu, that enables to change the layout and
        set the docked windows and status bar visibility)

      * `showStatusBar`: _bool, default=false_.
        Flag that enable to show a Status bar at the bottom. You can customize the status bar
        via RunnerCallbacks.ShowStatus()

      * `showStatus_Fps`: _bool, default=true_. If set, display the FPS in the status bar.

      * `configWindowsMoveFromTitleBarOnly`: _bool, default=true_.
        Make windows only movable from the title bar

      * `enableViewports`: _bool, default=false_. Enable multiple viewports (i.e multiple native windows)
        If True, you can drag windows outside out the main window in order to put their content into new native windows.

      * `tweakedTheme`: _string, default="ImGuiColorsDark"_.
        Change the ImGui theme. Several themes are available, you can query the list by calling
        HelloImGui::AvailableThemes()
    @@md

    """
    default_imgui_window_type: DefaultImGuiWindowType = DefaultImGuiWindowType.provide_full_screen_window

    background_color: ImVec4 = ImVec4(0.45, 0.55, 0.60, 1.00)

    show_menu_bar: bool = False
    show_menu_app: bool = True
    show_menu_view: bool = True

    show_status_bar: bool = False
    show_status_fps: bool = True

    config_windows_move_from_title_bar_only: bool = True

    enable_viewports: bool = False

    tweaked_theme: ImGuiTheme.ImGuiTweakedTheme


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_callbacks.h included by hello_imgui/runner_params.h                 //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/imgui_default_settings.h included by hello_imgui/runner_callbacks.h        //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
""" namespace HelloImGui"""
def load_font_ttf(
    font_filename: str,
    font_size: float,
    use_full_glyph_range: bool = False,
    config: ImFontConfig = ImFontConfig()
    ) -> ImFont:
    pass
def load_font_ttf_with_font_awesome_icons(
    font_filename: str,
    font_size: float,
    use_full_glyph_range: bool = False,
    config_font: ImFontConfig = ImFontConfig(),
    config_icons: ImFontConfig = ImFontConfig()
    ) -> ImFont:
    pass
def merge_font_awesome_to_last_font(
    font_size: float,
    config: ImFontConfig = ImFontConfig()
    ) -> ImFont:
    pass



#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_callbacks.h continued                                               //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#*
#@@md#VoidFunction_AnyEventCallback
#
#**VoidFunctionPointer** can hold any None(None) function.
#````cpp
#using VoidFunction = std::function<None(None)>
#````
#
#**AnyEventCallback** can hold any bool(None *) function.
#  It is designed to handle callbacks for a specific backend.
#````cpp
#using AnyEventCallback = std::function<bool(None * backendEvent)>
#````
#
#@@md
#*

class MobileCallbacks:
    """*
    @@md#MobileCallbacks

    **MobileCallbacks** is a struct that contains callbacks that are called by the application
     when running under "Android, iOS and WinRT".
     These events are specific to mobile and embedded devices that have different requirements
     than your usual desktop application. These events must be handled quickly,
     since often the OS needs an immediate response and will terminate your process shortly
     after sending the event if you do not handle them apprpriately.

     Note: on mobile devices, it is not possible to "Quit" an application, it can only be put on Pause.

     * `OnDestroy`: _VoidFunction, default=empty_. The application is being terminated by the OS.
     * `OnLowMemory`: _VoidFunction, default=empty_. The application is low on memory, free memory if possible.
     * `OnPause`: _VoidFunction, default=empty_. The application is about to enter the background.
     * `OnResume`: _VoidFunction, default=empty_. The application is has come to foreground and is now interactive.

     Note: 'OnPause' and 'OnResume' are called twice consecutively under iOS (before and after entering background
     or foreground).

    @@md

    """
    on_destroy: VoidFunction = {}
    on_low_memory: VoidFunction = {}
    on_pause: VoidFunction = {}
    on_resume: VoidFunction = {}

class RunnerCallbacks:
    """*
     @@md#RunnerCallbacks

     **RunnerCallbacks** is a struct that contains the callbacks that are called by the application

     _Members_

    * `ShowGui`: *VoidFunction, default=empty*.
      Fill it with a function that will add your widgets.

    * `ShowMenus`: *VoidFunction, default=empty*.
        A function that will render your menus. Fill it with a function that will add ImGui menus by calling:
        _ImGui::BeginMenu(...) / ImGui::MenuItem(...) / ImGui::EndMenu()_

        _Notes:_
        * you do not need to call _ImGui::BeginMenuBar_ and _ImGui::EndMenuBar_
        * Some default menus can be provided: see _ImGuiWindowParams_ options
          (_showMenuBar, showMenu_App_QuitAbout, showMenu_View_)

    * `ShowStatus`: *VoidFunction, default=empty*.
      A function that will add items to the status bar. Use small items (ImGui::Text for example),
      since the height of the status is 30. Also, remember to call ImGui::SameLine() between items.

    * `PostInit`: *VoidFunction, default=empty*.
        You can here add a function that will be called once after OpenGL and ImGui are inited

    * `BeforeExit`: *VoidFunction, default=empty*.
        You can here add a function that will be called once before exiting (when OpenGL and ImGui are
        still inited)

    * `AnyBackendEventCallback`: *AnyBackendCallback, default=empty*.
      Callbacks for events from a specific backend. _Only implemented for SDL, where the event
      will be of type 'SDL_Event *'_
      This callback should return True if the event was handled and shall not be processed further.

    * `LoadAdditionalFonts`: *VoidFunction, default=_LoadDefaultFont_WithFontAwesome*.
       A function that is called when fonts are ready to be loaded.
       By default, _LoadDefaultFont_WithFontAwesome_ is called but you can copy-customize it.

    * `SetupImGuiConfig`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.
        If needed, change ImGui config via SetupImGuiConfig (enable docking, gamepad, etc)

    * `SetupImGuiStyle`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.
        If needed, setup your own style by providing your own SetupImGuiStyle callback


    * `mobileCallbacks`: *_MobileCallbacks_*. Callbacks that are called by the application
        when running under "Android, iOS and WinRT".
    Notes:
      * 'mobileCallbacks' is present only if the target device is a mobile device (iOS, Android).
         Use `#ifdef HELLOIMGUI_MOBILEDEVICE` to detect this.
      * These events are currently handled only with SDL backend.

    @@md

    """
    show_gui: VoidFunction = {}
    show_menus: VoidFunction = {}
    show_status: VoidFunction = {}
    post_init: VoidFunction = {}
    before_exit: VoidFunction = {}

    any_backend_event_callback: AnyEventCallback = {}

    load_additional_fonts: VoidFunction = ImGuiDefaultSettings.LoadDefaultFont_WithFontAwesomeIcons
    setup_imgui_config: VoidFunction = ImGuiDefaultSettings.SetupDefaultImGuiConfig
    setup_imgui_style: VoidFunction = ImGuiDefaultSettings.SetupDefaultImGuiStyle



# namespace HelloImGui

#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/docking_params.h included by hello_imgui/runner_params.h                   //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""
#*
#@@md#DockingIntro
#
#HelloImGui facilitates the use of dockable windows (based on ImGui [docking branch](https://github.com/ocornut/imgui/tree/docking)).
#
#You can easily specify the default layout of the dockable windows, as well as their GUI code.
#HelloImGui will then provide a "View" menu with options in order to show/hide the dockable windows, and to restore the default layout
#
#![demo docking](../../docs/images/docking.gif)
#
#Source for this example: [src/hello_imgui_demos/hello_imgui_demodocking](../../src/hello_imgui_demos/hello_imgui_demodocking)
#
#This is done via the `DockingParams` struct: its member `dockingSplits` specifies the layout,
#and its member `dockableWindows` specifies the list of dockable windows, along with their default location,
#and their code (given by lambdas). See doc below for more details.
#
# @@md
#
#
#@@md#DockingExample
#
#Docking params: Example usage
#
#````cpp
#HelloImGui::RunnerParams runnerParams;
#runnerParams.imGuiWindowParams.defaultImGuiWindowType =
#    HelloImGui::DefaultImGuiWindowType::ProvideFullScreenDockSpace;
#
#runnerParams.dockingParams.dockingSplits =
#{
#    // First, add a bottom space whose height is 25% of the app height
#    // This will split the preexisting default dockspace "MainDockSpace"
#    // in two parts.
#    { "MainDockSpace", "BottomSpace", ImGuiDir_Down, 0.25 },
#    // Then, add a space to the left which occupies a column
#    // whose width is 25% of the app height
#    { "MainDockSpace", "LeftSpace", ImGuiDir_Left, 0.25 }
#    // We now have three spaces: "MainDockSpace", "BottomSpace", and "LeftSpace"
#};
#runnerParams.dockingParams.dockableWindows =
#{
#    // A Window named "Main" will be placed in "MainDockSpace".
#    // Its Gui is provided by the VoidFunction "MainGui"
#    {"Main", "MainDockSpace", MainGui},
#    // A Log  window named "Logs" will be placed in "BottomSpace".
#    // Its Gui is provided by the VoidFunction "ShowLogs"
#    {"Logs", "BottomSpace", ShowLogs},
#    // A Command panel named "Commands" will be placed in "LeftSpace".
#    // Its Gui is provided by the VoidFunction "ShowCommandsPanel"
#    {"Commands", "LeftSpace", ShowCommandsPanel}
#};
#
#runnerParams.imGuiWindowParams.showMenuBar = True;
#runnerParams.imGuiWindowParams.showStatusBar = True;
#
#HelloImGui::Run(runnerParams);
#````
#
#@@md
#

#***************************************************************************


class DockingSplit:
    """*
    @@md#DockingSplit

    **DockingSplit** is a struct that defines the way the docking splits should be applied on the screen
    in order to create new Dock Spaces. _DockingParams_ contains a _vector[DockingSplit]_,
    in order to partition the screen at your will.

    _Members:_

    * `initialDock`: _DockSpaceName (aka string)_

        id of the space that should be split.
        At the start, there is only one Dock Space named "MainDockSpace".
        You should start by partitioning this space, in order to create a new dock space.

    * `newDock`: _DockSpaceName (aka string)_. id of the new dock space that will be created
    * `direction`: *ImGuiDir_ (enum with ImGuiDir_Down, ImGuiDir_Down, ImGuiDir_Left, ImGuiDir_Right)*.
    Direction where this dock space should be created
    * `ratio`: _float, default=0.25_. Ratio of the initialDock size that should be used by the new dock space

    @@md

    """

    initial_dock: DockSpaceName
    new_dock: DockSpaceName
    direction: ImGuiDir_
    ratio: float = 0.25

class DockableWindow:
    """*
    @@md#DockableWindow

    **DockableWindow** is a struct that represents a window that can be docked.

    _Members:_

    * `label`: _string_. Title of the window.
    * `dockSpaceName`: _DockSpaceName (aka string)_. Id of the dock space where this window
       should initialy be placed
    * `GuiFunction`: _VoidFuntion_. Any function that will render this window's Gui.
    * `isVisible`: _bool, default=true_. Flag that indicates whether this window is visible or not.
    * `canBeClosed`: _bool, default=true_. Flag that indicates whether the user can close this window.
    * `callBeginEnd`: _bool, default=true_. Flag that indicates whether ImGui::Begin and ImGui::End
       calls should be added automatically (with the given "label"). Set to False if you want to call
       ImGui::Begin/End yourself
    * `includeInViewMenu`: _bool, default=true_. Flag that indicates whether this window should be mentioned
       in the view menu.
    * `imGuiWindowFlags`: _ImGuiWindowFlags, default=0_. Window flags, see enum ImGuiWindowFlags_
    * `windowSize`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window size (unused if docked)
    * `windowSizeCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window size.
    * `windowPos`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window position (unused if docked)
    * `windowPosCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window position.
    * `focusWindowAtNextFrame`: _bool, default = false_. If set to True this window will be focused at the next frame.

    @@md
    *
    """

    label: str

    dock_space_name: DockSpaceName

    gui_function: VoidFunction = {}

    is_visible: bool = True
    can_be_closed: bool = True
    call_begin_end: bool = True
    include_in_view_menu: bool = True
    imgui_window_flags: ImGuiWindowFlags = 0

    window_size: ImVec2 = ImVec2(0., 0.)
    window_size_condition: ImGuiCond = ImGuiCond_FirstUseEver

    window_position: ImVec2 = ImVec2(0., 0.)
    window_position_condition: ImGuiCond = ImGuiCond_FirstUseEver

    focus_window_at_next_frame: bool = False

class DockingParams:
    """*
    @@md#DockingParams

    **DockingParams** contains all the settings concerning the docking,
     together _with the Gui functions for the docked windows_.

     _Members:_

    * `dockingSplits`: _vector[DockingSplit]_.
      Defines the way docking splits should be applied on the screen in order to create new Dock Spaces
    * `dockableWindows`: _vector[DockableWindow]_.
      List of the dockable windows, together with their Gui code
    * `resetUserDockLayout`: _bool, default=true_.
      Reset user layout at application startup

     _Helpers:_

     * `DockableWindow * dockableWindowOfName(const std::string & name)`: returns a pointer to a dockable window
     * `None focusDockableWindow(const std::string& name)`: will focus a dockable window

    @@md

    """
    docking_splits: List[DockingSplit]

    dockable_windows: List[DockableWindow]

    reset_user_dock_layout: bool = True

    # wasDockLayoutApplied is an internal variable
    was_dock_layout_applied: bool = False

    def dockable_window_of_name(self, name: str) -> DockableWindow:
        pass
    def focus_dockable_window(self, window_name: str) -> None:
        pass


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/backend_pointers.h included by hello_imgui/runner_params.h                 //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""

class BackendPointers:
    """*
     @@md#BackendPointers

    **BackendPointers** is a struct that contains optional pointers to the backend implementations (for SDL and GLFW).

    These pointers will be filled when the application starts, and you can use them to customize
    your application behavior using the selected backend.

     Members:
    * `glfwWindow`: _void *, default=nullptr_. Pointer to the main GLFW window (of type `GLFWwindow*`).
      Only filled if the backend is GLFW.
    * `sdlWindow`: _void *, default=nullptr_. Pointer to the main SDL window (of type `SDL_Window*`).
      Only filled if the backend is SDL (or emscripten + sdl)
    * `sdlGlContext`: _void *, default=nullptr_. Pointer to SDL's GlContext (of type `SDL_GLContext`).
      Only filled if the backend is SDL (or emscripten + sdl)

    @@md

    """
    # GLFWwindow*
    glfw_window: Any = None

    # SDL_Window*
    sdl_window: Any = None
    # SDL_GLContext
    sdl_gl_context: Any = None




#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/runner_params.h continued                                                  //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////

""" namespace HelloImGui"""

class BackendType(enum.Enum):
    first_available = enum.auto() # (= 0)
    sdl = enum.auto()             # (= 1)
    glfw = enum.auto()            # (= 2)
    qt = enum.auto()              # (= 3)

class RunnerParams:
    """*
     @@md#RunnerParams

    **RunnerParams** is a struct that contains all the settings and callbacks needed to run an application.

     Members:
    * `callbacks`: _see [runner_callbacks.h](runner_callbacks.h)_.
        callbacks.ShowGui() will render the gui, ShowMenus() will show the menus, etc.
    * `appWindowParams`: _see [app_window_params.h](app_window_params.h)_.
        application Window Params (position, size, title)
    * `imGuiWindowParams`: _see [imgui_window_params.h](imgui_window_params.h)_.
        imgui window params (use docking, showMenuBar, ProvideFullScreenWindow, etc)
    * `dockingParams`: _see [docking_params.h](docking_params.h)_.
        dockable windows content and layout
    * `backendPointers`: _see [backend_pointers.h](backend_pointers.h)_.
       A struct that contains optional pointers to the backend implementations. These pointers will be filled
       when the application starts
    * `backendType`: _enum BackendType, default=BackendType::FirstAvailable_
      Select the wanted backend type between `Sdl`, `Glfw` and `Qt`. Only useful when multiple backend are compiled
      and available.
    * `appShallExit`: _bool, default=false_.
       Will be set to True by the app when exiting.
       _Note: 'appShallExit' has no effect on Mobile Devices (iOS, Android) and under emscripten, since these apps
       shall not exit._
    * `fpsIdle`: _float, default=10_.
      ImGui applications can consume a lot of CPU, since they update the screen very frequently.
      In order to reduce the CPU usage, the FPS is reduced when no user interaction is detected.
      This is ok most of the time but if you are displaying animated widgets (for example a live video),
      you may want to ask for a faster refresh: either increase fpsIdle, or set it to 0 for maximum refresh speed
      (you can change this value during the execution depending on your application refresh needs)
    * `emscripten_fps`: _int, default = 0_.
      Set the application refresh rate (only used on emscripten: 0 stands for "let the app or the browser decide")
    @@md

    """
    callbacks: RunnerCallbacks
    app_window_params: AppWindowParams
    imgui_window_params: ImGuiWindowParams
    docking_params: DockingParams
    backend_pointers: BackendPointers
    backend_type: BackendType = BackendType.first_available
    app_shall_exit: bool = False

    fps_idle: float = 10.

    emscripten_fps: int = 0


class SimpleRunnerParams:
    """*
     @@md#SimpleRunnerParams

    **RunnerParams** is a struct that contains simpler params adapted for simple uses

     Members:
    * `guiFunction`: _VoidFunction_.
       Function that renders the Gui.
    * `windowTitle`: _string, default=""_.
       Title of the application window
    * `windowSizeAuto`: _bool, default=false_.
       If True, the size of the window will be computed from its widgets.
    * `windowRestorePreviousGeometry`: _bool, default=true_.
       If True, restore the size and position of the window between runs.
    * `windowSize`: _ScreenSize, default={800, 600}_.
       Size of the window
    * `fpsIdle`: _float, default=10_.
       FPS of the application when idle (set to 0 for full speed).
    @@md

    """
    gui_function: VoidFunction
    window_title: str = ""

    window_size_auto: bool = False
    window_restore_previous_geometry: bool = False
    window_size: ScreenSize = {800, 600}

    fps_idle: float = 10.

    def to_runner_params(self) -> RunnerParams:
        pass


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui/hello_imgui_logger.h included by hello_imgui.h                             //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
"""*
@@md#HelloImGui::Log

HelloImGui provides a simple Log utility that is able to collect message and display them with a specific widget.

* __HelloImGui::Log(LogLevel level, char const* const format, ... )__ will log a message (printf like format)
* __HelloImGui::LogClear()__ will clear the Log list
* __HelloImGui::LogGui()__ will display the Log widget

@@md

"""
class LogLevel(enum.Enum):
    debug = enum.auto()   # (= 0)
    info = enum.auto()    # (= 1)
    warning = enum.auto() # (= 2)
    error = enum.auto()   # (= 3)

def log(level: LogLevel, format: str) -> None:
    pass
def log_clear() -> None:
    pass
def log_gui() -> None:
    pass


#////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#                       hello_imgui.h continued                                                                //
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////




"""*
@@md#HelloImGui::Run

__HelloImGui::Run()__ will run an application with a single call.

Three signatures are provided:

* `HelloImGui::Run(RunnerParams &)`: full signature, the most customizable version.
   Runs an application whose params and Gui are provided by runnerParams.

* `HelloImGui::Run(const SimpleRunnerParams&)`:
   Runs an application, using simpler params.

* `HelloImGui::Run(guiFunction, windowTitle, windowSize, windowSizeAuto=False, restoreLastWindowGeometry=False, fpsIdle=10)`

__HelloImGui::GetRunnerParams()__ is a convenience function that will return the runnerParams of the current application.

@@md

"""

def run(runner_params: RunnerParams) -> None:
    pass

def run(simple_params: SimpleRunnerParams) -> None:
    pass

def run(
    gui_function: VoidFunction,
    window_title: str = "",
    window_size_auto: bool = False,
    window_restore_previous_geometry: bool = False,
    window_size: ScreenSize = DefaultWindowSize,
    fps_idle: float = 10.
    ) -> None:
    pass

def get_runner_params() -> RunnerParams:
    pass


#*
#@@md#SDLMain
#
#Warning for SDL apps under iOS and Android:
#
#SDL uses a dirty hack in order to _replace your main() function by its own main() function_,
#which will then call your own main !
#
#Please make sure that the signature of your main() function is *exactly*
#    `int main(int argc, char **argv)`
#and that your main() function returns an int.
#
#@@md
#

# <submodule ImGuiDefaultSettings>
class ImGuiDefaultSettings:  # Proxy class that introduces typings for the *submodule* ImGuiDefaultSettings
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace ImGuiDefaultSettings"""
    def load_default_font_with_font_awesome_icons() -> None:
        pass
    def setup_default_imgui_config() -> None:
        pass
    def setup_default_imgui_style() -> None:
        pass

# </submodule ImGuiDefaultSettings>
####################    </generated_from:hello_imgui_amalgamation.h>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


import numpy as np


def final_app_window_screenshot() -> np.ndarray:
    """Return a screenshot of the final screen of the last (exited) app
    """
    pass
