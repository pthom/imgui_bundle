#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>

#include "hello_imgui/hello_imgui.h"

namespace py = pybind11;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_hello_imgui(py::module& m)
{
    using namespace HelloImGui;

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:hello_imgui_amalgamation.h>    ////////////////////
    auto pyClassAssetFileData =
        py::class_<HelloImGui::AssetFileData>
            (m, "AssetFileData", "*\n@@md#LoadAssetFileData\n\n    * `AssetFileData LoadAssetFileData(const char *assetPath)` will load an entire asset file into memory.\n     This works on all platforms, including android.\n     ````cpp\n        struct AssetFileData\n        {\n            None * data = None;\n            size_t dataSize = 0;\n        };\n     ````\n    * `FreeAssetFileData(AssetFileData * assetFileData)` will free the memory.\n\n      Note about ImGui: \"ImGui::GetIO().Fonts->AddFontFromMemoryTTF\" takes ownership of the data\n      and will free the memory for you.\n\n@@md\n*")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("data", &HelloImGui::AssetFileData::data, "")
        .def_readwrite("data_size", &HelloImGui::AssetFileData::dataSize, "")
        ;


    m.def("load_asset_file_data",
        HelloImGui::LoadAssetFileData, py::arg("asset_path"));

    m.def("free_asset_file_data",
        HelloImGui::FreeAssetFileData, py::arg("asset_file_data"));

    m.def("asset_file_full_path",
        HelloImGui::assetFileFullPath,
        py::arg("asset_relative_filename"),
        "*\n@@md#assetFileFullPath\n\n    `std::string assetFileFullPath(const std::string& assetRelativeFilename)` will return the path to assets.\n\n    This works under all platforms __except Android__.\n    For compatibility with Android and other platforms, prefer to use `LoadAssetFileData` whenever possible.\n\n    * Under iOS it will give a path in the app bundle (/private/XXX/....)\n    * Under emscripten, it will be stored in the virtual filesystem at \"/\"\n    * Under Android, assetFileFullPath is *not* implemented, and will throw an error:\n      assets can be compressed under android, and you cannot use standard file operations!\n      Use LoadAssetFileData instead\n\n@@md\n");

    m.def("override_assets_folder",
        HelloImGui::overrideAssetsFolder, py::arg("folder"));

    m.def("set_assets_folder",
        HelloImGui::setAssetsFolder, py::arg("folder"));


    m.def("image_from_asset",
        HelloImGui::ImageFromAsset, py::arg("asset_path"), py::arg("size") = ImVec2(0, 0), py::arg("uv0") = ImVec2(0, 0), py::arg("uv1") = ImVec2(1,1), py::arg("tint_col") = ImVec4(1,1,1,1), py::arg("border_col") = ImVec4(0,0,0,0));

    m.def("image_button_from_asset",
        HelloImGui::ImageButtonFromAsset, py::arg("asset_path"), py::arg("size") = ImVec2(0, 0), py::arg("uv0") = ImVec2(0, 0), py::arg("uv1") = ImVec2(1,1), py::arg("frame_padding") = -1, py::arg("bg_col") = ImVec4(0,0,0,0), py::arg("tint_col") = ImVec4(1,1,1,1));

    m.def("im_texture_id_from_asset",
        HelloImGui::ImTextureIdFromAsset, py::arg("asset_path"));


    auto pyClassAppWindowParams =
        py::class_<HelloImGui::AppWindowParams>
            (m, "AppWindowParams", "*\n@@md#AppWindowParams\n\n    __AppWindowParams__ is a struct that defines the application window display params.\n\n    Members:\n    * `windowTitle`: _string, default=\"\"_. Title of the application window\n    * `windowSize`: _ImVec2, default (800,600)_. Size of the window.\n    * `maximized`: _bool, default=false_. If this boolean flag is True, the application window\n       will occupy the full space of the primary screen\n    * `fullScreen`: _bool, default=false_. If this boolean flag is True, the application window\n       will be full screen, with no decorations.\n        _Note: on a mobile device, the application will always be full screen._\n    * `windowPosition`: _ImVec2, default=(-11000, -1)_. Position of the window if x >= -1000,\n       else let the OS decide\n\n@@md\n*")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("window_title", &HelloImGui::AppWindowParams::windowTitle, "")
        .def_readwrite("window_size", &HelloImGui::AppWindowParams::windowSize, "")
        .def_readwrite("maximized", &HelloImGui::AppWindowParams::maximized, "")
        .def_readwrite("full_screen", &HelloImGui::AppWindowParams::fullScreen, "")
        .def_readwrite("window_position", &HelloImGui::AppWindowParams::windowPosition, "")
        ;


    py::enum_<HelloImGui::DefaultImGuiWindowType>(m, "DefaultImGuiWindowType", py::arithmetic(), "*\n@@md#DefaultImGuiWindowType\n\n    __DefaultImGuiWindowType__ is an enum class that defines whether or not a full screen background window is provided.\n\n     Values:\n      * _ProvideFullScreenWindow_: a full window is provided in the background\n      * _ProvideFullScreenDockSpace_: a full screen dockspace is provided in the background\n      * _NoDefaultWindow_: No default window is provided (except for ImGui's default \"debug\" window)\n\n@@md\n")
        .value("provide_full_screen_window", HelloImGui::DefaultImGuiWindowType::ProvideFullScreenWindow, "")
        .value("provide_full_screen_dock_space", HelloImGui::DefaultImGuiWindowType::ProvideFullScreenDockSpace, "")
        .value("no_default_window", HelloImGui::DefaultImGuiWindowType::NoDefaultWindow, "");


    auto pyClassImGuiWindowParams =
        py::class_<HelloImGui::ImGuiWindowParams>
            (m, "ImGuiWindowParams", "*\n@@md#ImGuiWindowParams\n\n    __ImGuiWindowParams__ is a struct that defines the ImGui inner windows params\n    These settings affect the imgui inner windows inside the application window.\n    In order to change the application window settings, change the _AppWindowsParams_\n\n     Members:\n\n      * `defaultImGuiWindowType`: _DefaultImGuiWindowType, default=ProvideFullScreenWindow_.\n          By default, a full window is provided in the background. You can still\n          add windows on top of it, since the Z-order of this background window is always behind\n\n      * `backgroundColor`: _ImVec4, default=ImVec4(0.45, 0.55, 0.60, 1.00)_.\n          This is the \"clearColor\", only visible is defaultImGuiWindowType is NoDefaultWindow.\n\n      * `showMenuBar`: _bool, default=false_.\n        Show Menu bar on top of imgui main window\n        You can customize the menu via `RunnerCallbacks.ShowMenus()`\n\n      * `showMenu_App`: _bool, default=true_.\n        If menu bar is shown, include or not the default app menu (with Quit button)\n\n      * `showMenu_View`: _bool, default=true_.\n        If menu bar is shown, include or not the default _View_ menu, that enables to change the layout and\n        set the docked windows and status bar visibility)\n\n      * `showStatusBar`: _bool, default=false_.\n        Flag that enable to show a Status bar at the bottom. You can customize the status bar\n        via RunnerCallbacks.ShowStatus()\n\n      * `showStatus_Fps`: _bool, default=true_. If set, display the FPS in the status bar.\n\n      * `configWindowsMoveFromTitleBarOnly`: _bool, default=true_.\n        Make windows only movable from the title bar\n\n      * `enableViewports`: _bool, default=false_. Enable multiple viewports (i.e multiple native windows)\n        If True, you can drag windows outside out the main window in order to put their content into new native windows.\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("default_imgui_window_type", &HelloImGui::ImGuiWindowParams::defaultImGuiWindowType, "")
        .def_readwrite("background_color", &HelloImGui::ImGuiWindowParams::backgroundColor, "")
        .def_readwrite("show_menu_bar", &HelloImGui::ImGuiWindowParams::showMenuBar, "")
        .def_readwrite("show_menu_app", &HelloImGui::ImGuiWindowParams::showMenu_App, "")
        .def_readwrite("show_menu_view", &HelloImGui::ImGuiWindowParams::showMenu_View, "")
        .def_readwrite("show_status_bar", &HelloImGui::ImGuiWindowParams::showStatusBar, "")
        .def_readwrite("show_status_fps", &HelloImGui::ImGuiWindowParams::showStatus_Fps, "")
        .def_readwrite("config_windows_move_from_title_bar_only", &HelloImGui::ImGuiWindowParams::configWindowsMoveFromTitleBarOnly, "")
        .def_readwrite("enable_viewports", &HelloImGui::ImGuiWindowParams::enableViewports, "")
        ;


    m.def("load_font_ttf",
        HelloImGui::LoadFontTTF,
        py::arg("font_filename"), py::arg("font_size"), py::arg("use_full_glyph_range") = false, py::arg("config") = ImFontConfig(),
        pybind11::return_value_policy::reference);

    m.def("load_font_ttf_with_font_awesome_icons",
        HelloImGui::LoadFontTTF_WithFontAwesomeIcons,
        py::arg("font_filename"), py::arg("font_size"), py::arg("use_full_glyph_range") = false, py::arg("config_font") = ImFontConfig(), py::arg("config_icons") = ImFontConfig(),
        pybind11::return_value_policy::reference);

    m.def("merge_font_awesome_to_last_font",
        HelloImGui::MergeFontAwesomeToLastFont,
        py::arg("font_size"), py::arg("config") = ImFontConfig(),
        pybind11::return_value_policy::reference);


    auto pyClassMobileCallbacks =
        py::class_<HelloImGui::MobileCallbacks>
            (m, "MobileCallbacks", "*\n@@md#MobileCallbacks\n\n    **MobileCallbacks** is a struct that contains callbacks that are called by the application\n     when running under \"Android, iOS and WinRT\".\n     These events are specific to mobile and embedded devices that have different requirements\n     than your usual desktop application. These events must be handled quickly,\n     since often the OS needs an immediate response and will terminate your process shortly\n     after sending the event if you do not handle them apprpriately.\n\n     Note: on mobile devices, it is not possible to \"Quit\" an application, it can only be put on Pause.\n\n     * `OnDestroy`: _VoidFunction, default=empty_. The application is being terminated by the OS.\n     * `OnLowMemory`: _VoidFunction, default=empty_. The application is low on memory, free memory if possible.\n     * `OnPause`: _VoidFunction, default=empty_. The application is about to enter the background.\n     * `OnResume`: _VoidFunction, default=empty_. The application is has come to foreground and is now interactive.\n\n     Note: 'OnPause' and 'OnResume' are called twice consecutively under iOS (before and after entering background\n     or foreground).\n\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("on_destroy", &HelloImGui::MobileCallbacks::OnDestroy, "")
        .def_readwrite("on_low_memory", &HelloImGui::MobileCallbacks::OnLowMemory, "")
        .def_readwrite("on_pause", &HelloImGui::MobileCallbacks::OnPause, "")
        .def_readwrite("on_resume", &HelloImGui::MobileCallbacks::OnResume, "")
        ;


    auto pyClassRunnerCallbacks =
        py::class_<HelloImGui::RunnerCallbacks>
            (m, "RunnerCallbacks", "*\n @@md#RunnerCallbacks\n\n     **RunnerCallbacks** is a struct that contains the callbacks that are called by the application\n\n     _Members_\n\n    * `ShowGui`: *VoidFunction, default=empty*.\n      Fill it with a function that will add your widgets.\n\n    * `ShowMenus`: *VoidFunction, default=empty*.\n        A function that will render your menus. Fill it with a function that will add ImGui menus by calling:\n        _ImGui::BeginMenu(...) / ImGui::MenuItem(...) / ImGui::EndMenu()_\n\n        _Notes:_\n        * you do not need to call _ImGui::BeginMenuBar_ and _ImGui::EndMenuBar_\n        * Some default menus can be provided: see _ImGuiWindowParams_ options\n          (_showMenuBar, showMenu_App_QuitAbout, showMenu_View_)\n\n    * `ShowStatus`: *VoidFunction, default=empty*.\n      A function that will add items to the status bar. Use small items (ImGui::Text for example),\n      since the height of the status is 30. Also, remember to call ImGui::SameLine() between items.\n\n    * `PostInit`: *VoidFunction, default=empty*.\n        You can here add a function that will be called once after OpenGL and ImGui are inited\n\n    * `BeforeExit`: *VoidFunction, default=empty*.\n        You can here add a function that will be called once before exiting (when OpenGL and ImGui are\n        still inited)\n\n    * `AnyBackendEventCallback`: *AnyBackendCallback, default=empty*.\n      Callbacks for events from a specific backend. _Only implemented for SDL, where the event\n      will be of type 'SDL_Event *'_\n      This callback should return True if the event was handled and shall not be processed further.\n\n    * `LoadAdditionalFonts`: *VoidFunction, default=_LoadDefaultFont_WithFontAwesome*.\n       A function that is called when fonts are ready to be loaded.\n       By default, _LoadDefaultFont_WithFontAwesome_ is called but you can copy-customize it.\n\n    * `SetupImGuiConfig`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.\n        If needed, change ImGui config via SetupImGuiConfig (enable docking, gamepad, etc)\n\n    * `SetupImGuiStyle`: *VoidFunction, default=_ImGuiDefaultSettings::SetupDefaultImGuiConfig*.\n        If needed, setup your own style by providing your own SetupImGuiStyle callback\n\n\n    * `mobileCallbacks`: *_MobileCallbacks_*. Callbacks that are called by the application\n        when running under \"Android, iOS and WinRT\".\n    Notes:\n      * 'mobileCallbacks' is present only if the target device is a mobile device (iOS, Android).\n         Use `#ifdef HELLOIMGUI_MOBILEDEVICE` to detect this.\n      * These events are currently handled only with SDL backend.\n\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("show_gui", &HelloImGui::RunnerCallbacks::ShowGui, "")
        .def_readwrite("show_menus", &HelloImGui::RunnerCallbacks::ShowMenus, "")
        .def_readwrite("show_status", &HelloImGui::RunnerCallbacks::ShowStatus, "")
        .def_readwrite("post_init", &HelloImGui::RunnerCallbacks::PostInit, "")
        .def_readwrite("before_exit", &HelloImGui::RunnerCallbacks::BeforeExit, "")
        .def_readwrite("any_backend_event_callback", &HelloImGui::RunnerCallbacks::AnyBackendEventCallback, "")
        .def_readwrite("load_additional_fonts", &HelloImGui::RunnerCallbacks::LoadAdditionalFonts, "")
        .def_readwrite("setup_imgui_config", &HelloImGui::RunnerCallbacks::SetupImGuiConfig, "")
        .def_readwrite("setup_imgui_style", &HelloImGui::RunnerCallbacks::SetupImGuiStyle, "")
        ;


    auto pyClassDockingSplit =
        py::class_<HelloImGui::DockingSplit>
            (m, "DockingSplit", "*\n@@md#DockingSplit\n\n    **DockingSplit** is a struct that defines the way the docking splits should be applied on the screen\n    in order to create new Dock Spaces. _DockingParams_ contains a _vector[DockingSplit]_,\n    in order to partition the screen at your will.\n\n    _Members:_\n\n    * `initialDock`: _DockSpaceName (aka string)_\n\n        id of the space that should be split.\n        At the start, there is only one Dock Space named \"MainDockSpace\".\n        You should start by partitioning this space, in order to create a new dock space.\n\n    * `newDock`: _DockSpaceName (aka string)_. id of the new dock space that will be created\n    * `direction`: *ImGuiDir_ (enum with ImGuiDir_Down, ImGuiDir_Down, ImGuiDir_Left, ImGuiDir_Right)*.\n    Direction where this dock space should be created\n    * `ratio`: _float, default=0.25_. Ratio of the initialDock size that should be used by the new dock space\n\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("initial_dock", &HelloImGui::DockingSplit::initialDock, "")
        .def_readwrite("new_dock", &HelloImGui::DockingSplit::newDock, "")
        .def_readwrite("direction", &HelloImGui::DockingSplit::direction, "")
        .def_readwrite("ratio", &HelloImGui::DockingSplit::ratio, "")
        ;


    auto pyClassDockableWindow =
        py::class_<HelloImGui::DockableWindow>
            (m, "DockableWindow", "*\n@@md#DockableWindow\n\n    **DockableWindow** is a struct that represents a window that can be docked.\n\n    _Members:_\n\n    * `label`: _string_. Title of the window.\n    * `dockSpaceName`: _DockSpaceName (aka string)_. Id of the dock space where this window\n       should initialy be placed\n    * `GuiFunction`: _VoidFuntion_. Any function that will render this window's Gui.\n    * `isVisible`: _bool, default=true_. Flag that indicates whether this window is visible or not.\n    * `canBeClosed`: _bool, default=true_. Flag that indicates whether the user can close this window.\n    * `callBeginEnd`: _bool, default=true_. Flag that indicates whether ImGui::Begin and ImGui::End\n       calls should be added automatically (with the given \"label\"). Set to False if you want to call\n       ImGui::Begin/End yourself\n    * `includeInViewMenu`: _bool, default=true_. Flag that indicates whether this window should be mentioned\n       in the view menu.\n    * `imGuiWindowFlags`: _ImGuiWindowFlags, default=0_. Window flags, see enum ImGuiWindowFlags_\n    * `windowSize`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window size (unused if docked)\n    * `windowSizeCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window size.\n    * `windowPos`: _ImVec2, default=(0., 0.) (i.e let the app decide)_. Window position (unused if docked)\n    * `windowPosCondition`: _ImGuiCond, default=ImGuiCond_FirstUseEver_. When to apply the window position.\n    * `focusWindowAtNextFrame`: _bool, default = false_. If set to True this window will be focused at the next frame.\n\n@@md\n*")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("label", &HelloImGui::DockableWindow::label, "")
        .def_readwrite("dock_space_name", &HelloImGui::DockableWindow::dockSpaceName, "")
        .def_readwrite("gui_function", &HelloImGui::DockableWindow::GuiFunction, "")
        .def_readwrite("is_visible", &HelloImGui::DockableWindow::isVisible, "")
        .def_readwrite("can_be_closed", &HelloImGui::DockableWindow::canBeClosed, "")
        .def_readwrite("call_begin_end", &HelloImGui::DockableWindow::callBeginEnd, "")
        .def_readwrite("include_in_view_menu", &HelloImGui::DockableWindow::includeInViewMenu, "")
        .def_readwrite("imgui_window_flags", &HelloImGui::DockableWindow::imGuiWindowFlags, "")
        .def_readwrite("window_size", &HelloImGui::DockableWindow::windowSize, "")
        .def_readwrite("window_size_condition", &HelloImGui::DockableWindow::windowSizeCondition, "")
        .def_readwrite("window_position", &HelloImGui::DockableWindow::windowPosition, "")
        .def_readwrite("window_position_condition", &HelloImGui::DockableWindow::windowPositionCondition, "")
        .def_readwrite("focus_window_at_next_frame", &HelloImGui::DockableWindow::focusWindowAtNextFrame, "")
        ;


    auto pyClassDockingParams =
        py::class_<HelloImGui::DockingParams>
            (m, "DockingParams", "*\n@@md#DockingParams\n\n    **DockingParams** contains all the settings concerning the docking,\n     together _with the Gui functions for the docked windows_.\n\n     _Members:_\n\n    * `dockingSplits`: _vector[DockingSplit]_.\n      Defines the way docking splits should be applied on the screen in order to create new Dock Spaces\n    * `dockableWindows`: _vector[DockableWindow]_.\n      List of the dockable windows, together with their Gui code\n    * `resetUserDockLayout`: _bool, default=true_.\n      Reset user layout at application startup\n\n     _Helpers:_\n\n     * `DockableWindow * dockableWindowOfName(const std::string & name)`: returns a pointer to a dockable window\n     * `None focusDockableWindow(const std::string& name)`: will focus a dockable window\n\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("docking_splits", &HelloImGui::DockingParams::dockingSplits, "")
        .def_readwrite("dockable_windows", &HelloImGui::DockingParams::dockableWindows, "")
        .def_readwrite("reset_user_dock_layout", &HelloImGui::DockingParams::resetUserDockLayout, "")
        .def_readwrite("was_dock_layout_applied", &HelloImGui::DockingParams::wasDockLayoutApplied, "wasDockLayoutApplied is an internal variable")
        .def("dockable_window_of_name",
            &HelloImGui::DockingParams::dockableWindowOfName, py::arg("name"))
        .def("focus_dockable_window",
            &HelloImGui::DockingParams::focusDockableWindow, py::arg("window_name"))
        ;


    auto pyClassBackendPointers =
        py::class_<HelloImGui::BackendPointers>
            (m, "BackendPointers", "*\n @@md#BackendPointers\n\n    **BackendPointers** is a struct that contains optional pointers to the backend implementations (for SDL and GLFW).\n\n    These pointers will be filled when the application starts, and you can use them to customize\n    your application behavior using the selected backend.\n\n     Members:\n    * `glfwWindow`: _void *, default=nullptr_. Pointer to the main GLFW window (of type `GLFWwindow*`).\n      Only filled if the backend is GLFW.\n    * `sdlWindow`: _void *, default=nullptr_. Pointer to the main SDL window (of type `SDL_Window*`).\n      Only filled if the backend is SDL (or emscripten + sdl)\n    * `sdlGlContext`: _void *, default=nullptr_. Pointer to SDL's GlContext (of type `SDL_GLContext`).\n      Only filled if the backend is SDL (or emscripten + sdl)\n\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("glfw_window", &HelloImGui::BackendPointers::glfwWindow, "")
        .def_readwrite("sdl_window", &HelloImGui::BackendPointers::sdlWindow, "")
        .def_readwrite("sdl_gl_context", &HelloImGui::BackendPointers::sdlGlContext, "")
        ;


    auto pyClassRunnerParams =
        py::class_<HelloImGui::RunnerParams>
            (m, "RunnerParams", "*\n @@md#RunnerParams\n\n    **RunnerParams** is a struct that contains all the settings and callbacks needed to run an application.\n\n     Members:\n    * `callbacks`: _see [runner_callbacks.h](runner_callbacks.h)_.\n        callbacks.ShowGui() will render the gui, ShowMenus() will show the menus, etc.\n    * `appWindowParams`: _see [app_window_params.h](app_window_params.h)_.\n        application Window Params (position, size, title)\n    * `imGuiWindowParams`: _see [imgui_window_params.h](imgui_window_params.h)_.\n        imgui window params (use docking, showMenuBar, ProvideFullScreenWindow, etc)\n    * `dockingParams`: _see [docking_params.h](docking_params.h)_.\n        dockable windows content and layout\n    * `backendPointers`: _see [backend_pointers.h](backend_pointers.h)_.\n       A struct that contains optional pointers to the backend implementations. These pointers will be filled\n       when the application starts\n    * `appShallExit`: _bool, default=false_.\n       will be set to True by the app when exiting.\n       _Note: 'appShallExit' has no effect on Mobile Devices (iOS, Android) and under emscripten, since these apps\n       shall not exit._\n    * `fps`: _int, default = 0` when applicable, set the application refresh rate\n       (only used on emscripten for the moment: 0 stands for \"let the app or the browser decide\")\n\n@@md\n")
        .def(py::init<>()) // implicit default constructor
        .def_readwrite("callbacks", &HelloImGui::RunnerParams::callbacks, "")
        .def_readwrite("app_window_params", &HelloImGui::RunnerParams::appWindowParams, "")
        .def_readwrite("imgui_window_params", &HelloImGui::RunnerParams::imGuiWindowParams, "")
        .def_readwrite("docking_params", &HelloImGui::RunnerParams::dockingParams, "")
        .def_readwrite("backend_pointers", &HelloImGui::RunnerParams::backendPointers, "")
        .def_readwrite("app_shall_exit", &HelloImGui::RunnerParams::appShallExit, "")
        .def_readwrite("fps", &HelloImGui::RunnerParams::fps, "")
        ;


    py::enum_<HelloImGui::LogLevel>(m, "LogLevel", py::arithmetic(), "")
        .value("debug", HelloImGui::LogLevel::Debug, "")
        .value("info", HelloImGui::LogLevel::Info, "")
        .value("warning", HelloImGui::LogLevel::Warning, "")
        .value("error", HelloImGui::LogLevel::Error, "");


    m.def("log",
        [](HelloImGui::LogLevel level, const char * const format)
        {
            auto Log_adapt_variadic_format = [](HelloImGui::LogLevel level, const char * const format)
            {
                HelloImGui::Log(level, "%s", format);
            };

            Log_adapt_variadic_format(level, format);
        },     py::arg("level"), py::arg("format"));

    m.def("log_clear",
        HelloImGui::LogClear);

    m.def("log_gui",
        HelloImGui::LogGui);


    m.def("run",
        py::overload_cast<HelloImGui::RunnerParams &>(HelloImGui::Run), py::arg("runner_params"));

    m.def("run",
        py::overload_cast<VoidFunction, ImVec2, std::string>(HelloImGui::Run), py::arg("gui_fonction"), py::arg("window_size") = ImVec2(800.f, 600.f), py::arg("window_title") = "");

    { // <namespace ImGuiDefaultSettings>
        py::module_ pyNsImGuiDefaultSettings = m.def_submodule("ImGuiDefaultSettings", "namespace ImGuiDefaultSettings");
        pyNsImGuiDefaultSettings.def("load_default_font_with_font_awesome_icons",
            HelloImGui::ImGuiDefaultSettings::LoadDefaultFont_WithFontAwesomeIcons);

        pyNsImGuiDefaultSettings.def("setup_default_imgui_config",
            HelloImGui::ImGuiDefaultSettings::SetupDefaultImGuiConfig);

        pyNsImGuiDefaultSettings.def("setup_default_imgui_style",
            HelloImGui::ImGuiDefaultSettings::SetupDefaultImGuiStyle);
    } // </namespace ImGuiDefaultSettings>
    ////////////////////    </generated_from:hello_imgui_amalgamation.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
