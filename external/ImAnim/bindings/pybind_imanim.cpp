// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2025 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>

#include "ImAnim/im_anim.h"

namespace nb = nanobind;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_imanim(nb::module_& m)
{
    // ImAnim uses C-style API at global scope, no namespace

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:im_anim.h>    ////////////////////
    auto pyEnumease_type =
        nb::enum_<iam_ease_type>(m, "ease_type", nb::is_arithmetic(), " ----------------------------------------------------\n Public enums & descriptors (C-style)\n ----------------------------------------------------")
            .value("ease_linear", iam_ease_linear, "")
            .value("ease_in_quad", iam_ease_in_quad, "")
            .value("ease_out_quad", iam_ease_out_quad, "")
            .value("ease_in_out_quad", iam_ease_in_out_quad, "")
            .value("ease_in_cubic", iam_ease_in_cubic, "")
            .value("ease_out_cubic", iam_ease_out_cubic, "")
            .value("ease_in_out_cubic", iam_ease_in_out_cubic, "")
            .value("ease_in_quart", iam_ease_in_quart, "")
            .value("ease_out_quart", iam_ease_out_quart, "")
            .value("ease_in_out_quart", iam_ease_in_out_quart, "")
            .value("ease_in_quint", iam_ease_in_quint, "")
            .value("ease_out_quint", iam_ease_out_quint, "")
            .value("ease_in_out_quint", iam_ease_in_out_quint, "")
            .value("ease_in_sine", iam_ease_in_sine, "")
            .value("ease_out_sine", iam_ease_out_sine, "")
            .value("ease_in_out_sine", iam_ease_in_out_sine, "")
            .value("ease_in_expo", iam_ease_in_expo, "")
            .value("ease_out_expo", iam_ease_out_expo, "")
            .value("ease_in_out_expo", iam_ease_in_out_expo, "")
            .value("ease_in_circ", iam_ease_in_circ, "")
            .value("ease_out_circ", iam_ease_out_circ, "")
            .value("ease_in_out_circ", iam_ease_in_out_circ, "")
            .value("ease_in_back", iam_ease_in_back, "")
            .value("ease_out_back", iam_ease_out_back, "")
            .value("ease_in_out_back", iam_ease_in_out_back, "p0 = overshoot")
            .value("ease_in_elastic", iam_ease_in_elastic, "")
            .value("ease_out_elastic", iam_ease_out_elastic, "")
            .value("ease_in_out_elastic", iam_ease_in_out_elastic, "p0 = amplitude, p1 = period")
            .value("ease_in_bounce", iam_ease_in_bounce, "")
            .value("ease_out_bounce", iam_ease_out_bounce, "")
            .value("ease_in_out_bounce", iam_ease_in_out_bounce, "")
            .value("ease_steps", iam_ease_steps, "p0 = steps (>=1), p1 = 0:end 1:start 2:both")
            .value("ease_cubic_bezier", iam_ease_cubic_bezier, "p0=x1 p1=y1 p2=x2 p3=y2")
            .value("ease_spring", iam_ease_spring, "p0=mass p1=stiffness p2=damping p3=v0")
            .value("ease_custom", iam_ease_custom, "User-defined easing function (use iam_ease_custom_fn)");


    auto pyEnumpolicy =
        nb::enum_<iam_policy>(m, "policy", nb::is_arithmetic(), "")
            .value("crossfade", iam_policy_crossfade, "smooth into new target")
            .value("cut", iam_policy_cut, "snap to target")
            .value("queue", iam_policy_queue, "queue one pending target");


    auto pyEnumcolor_space =
        nb::enum_<iam_color_space>(m, "color_space", nb::is_arithmetic(), "")
            .value("col_srgb", iam_col_srgb, "blend in sRGB (not physically linear)")
            .value("col_srgb_linear", iam_col_srgb_linear, "sRGB<->linear, blend in linear, back to sRGB")
            .value("col_hsv", iam_col_hsv, "blend H/S/V (hue shortest arc), keep A linear")
            .value("col_oklab", iam_col_oklab, "sRGB<->OKLAB, blend in OKLAB, back to sRGB")
            .value("col_oklch", iam_col_oklch, "sRGB<->OKLCH (cylindrical OKLAB), blend in OKLCH, back to sRGB");


    auto pyEnumanchor_space =
        nb::enum_<iam_anchor_space>(m, "anchor_space", nb::is_arithmetic(), "")
            .value("anchor_window_content", iam_anchor_window_content, "ImGui::GetContentRegionAvail()")
            .value("anchor_window", iam_anchor_window, "ImGui::GetWindowSize()")
            .value("anchor_viewport", iam_anchor_viewport, "ImGui::GetWindowViewport()->Size")
            .value("anchor_last_item", iam_anchor_last_item, "ImGui::GetItemRectSize()");


    auto pyClassiam_ease_desc =
        nb::class_<iam_ease_desc>
            (m, "ease_desc", "Descriptor for any easing (preset or parametric)")
        .def("__init__", [](iam_ease_desc * self, int type = int(), float p0 = float(), float p1 = float(), float p2 = float(), float p3 = float())
        {
            new (self) iam_ease_desc();  // placement new
            auto r_ctor_ = self;
            r_ctor_->type = type;
            r_ctor_->p0 = p0;
            r_ctor_->p1 = p1;
            r_ctor_->p2 = p2;
            r_ctor_->p3 = p3;
        },
        nb::arg("type") = int(), nb::arg("p0") = float(), nb::arg("p1") = float(), nb::arg("p2") = float(), nb::arg("p3") = float()
        )
        .def_rw("type", &iam_ease_desc::type, "iam_ease_type")
        .def_rw("p0", &iam_ease_desc::p0, "")
        .def_rw("p1", &iam_ease_desc::p1, "")
        .def_rw("p2", &iam_ease_desc::p2, "")
        .def_rw("p3", &iam_ease_desc::p3, "")
        ;


    m.def("update_begin_frame",
        iam_update_begin_frame, "Call once per frame before any tweens.");

    m.def("gc",
        iam_gc,
        nb::arg("max_age_frames") = 600,
        "Remove stale tween entries older than max_age_frames.");

    m.def("pool_clear",
        iam_pool_clear, "Manually clean up pools.");

    m.def("reserve",
        iam_reserve,
        nb::arg("cap_float"), nb::arg("cap_vec2"), nb::arg("cap_vec4"), nb::arg("cap_int"), nb::arg("cap_color"),
        "Pre-allocate pool capacity.");

    m.def("set_ease_lut_samples",
        iam_set_ease_lut_samples,
        nb::arg("count"),
        "Set LUT resolution for parametric easings (default: 256).");

    m.def("set_global_time_scale",
        iam_set_global_time_scale,
        nb::arg("scale"),
        "Set global time multiplier (1.0 = normal, 0.5 = half speed, 2.0 = double).");

    m.def("get_global_time_scale",
        iam_get_global_time_scale, "Get current global time scale.");

    m.def("set_lazy_init",
        iam_set_lazy_init,
        nb::arg("enable"),
        "Enable/disable lazy initialization (default: True).");

    m.def("is_lazy_init_enabled",
        iam_is_lazy_init_enabled, "Check if lazy init is enabled.");

    m.def("register_custom_ease",
        iam_register_custom_ease,
        nb::arg("slot"), nb::arg("fn"),
        "Register custom easing in slot 0-15. Use with iam_ease_custom_fn(slot).");

    m.def("get_custom_ease",
        iam_get_custom_ease,
        nb::arg("slot"),
        "Get registered custom easing function.");

    m.def("show_unified_inspector",
        iam_show_unified_inspector,
        nb::arg("p_open") = nb::none(),
        "Show unified inspector (merges debug window + animation inspector).");

    m.def("show_debug_timeline",
        iam_show_debug_timeline,
        nb::arg("instance_id"),
        "Show debug timeline for a clip instance.");

    m.def("profiler_enable",
        iam_profiler_enable,
        nb::arg("enable"),
        "Enable/disable the performance profiler.");

    m.def("profiler_is_enabled",
        iam_profiler_is_enabled, "Check if profiler is enabled.");

    m.def("profiler_begin_frame",
        iam_profiler_begin_frame, "Call at frame start when profiler is enabled.");

    m.def("profiler_end_frame",
        iam_profiler_end_frame, "Call at frame end when profiler is enabled.");

    m.def("profiler_begin",
        iam_profiler_begin,
        nb::arg("name"),
        "Begin a named profiler section.");

    m.def("profiler_end",
        iam_profiler_end, "End the current profiler section.");


    auto pyClassiam_drag_opts =
        nb::class_<iam_drag_opts>
            (m, "drag_opts", "Drag Feedback - animated feedback for drag operations")
        .def_rw("snap_grid", &iam_drag_opts::snap_grid, "Grid size for snapping (0,0 = no grid)")
        .def_rw("snap_points", &iam_drag_opts::snap_points, "Array of custom snap points")
        .def_rw("snap_points_count", &iam_drag_opts::snap_points_count, "Number of snap points")
        .def_rw("snap_duration", &iam_drag_opts::snap_duration, "Duration of snap animation")
        .def_rw("overshoot", &iam_drag_opts::overshoot, "Overshoot amount (0 = none, 1 = normal)")
        .def_rw("ease_type", &iam_drag_opts::ease_type, "Easing type for snap animation")
        .def(nb::init<>())
        ;


    auto pyClassiam_drag_feedback =
        nb::class_<iam_drag_feedback>
            (m, "drag_feedback", "")
        .def("__init__", [](iam_drag_feedback * self, const std::optional<const ImVec2> & position = std::nullopt, const std::optional<const ImVec2> & offset = std::nullopt, const std::optional<const ImVec2> & velocity = std::nullopt, bool is_dragging = bool(), bool is_snapping = bool(), float snap_progress = float())
        {
            new (self) iam_drag_feedback();  // placement new
            auto r_ctor_ = self;
            if (position.has_value())
                r_ctor_->position = position.value();
            else
                r_ctor_->position = ImVec2();
            if (offset.has_value())
                r_ctor_->offset = offset.value();
            else
                r_ctor_->offset = ImVec2();
            if (velocity.has_value())
                r_ctor_->velocity = velocity.value();
            else
                r_ctor_->velocity = ImVec2();
            r_ctor_->is_dragging = is_dragging;
            r_ctor_->is_snapping = is_snapping;
            r_ctor_->snap_progress = snap_progress;
        },
        nb::arg("position").none() = nb::none(), nb::arg("offset").none() = nb::none(), nb::arg("velocity").none() = nb::none(), nb::arg("is_dragging") = bool(), nb::arg("is_snapping") = bool(), nb::arg("snap_progress") = float()
        )
        .def_rw("position", &iam_drag_feedback::position, "Current animated position")
        .def_rw("offset", &iam_drag_feedback::offset, "Offset from drag start")
        .def_rw("velocity", &iam_drag_feedback::velocity, "Current velocity estimate")
        .def_rw("is_dragging", &iam_drag_feedback::is_dragging, "Currently being dragged")
        .def_rw("is_snapping", &iam_drag_feedback::is_snapping, "Currently snapping to target")
        .def_rw("snap_progress", &iam_drag_feedback::snap_progress, "Snap animation progress (0-1)")
        ;


    m.def("drag_begin",
        iam_drag_begin,
        nb::arg("id"), nb::arg("pos"),
        "Start tracking drag at position.");

    m.def("drag_update",
        iam_drag_update,
        nb::arg("id"), nb::arg("pos"), nb::arg("dt"),
        "Update drag position during drag.");

    m.def("drag_release",
        iam_drag_release,
        nb::arg("id"), nb::arg("pos"), nb::arg("opts"), nb::arg("dt"),
        "Release drag with animated feedback.");

    m.def("drag_cancel",
        iam_drag_cancel,
        nb::arg("id"),
        "Cancel drag tracking.");


    auto pyEnumwave_type =
        nb::enum_<iam_wave_type>(m, "wave_type", nb::is_arithmetic(), "Oscillators - continuous periodic animations")
            .value("wave_sine", iam_wave_sine, "Smooth sine wave")
            .value("wave_triangle", iam_wave_triangle, "Triangle wave (linear up/down)")
            .value("wave_sawtooth", iam_wave_sawtooth, "Sawtooth wave (linear up, instant reset)")
            .value("wave_square", iam_wave_square, "Square wave (on/off pulse)");


    m.def("oscillate",
        iam_oscillate,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "Returns oscillating value [-amplitude, +amplitude].");

    m.def("oscillate_int",
        iam_oscillate_int,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "Returns oscillating integer value [-amplitude, +amplitude].");

    m.def("oscillate_vec2",
        iam_oscillate_vec2,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "2D oscillation.");

    m.def("oscillate_vec4",
        iam_oscillate_vec4,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "4D oscillation.");

    m.def("oscillate_color",
        iam_oscillate_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("color_space"), nb::arg("dt"),
        "Color oscillation in specified color space.");

    m.def("shake",
        iam_shake,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "Decaying random shake. Returns offset that decays to 0.");

    m.def("shake_int",
        iam_shake_int,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "Decaying random shake for integers.");

    m.def("shake_vec2",
        iam_shake_vec2,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "2D decaying shake.");

    m.def("shake_vec4",
        iam_shake_vec4,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "4D decaying shake.");

    m.def("shake_color",
        iam_shake_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("color_space"), nb::arg("dt"),
        "Color shake in specified color space.");

    m.def("wiggle",
        iam_wiggle,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "Continuous smooth random movement.");

    m.def("wiggle_int",
        iam_wiggle_int,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "Continuous smooth random movement for integers.");

    m.def("wiggle_vec2",
        iam_wiggle_vec2,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "2D continuous wiggle.");

    m.def("wiggle_vec4",
        iam_wiggle_vec4,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "4D continuous wiggle.");

    m.def("wiggle_color",
        iam_wiggle_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("color_space"), nb::arg("dt"),
        "Color wiggle in specified color space.");

    m.def("trigger_shake",
        iam_trigger_shake,
        nb::arg("id"),
        "Trigger/restart a shake animation.");

    m.def("eval_preset",
        iam_eval_preset,
        nb::arg("type"), nb::arg("t"),
        "Evaluate a preset easing function at time t (0-1).");

    m.def("tween_float",
        iam_tween_float,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value") = 0.0f,
        "Animate a float value.");

    m.def("tween_vec2",
        [](ImGuiID id, ImGuiID channel_id, ImVec2 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec2> & init_value = std::nullopt) -> ImVec2
        {
            auto iam_tween_vec2_adapt_mutable_param_with_default_value = [](ImGuiID id, ImGuiID channel_id, ImVec2 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec2> & init_value = std::nullopt) -> ImVec2
            {

                const ImVec2& init_value_or_default = [&]() -> const ImVec2 {
                    if (init_value.has_value())
                        return init_value.value();
                    else
                        return ImVec2(0, 0);
                }();

                auto lambda_result = iam_tween_vec2(id, channel_id, target, dur, ez, policy, dt, init_value_or_default);
                return lambda_result;
            };

            return iam_tween_vec2_adapt_mutable_param_with_default_value(id, channel_id, target, dur, ez, policy, dt, init_value);
        },
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value").none() = nb::none(),
        "Python bindings defaults:\n    If init_value is None, then its default value will be: ImVec2(0, 0)\n\n Animate a 2D vector.");

    m.def("tween_vec4",
        [](ImGuiID id, ImGuiID channel_id, ImVec4 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
        {
            auto iam_tween_vec4_adapt_mutable_param_with_default_value = [](ImGuiID id, ImGuiID channel_id, ImVec4 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
            {

                const ImVec4& init_value_or_default = [&]() -> const ImVec4 {
                    if (init_value.has_value())
                        return init_value.value();
                    else
                        return ImVec4(0, 0, 0, 0);
                }();

                auto lambda_result = iam_tween_vec4(id, channel_id, target, dur, ez, policy, dt, init_value_or_default);
                return lambda_result;
            };

            return iam_tween_vec4_adapt_mutable_param_with_default_value(id, channel_id, target, dur, ez, policy, dt, init_value);
        },
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value").none() = nb::none(),
        "Python bindings defaults:\n    If init_value is None, then its default value will be: ImVec4(0, 0, 0, 0)\n\n Animate a 4D vector.");

    m.def("tween_int",
        iam_tween_int,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value") = 0,
        "Animate an integer value.");

    m.def("tween_color",
        [](ImGuiID id, ImGuiID channel_id, ImVec4 target_srgb, float dur, const iam_ease_desc & ez, int policy, int color_space, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
        {
            auto iam_tween_color_adapt_mutable_param_with_default_value = [](ImGuiID id, ImGuiID channel_id, ImVec4 target_srgb, float dur, const iam_ease_desc & ez, int policy, int color_space, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
            {

                const ImVec4& init_value_or_default = [&]() -> const ImVec4 {
                    if (init_value.has_value())
                        return init_value.value();
                    else
                        return ImVec4(1, 1, 1, 1);
                }();

                auto lambda_result = iam_tween_color(id, channel_id, target_srgb, dur, ez, policy, color_space, dt, init_value_or_default);
                return lambda_result;
            };

            return iam_tween_color_adapt_mutable_param_with_default_value(id, channel_id, target_srgb, dur, ez, policy, color_space, dt, init_value);
        },
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target_srgb"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("color_space"), nb::arg("dt"), nb::arg("init_value").none() = nb::none(),
        "Python bindings defaults:\n    If init_value is None, then its default value will be: ImVec4(1, 1, 1, 1)\n\n Animate a color in specified color space.");

    m.def("anchor_size",
        iam_anchor_size,
        nb::arg("space"),
        "Get dimensions of anchor space (window, viewport, etc.).");

    m.def("tween_float_rel",
        iam_tween_float_rel,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("anchor_space"), nb::arg("axis"), nb::arg("dt"),
        "Float relative to anchor (axis: 0=x, 1=y).");

    m.def("tween_vec2_rel",
        iam_tween_vec2_rel,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("anchor_space"), nb::arg("dt"),
        "Vec2 relative to anchor.");

    m.def("tween_vec4_rel",
        iam_tween_vec4_rel,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("anchor_space"), nb::arg("dt"),
        "Vec4 with x,y relative to anchor.");

    m.def("tween_color_rel",
        iam_tween_color_rel,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("color_space"), nb::arg("anchor_space"), nb::arg("dt"),
        "Color with component offsets.");

    m.def("tween_float_resolved",
        iam_tween_float_resolved,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("fn"), nb::arg("user"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"),
        "Float with dynamic target.");

    m.def("tween_vec2_resolved",
        iam_tween_vec2_resolved,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("fn"), nb::arg("user"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"),
        "Vec2 with dynamic target.");

    m.def("tween_vec4_resolved",
        iam_tween_vec4_resolved,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("fn"), nb::arg("user"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"),
        "Vec4 with dynamic target.");

    m.def("tween_color_resolved",
        iam_tween_color_resolved,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("fn"), nb::arg("user"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("color_space"), nb::arg("dt"),
        "Color with dynamic target.");

    m.def("tween_int_resolved",
        iam_tween_int_resolved,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("fn"), nb::arg("user"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"),
        "Int with dynamic target.");

    m.def("rebase_float",
        iam_rebase_float,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect float animation to new target.");

    m.def("rebase_vec2",
        iam_rebase_vec2,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect vec2 animation to new target.");

    m.def("rebase_vec4",
        iam_rebase_vec4,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect vec4 animation to new target.");

    m.def("rebase_color",
        iam_rebase_color,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect color animation to new target.");

    m.def("rebase_int",
        iam_rebase_int,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect int animation to new target.");

    m.def("get_blended_color",
        iam_get_blended_color,
        nb::arg("a_srgb"), nb::arg("b_srgb"), nb::arg("t"), nb::arg("color_space"),
        "Blend two sRGB colors in specified color space.");

    m.def("ease_preset",
        iam_ease_preset,
        nb::arg("type"),
        "Create descriptor from preset enum.");

    m.def("ease_bezier",
        iam_ease_bezier,
        nb::arg("x1"), nb::arg("y1"), nb::arg("x2"), nb::arg("y2"),
        "Create cubic bezier easing.");

    m.def("ease_steps_desc",
        iam_ease_steps_desc,
        nb::arg("steps"), nb::arg("mode"),
        "Create step function easing.");

    m.def("ease_back",
        iam_ease_back,
        nb::arg("overshoot"),
        "Create back easing with overshoot.");

    m.def("ease_elastic",
        iam_ease_elastic,
        nb::arg("amplitude"), nb::arg("period"),
        "Create elastic easing.");

    m.def("ease_spring_desc",
        iam_ease_spring_desc,
        nb::arg("mass"), nb::arg("stiffness"), nb::arg("damping"), nb::arg("v0"),
        "Create physics spring.");

    m.def("ease_custom_fn",
        iam_ease_custom_fn,
        nb::arg("slot"),
        "Use registered custom easing (slot 0-15).");

    m.def("scroll_to_y",
        [](float target_y, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_y_adapt_mutable_param_with_default_value = [](float target_y, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_y(target_y, duration, ez_or_default);
            };

            iam_scroll_to_y_adapt_mutable_param_with_default_value(target_y, duration, ez);
        },
        nb::arg("target_y"), nb::arg("duration"), nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll current window to Y position.");

    m.def("scroll_to_x",
        [](float target_x, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_x_adapt_mutable_param_with_default_value = [](float target_x, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_x(target_x, duration, ez_or_default);
            };

            iam_scroll_to_x_adapt_mutable_param_with_default_value(target_x, duration, ez);
        },
        nb::arg("target_x"), nb::arg("duration"), nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll current window to X position.");

    m.def("scroll_to_top",
        [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_top_adapt_mutable_param_with_default_value = [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_top(duration, ez_or_default);
            };

            iam_scroll_to_top_adapt_mutable_param_with_default_value(duration, ez);
        },
        nb::arg("duration") = 0.3f, nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll to top of window.");

    m.def("scroll_to_bottom",
        [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_bottom_adapt_mutable_param_with_default_value = [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_bottom(duration, ez_or_default);
            };

            iam_scroll_to_bottom_adapt_mutable_param_with_default_value(duration, ez);
        },
        nb::arg("duration") = 0.3f, nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll to bottom of window.");


    auto pyClassiam_ease_per_axis =
        nb::class_<iam_ease_per_axis>
            (m, "ease_per_axis", "Per-axis easing descriptor (for vec2/vec4/color)")
        .def_rw("x", &iam_ease_per_axis::x, "Easing for X component")
        .def_rw("y", &iam_ease_per_axis::y, "Easing for Y component")
        .def_rw("z", &iam_ease_per_axis::z, "Easing for Z component (vec4/color only)")
        .def_rw("w", &iam_ease_per_axis::w, "Easing for W/alpha component (vec4/color only)")
        .def(nb::init<>())
        .def(nb::init<iam_ease_desc>(),
            nb::arg("all"))
        .def(nb::init<iam_ease_desc, iam_ease_desc>(),
            nb::arg("ex"), nb::arg("ey"))
        .def(nb::init<iam_ease_desc, iam_ease_desc, iam_ease_desc, iam_ease_desc>(),
            nb::arg("ex"), nb::arg("ey"), nb::arg("ez"), nb::arg("ew"))
        ;


    m.def("tween_vec2_per_axis",
        iam_tween_vec2_per_axis, nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"));

    m.def("tween_vec4_per_axis",
        iam_tween_vec4_per_axis, nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"));

    m.def("tween_color_per_axis",
        iam_tween_color_per_axis, nb::arg("id"), nb::arg("channel_id"), nb::arg("target_srgb"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("color_space"), nb::arg("dt"));


    auto pyEnumpath_segment_type =
        nb::enum_<iam_path_segment_type>(m, "path_segment_type", nb::is_arithmetic(), "Path segment types")
            .value("seg_line", iam_seg_line, "Linear segment to endpoint")
            .value("seg_quadratic_bezier", iam_seg_quadratic_bezier, "Quadratic bezier (1 control point)")
            .value("seg_cubic_bezier", iam_seg_cubic_bezier, "Cubic bezier (2 control points)")
            .value("seg_catmull_rom", iam_seg_catmull_rom, "Catmull-rom spline segment");


    m.def("bezier_quadratic",
        iam_bezier_quadratic,
        nb::arg("p0"), nb::arg("p1"), nb::arg("p2"), nb::arg("t"),
        "Evaluate quadratic bezier at t [0,1].");

    m.def("bezier_cubic",
        iam_bezier_cubic,
        nb::arg("p0"), nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("t"),
        "Evaluate cubic bezier at t [0,1].");

    m.def("catmull_rom",
        iam_catmull_rom,
        nb::arg("p0"), nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("t"), nb::arg("tension") = 0.5f,
        "Evaluate Catmull-Rom spline at t [0,1]. Points go through p1 and p2.");

    m.def("bezier_quadratic_deriv",
        iam_bezier_quadratic_deriv,
        nb::arg("p0"), nb::arg("p1"), nb::arg("p2"), nb::arg("t"),
        "Derivative of quadratic bezier.");

    m.def("bezier_cubic_deriv",
        iam_bezier_cubic_deriv,
        nb::arg("p0"), nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("t"),
        "Derivative of cubic bezier.");

    m.def("catmull_rom_deriv",
        iam_catmull_rom_deriv,
        nb::arg("p0"), nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("t"), nb::arg("tension") = 0.5f,
        "Derivative of Catmull-Rom.");


    auto pyClassiam_path =
        nb::class_<iam_path>
            (m, "path", "iam_path - fluent API for building multi-segment motion paths")
        .def_static("begin",
            &iam_path::begin,
            nb::arg("path_id"), nb::arg("start"),
            "Start building a path at position.")
        .def("line_to",
            &iam_path::line_to,
            nb::arg("end"),
            "Add linear segment to endpoint.")
        .def("quadratic_to",
            &iam_path::quadratic_to,
            nb::arg("ctrl"), nb::arg("end"),
            "Add quadratic bezier segment.")
        .def("cubic_to",
            &iam_path::cubic_to,
            nb::arg("ctrl1"), nb::arg("ctrl2"), nb::arg("end"),
            "Add cubic bezier segment.")
        .def("catmull_to",
            &iam_path::catmull_to,
            nb::arg("end"), nb::arg("tension") = 0.5f,
            "Add Catmull-Rom segment to endpoint.")
        .def("close",
            &iam_path::close, "Close path back to start point.")
        .def("end",
            &iam_path::end, "Finalize and register path.")
        .def("id",
            &iam_path::id)
        ;


    m.def("path_exists",
        iam_path_exists,
        nb::arg("path_id"),
        "Check if path exists.");

    m.def("path_length",
        iam_path_length,
        nb::arg("path_id"),
        "Get approximate path length.");

    m.def("path_evaluate",
        iam_path_evaluate,
        nb::arg("path_id"), nb::arg("t"),
        "Sample path at t [0,1].");

    m.def("path_tangent",
        iam_path_tangent,
        nb::arg("path_id"), nb::arg("t"),
        "Get tangent (normalized direction) at t.");

    m.def("path_angle",
        iam_path_angle,
        nb::arg("path_id"), nb::arg("t"),
        "Get rotation angle (radians) at t.");

    m.def("tween_path",
        iam_tween_path,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("path_id"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"),
        "Animate position along path.");

    m.def("tween_path_angle",
        iam_tween_path_angle,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("path_id"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"),
        "Animate rotation angle along path.");

    m.def("path_build_arc_lut",
        iam_path_build_arc_lut,
        nb::arg("path_id"), nb::arg("subdivisions") = 64,
        "Build LUT with specified resolution.");

    m.def("path_has_arc_lut",
        iam_path_has_arc_lut,
        nb::arg("path_id"),
        "Check if path has precomputed LUT.");

    m.def("path_distance_to_t",
        iam_path_distance_to_t,
        nb::arg("path_id"), nb::arg("distance"),
        "Convert arc-length distance to t parameter.");

    m.def("path_evaluate_at_distance",
        iam_path_evaluate_at_distance,
        nb::arg("path_id"), nb::arg("distance"),
        "Get position at arc-length distance.");

    m.def("path_angle_at_distance",
        iam_path_angle_at_distance,
        nb::arg("path_id"), nb::arg("distance"),
        "Get rotation angle at arc-length distance.");

    m.def("path_tangent_at_distance",
        iam_path_tangent_at_distance,
        nb::arg("path_id"), nb::arg("distance"),
        "Get tangent at arc-length distance.");


    auto pyClassiam_morph_opts =
        nb::class_<iam_morph_opts>
            (m, "morph_opts", "Morph options for path interpolation")
        .def_rw("samples", &iam_morph_opts::samples, "Number of sample points for resampling (default: 64)")
        .def_rw("match_endpoints", &iam_morph_opts::match_endpoints, "Force endpoints to match exactly (default: True)")
        .def_rw("use_arc_length", &iam_morph_opts::use_arc_length, "Use arc-length parameterization for smoother morphing (default: True)")
        .def(nb::init<>())
        ;


    m.def("path_morph",
        [](ImGuiID path_a, ImGuiID path_b, float t, float blend, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> ImVec2
        {
            auto iam_path_morph_adapt_mutable_param_with_default_value = [](ImGuiID path_a, ImGuiID path_b, float t, float blend, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> ImVec2
            {

                const iam_morph_opts& opts_or_default = [&]() -> const iam_morph_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_morph_opts();
                }();

                auto lambda_result = iam_path_morph(path_a, path_b, t, blend, opts_or_default);
                return lambda_result;
            };

            return iam_path_morph_adapt_mutable_param_with_default_value(path_a, path_b, t, blend, opts);
        },
        nb::arg("path_a"), nb::arg("path_b"), nb::arg("t"), nb::arg("blend"), nb::arg("opts").none() = nb::none(),
        " Evaluate morphed path at parameter t [0,1] with blend factor [0,1]\n path_a at blend=0, path_b at blend=1\n Paths can have different numbers of segments - they are resampled to match\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: morph_opts()");

    m.def("path_morph_tangent",
        [](ImGuiID path_a, ImGuiID path_b, float t, float blend, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> ImVec2
        {
            auto iam_path_morph_tangent_adapt_mutable_param_with_default_value = [](ImGuiID path_a, ImGuiID path_b, float t, float blend, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> ImVec2
            {

                const iam_morph_opts& opts_or_default = [&]() -> const iam_morph_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_morph_opts();
                }();

                auto lambda_result = iam_path_morph_tangent(path_a, path_b, t, blend, opts_or_default);
                return lambda_result;
            };

            return iam_path_morph_tangent_adapt_mutable_param_with_default_value(path_a, path_b, t, blend, opts);
        },
        nb::arg("path_a"), nb::arg("path_b"), nb::arg("t"), nb::arg("blend"), nb::arg("opts").none() = nb::none(),
        " Get tangent of morphed path\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: morph_opts()");

    m.def("path_morph_angle",
        [](ImGuiID path_a, ImGuiID path_b, float t, float blend, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> float
        {
            auto iam_path_morph_angle_adapt_mutable_param_with_default_value = [](ImGuiID path_a, ImGuiID path_b, float t, float blend, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> float
            {

                const iam_morph_opts& opts_or_default = [&]() -> const iam_morph_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_morph_opts();
                }();

                auto lambda_result = iam_path_morph_angle(path_a, path_b, t, blend, opts_or_default);
                return lambda_result;
            };

            return iam_path_morph_angle_adapt_mutable_param_with_default_value(path_a, path_b, t, blend, opts);
        },
        nb::arg("path_a"), nb::arg("path_b"), nb::arg("t"), nb::arg("blend"), nb::arg("opts").none() = nb::none(),
        " Get angle (radians) of morphed path\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: morph_opts()");

    m.def("tween_path_morph",
        [](ImGuiID id, ImGuiID channel_id, ImGuiID path_a, ImGuiID path_b, float target_blend, float dur, const iam_ease_desc & path_ease, const iam_ease_desc & morph_ease, int policy, float dt, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> ImVec2
        {
            auto iam_tween_path_morph_adapt_mutable_param_with_default_value = [](ImGuiID id, ImGuiID channel_id, ImGuiID path_a, ImGuiID path_b, float target_blend, float dur, const iam_ease_desc & path_ease, const iam_ease_desc & morph_ease, int policy, float dt, const std::optional<const iam_morph_opts> & opts = std::nullopt) -> ImVec2
            {

                const iam_morph_opts& opts_or_default = [&]() -> const iam_morph_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_morph_opts();
                }();

                auto lambda_result = iam_tween_path_morph(id, channel_id, path_a, path_b, target_blend, dur, path_ease, morph_ease, policy, dt, opts_or_default);
                return lambda_result;
            };

            return iam_tween_path_morph_adapt_mutable_param_with_default_value(id, channel_id, path_a, path_b, target_blend, dur, path_ease, morph_ease, policy, dt, opts);
        },
        nb::arg("id"), nb::arg("channel_id"), nb::arg("path_a"), nb::arg("path_b"), nb::arg("target_blend"), nb::arg("dur"), nb::arg("path_ease"), nb::arg("morph_ease"), nb::arg("policy"), nb::arg("dt"), nb::arg("opts").none() = nb::none(),
        " Tween along a morphing path - animates both position along path AND the morph blend\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: morph_opts()");

    m.def("get_morph_blend",
        iam_get_morph_blend,
        nb::arg("id"), nb::arg("channel_id"),
        "Get current morph blend value from a tween (for querying state)");


    auto pyEnumtext_path_align =
        nb::enum_<iam_text_path_align>(m, "text_path_align", nb::is_arithmetic(), "Text alignment along path")
            .value("text_align_start", iam_text_align_start, "Text starts at path start (or offset)")
            .value("text_align_center", iam_text_align_center, "Text centered on path")
            .value("text_align_end", iam_text_align_end, "Text ends at path end");


    auto pyClassiam_text_path_opts =
        nb::class_<iam_text_path_opts>
            (m, "text_path_opts", "Text path options")
        .def_rw("origin", &iam_text_path_opts::origin, "Screen-space origin for rendering (path coords are offset by this)")
        .def_rw("offset", &iam_text_path_opts::offset, "Starting offset along path (pixels)")
        .def_rw("letter_spacing", &iam_text_path_opts::letter_spacing, "Extra spacing between characters (pixels)")
        .def_rw("align", &iam_text_path_opts::align, "iam_text_path_align value")
        .def_rw("flip_y", &iam_text_path_opts::flip_y, "Flip text vertically (for paths going right-to-left)")
        .def_rw("color", &iam_text_path_opts::color, "Text color (default: white)")
        .def_rw("font", &iam_text_path_opts::font, "Font to use (None = current font)")
        .def_rw("font_scale", &iam_text_path_opts::font_scale, "Additional font scale (1.0 = normal)")
        .def(nb::init<>())
        ;


    m.def("text_path",
        [](ImGuiID path_id, const char * text, const std::optional<const iam_text_path_opts> & opts = std::nullopt)
        {
            auto iam_text_path_adapt_mutable_param_with_default_value = [](ImGuiID path_id, const char * text, const std::optional<const iam_text_path_opts> & opts = std::nullopt)
            {

                const iam_text_path_opts& opts_or_default = [&]() -> const iam_text_path_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_text_path_opts();
                }();

                iam_text_path(path_id, text, opts_or_default);
            };

            iam_text_path_adapt_mutable_param_with_default_value(path_id, text, opts);
        },
        nb::arg("path_id"), nb::arg("text"), nb::arg("opts").none() = nb::none(),
        " Render text along a path (static - no animation)\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: text_path_opts()");

    m.def("text_path_animated",
        [](ImGuiID path_id, const char * text, float progress, const std::optional<const iam_text_path_opts> & opts = std::nullopt)
        {
            auto iam_text_path_animated_adapt_mutable_param_with_default_value = [](ImGuiID path_id, const char * text, float progress, const std::optional<const iam_text_path_opts> & opts = std::nullopt)
            {

                const iam_text_path_opts& opts_or_default = [&]() -> const iam_text_path_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_text_path_opts();
                }();

                iam_text_path_animated(path_id, text, progress, opts_or_default);
            };

            iam_text_path_animated_adapt_mutable_param_with_default_value(path_id, text, progress, opts);
        },
        nb::arg("path_id"), nb::arg("text"), nb::arg("progress"), nb::arg("opts").none() = nb::none(),
        " Animated text along path (characters appear progressively)\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: text_path_opts()");

    m.def("text_path_width",
        [](const char * text, const std::optional<const iam_text_path_opts> & opts = std::nullopt) -> float
        {
            auto iam_text_path_width_adapt_mutable_param_with_default_value = [](const char * text, const std::optional<const iam_text_path_opts> & opts = std::nullopt) -> float
            {

                const iam_text_path_opts& opts_or_default = [&]() -> const iam_text_path_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_text_path_opts();
                }();

                auto lambda_result = iam_text_path_width(text, opts_or_default);
                return lambda_result;
            };

            return iam_text_path_width_adapt_mutable_param_with_default_value(text, opts);
        },
        nb::arg("text"), nb::arg("opts").none() = nb::none(),
        " Helper: Get text width for path layout calculations\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: text_path_opts()");

    m.def("transform_quad",
        iam_transform_quad,
        nb::arg("quad"), nb::arg("center"), nb::arg("angle_rad"), nb::arg("translation"),
        "Transform a quad (4 vertices) by rotation and translation");

    m.def("make_glyph_quad",
        iam_make_glyph_quad,
        nb::arg("quad"), nb::arg("pos"), nb::arg("angle_rad"), nb::arg("glyph_width"), nb::arg("glyph_height"), nb::arg("baseline_offset") = 0.0f,
        "Create a rotated quad for a glyph at a position on the path");


    auto pyEnumtext_stagger_effect =
        nb::enum_<iam_text_stagger_effect>(m, "text_stagger_effect", nb::is_arithmetic(), "Text stagger effect types")
            .value("text_fx_none", iam_text_fx_none, "No effect (instant appear)")
            .value("text_fx_fade", iam_text_fx_fade, "Fade in alpha")
            .value("text_fx_scale", iam_text_fx_scale, "Scale from center")
            .value("text_fx_slide_up", iam_text_fx_slide_up, "Slide up from below")
            .value("text_fx_slide_down", iam_text_fx_slide_down, "Slide down from above")
            .value("text_fx_slide_left", iam_text_fx_slide_left, "Slide in from right")
            .value("text_fx_slide_right", iam_text_fx_slide_right, "Slide in from left")
            .value("text_fx_rotate", iam_text_fx_rotate, "Rotate in")
            .value("text_fx_bounce", iam_text_fx_bounce, "Bounce in with overshoot")
            .value("text_fx_wave", iam_text_fx_wave, "Wave motion (continuous)")
            .value("text_fx_typewriter", iam_text_fx_typewriter, "Typewriter style (instant per char)");


    auto pyClassiam_text_stagger_opts =
        nb::class_<iam_text_stagger_opts>
            (m, "text_stagger_opts", "Text stagger options")
        .def_rw("pos", &iam_text_stagger_opts::pos, "Base position for text")
        .def_rw("effect", &iam_text_stagger_opts::effect, "iam_text_stagger_effect")
        .def_rw("char_delay", &iam_text_stagger_opts::char_delay, "Delay between each character (seconds)")
        .def_rw("char_duration", &iam_text_stagger_opts::char_duration, "Duration of each character's animation (seconds)")
        .def_rw("effect_intensity", &iam_text_stagger_opts::effect_intensity, "Intensity of effect (pixels for slide, degrees for rotate, scale factor)")
        .def_rw("ease", &iam_text_stagger_opts::ease, "Easing for character animation")
        .def_rw("color", &iam_text_stagger_opts::color, "Text color")
        .def_rw("font", &iam_text_stagger_opts::font, "Font to use (None = current)")
        .def_rw("font_scale", &iam_text_stagger_opts::font_scale, "Font scale multiplier")
        .def_rw("letter_spacing", &iam_text_stagger_opts::letter_spacing, "Extra spacing between characters")
        .def(nb::init<>())
        ;


    m.def("text_stagger",
        [](ImGuiID id, const char * text, float progress, const std::optional<const iam_text_stagger_opts> & opts = std::nullopt)
        {
            auto iam_text_stagger_adapt_mutable_param_with_default_value = [](ImGuiID id, const char * text, float progress, const std::optional<const iam_text_stagger_opts> & opts = std::nullopt)
            {

                const iam_text_stagger_opts& opts_or_default = [&]() -> const iam_text_stagger_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_text_stagger_opts();
                }();

                iam_text_stagger(id, text, progress, opts_or_default);
            };

            iam_text_stagger_adapt_mutable_param_with_default_value(id, text, progress, opts);
        },
        nb::arg("id"), nb::arg("text"), nb::arg("progress"), nb::arg("opts").none() = nb::none(),
        " Render text with per-character stagger animation\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: text_stagger_opts()");

    m.def("text_stagger_width",
        [](const char * text, const std::optional<const iam_text_stagger_opts> & opts = std::nullopt) -> float
        {
            auto iam_text_stagger_width_adapt_mutable_param_with_default_value = [](const char * text, const std::optional<const iam_text_stagger_opts> & opts = std::nullopt) -> float
            {

                const iam_text_stagger_opts& opts_or_default = [&]() -> const iam_text_stagger_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_text_stagger_opts();
                }();

                auto lambda_result = iam_text_stagger_width(text, opts_or_default);
                return lambda_result;
            };

            return iam_text_stagger_width_adapt_mutable_param_with_default_value(text, opts);
        },
        nb::arg("text"), nb::arg("opts").none() = nb::none(),
        " Get text width for layout calculations\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: text_stagger_opts()");

    m.def("text_stagger_duration",
        [](const char * text, const std::optional<const iam_text_stagger_opts> & opts = std::nullopt) -> float
        {
            auto iam_text_stagger_duration_adapt_mutable_param_with_default_value = [](const char * text, const std::optional<const iam_text_stagger_opts> & opts = std::nullopt) -> float
            {

                const iam_text_stagger_opts& opts_or_default = [&]() -> const iam_text_stagger_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_text_stagger_opts();
                }();

                auto lambda_result = iam_text_stagger_duration(text, opts_or_default);
                return lambda_result;
            };

            return iam_text_stagger_duration_adapt_mutable_param_with_default_value(text, opts);
        },
        nb::arg("text"), nb::arg("opts").none() = nb::none(),
        " Get total animation duration for text (accounts for stagger delays)\n\n\nPython bindings defaults:\n    If opts is None, then its default value will be: text_stagger_opts()");


    auto pyEnumnoise_type =
        nb::enum_<iam_noise_type>(m, "noise_type", nb::is_arithmetic(), "Noise types")
            .value("noise_perlin", iam_noise_perlin, "Classic Perlin noise")
            .value("noise_simplex", iam_noise_simplex, "Simplex noise (faster, fewer artifacts)")
            .value("noise_value", iam_noise_value, "Value noise (blocky)")
            .value("noise_worley", iam_noise_worley, "Worley/cellular noise");


    auto pyClassiam_noise_opts =
        nb::class_<iam_noise_opts>
            (m, "noise_opts", "Noise options")
        .def_rw("type", &iam_noise_opts::type, "iam_noise_type")
        .def_rw("octaves", &iam_noise_opts::octaves, "Number of octaves for fractal noise (1-8)")
        .def_rw("persistence", &iam_noise_opts::persistence, "Amplitude multiplier per octave (0.0-1.0)")
        .def_rw("lacunarity", &iam_noise_opts::lacunarity, "Frequency multiplier per octave (typically 2.0)")
        .def_rw("seed", &iam_noise_opts::seed, "Random seed for noise generation")
        .def(nb::init<>())
        ;


    m.def("noise_2d",
        [](float x, float y, const std::optional<const iam_noise_opts> & opts = std::nullopt) -> float
        {
            auto iam_noise_2d_adapt_mutable_param_with_default_value = [](float x, float y, const std::optional<const iam_noise_opts> & opts = std::nullopt) -> float
            {

                const iam_noise_opts& opts_or_default = [&]() -> const iam_noise_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_noise_opts();
                }();

                auto lambda_result = iam_noise_2d(x, y, opts_or_default);
                return lambda_result;
            };

            return iam_noise_2d_adapt_mutable_param_with_default_value(x, y, opts);
        },
        nb::arg("x"), nb::arg("y"), nb::arg("opts").none() = nb::none(),
        "Python bindings defaults:\n    If opts is None, then its default value will be: noise_opts()\n\n 2D noise");

    m.def("noise_3d",
        [](float x, float y, float z, const std::optional<const iam_noise_opts> & opts = std::nullopt) -> float
        {
            auto iam_noise_3d_adapt_mutable_param_with_default_value = [](float x, float y, float z, const std::optional<const iam_noise_opts> & opts = std::nullopt) -> float
            {

                const iam_noise_opts& opts_or_default = [&]() -> const iam_noise_opts {
                    if (opts.has_value())
                        return opts.value();
                    else
                        return iam_noise_opts();
                }();

                auto lambda_result = iam_noise_3d(x, y, z, opts_or_default);
                return lambda_result;
            };

            return iam_noise_3d_adapt_mutable_param_with_default_value(x, y, z, opts);
        },
        nb::arg("x"), nb::arg("y"), nb::arg("z"), nb::arg("opts").none() = nb::none(),
        "Python bindings defaults:\n    If opts is None, then its default value will be: noise_opts()\n\n 3D noise");

    m.def("noise_channel_float",
        iam_noise_channel_float,
        nb::arg("id"), nb::arg("frequency"), nb::arg("amplitude"), nb::arg("opts"), nb::arg("dt"),
        "1D animated noise");

    m.def("noise_channel_vec2",
        iam_noise_channel_vec2,
        nb::arg("id"), nb::arg("frequency"), nb::arg("amplitude"), nb::arg("opts"), nb::arg("dt"),
        "2D animated noise");

    m.def("noise_channel_vec4",
        iam_noise_channel_vec4,
        nb::arg("id"), nb::arg("frequency"), nb::arg("amplitude"), nb::arg("opts"), nb::arg("dt"),
        "4D animated noise");

    m.def("noise_channel_color",
        iam_noise_channel_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("opts"), nb::arg("color_space"), nb::arg("dt"),
        "Animated color noise in specified color space");

    m.def("smooth_noise_float",
        iam_smooth_noise_float,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("speed"), nb::arg("dt"),
        "Simple 1D smooth noise");

    m.def("smooth_noise_vec2",
        iam_smooth_noise_vec2,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("speed"), nb::arg("dt"),
        "Simple 2D smooth noise");

    m.def("smooth_noise_vec4",
        iam_smooth_noise_vec4,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("speed"), nb::arg("dt"),
        "Simple 4D smooth noise");

    m.def("smooth_noise_color",
        iam_smooth_noise_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("amplitude"), nb::arg("speed"), nb::arg("color_space"), nb::arg("dt"),
        "Smooth noise for colors in specified color space");

    m.def("style_register",
        iam_style_register,
        nb::arg("style_id"), nb::arg("style"),
        "Register a style snapshot");

    m.def("style_register_current",
        iam_style_register_current,
        nb::arg("style_id"),
        "Register current ImGui style");

    m.def("style_blend",
        iam_style_blend,
        nb::arg("style_a"), nb::arg("style_b"), nb::arg("t"), nb::arg("color_space") = iam_color_space::iam_col_oklab,
        " Blend between two registered styles (result applied to ImGui::GetStyle())\n Uses iam_color_space for color blending mode (iam_col_oklab recommended)");

    m.def("style_tween",
        iam_style_tween,
        nb::arg("id"), nb::arg("target_style"), nb::arg("duration"), nb::arg("ease"), nb::arg("color_space"), nb::arg("dt"),
        "Tween between styles over time");

    m.def("style_blend_to",
        iam_style_blend_to,
        nb::arg("style_a"), nb::arg("style_b"), nb::arg("t"), nb::arg("out_style"), nb::arg("color_space") = iam_color_space::iam_col_oklab,
        "Get interpolated style without applying");

    m.def("style_exists",
        iam_style_exists,
        nb::arg("style_id"),
        "Check if a style is registered");

    m.def("style_unregister",
        iam_style_unregister,
        nb::arg("style_id"),
        "Remove a registered style");


    auto pyClassiam_gradient =
        nb::class_<iam_gradient>
            (m, "gradient", "Color gradient with any number of stops (sorted by position)")
        .def_rw("positions", &iam_gradient::positions, "Positions along gradient [0,1], kept sorted")
        .def_rw("colors", &iam_gradient::colors, "Colors at each position (sRGB)")
        .def(nb::init<>())
        .def("add",
            nb::overload_cast<float, ImVec4>(&iam_gradient::add),
            nb::arg("position"), nb::arg("color"),
            "Add a stop to the gradient (automatically sorted by position)")
        .def("add",
            nb::overload_cast<float, ImU32>(&iam_gradient::add), nb::arg("position"), nb::arg("color"))
        .def("stop_count",
            &iam_gradient::stop_count, "Get stop count")
        .def("sample",
            &iam_gradient::sample,
            nb::arg("t"), nb::arg("color_space") = iam_color_space::iam_col_oklab,
            "Sample the gradient at position t [0,1]")
        .def_static("solid",
            &iam_gradient::solid, nb::arg("color"))
        .def_static("two_color",
            &iam_gradient::two_color, nb::arg("start"), nb::arg("end"))
        .def_static("three_color",
            &iam_gradient::three_color, nb::arg("start"), nb::arg("mid"), nb::arg("end"))
        ;


    m.def("gradient_lerp",
        iam_gradient_lerp,
        nb::arg("a"), nb::arg("b"), nb::arg("t"), nb::arg("color_space") = iam_color_space::iam_col_oklab,
        "Blend between two gradients");

    m.def("tween_gradient",
        iam_tween_gradient,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("color_space"), nb::arg("dt"),
        "Tween between gradients over time");


    auto pyEnumrotation_mode =
        nb::enum_<iam_rotation_mode>(m, "rotation_mode", nb::is_arithmetic(), "Rotation interpolation modes")
            .value("rotation_shortest", iam_rotation_shortest, "Shortest path (default) - never rotates more than 180 degrees")
            .value("rotation_longest", iam_rotation_longest, "Longest path - always takes the long way around")
            .value("rotation_cw", iam_rotation_cw, "Clockwise - always rotates clockwise (positive direction)")
            .value("rotation_ccw", iam_rotation_ccw, "Counter-clockwise - always rotates counter-clockwise")
            .value("rotation_direct", iam_rotation_direct, "Direct lerp - no angle unwrapping, can cause spinning for large deltas");


    auto pyClassiam_transform =
        nb::class_<iam_transform>
            (m, "transform", "2D transform (position, rotation, scale)")
        .def_rw("position", &iam_transform::position, "Translation")
        .def_rw("scale", &iam_transform::scale, "Scale (1,1 = identity)")
        .def_rw("rotation", &iam_transform::rotation, "Rotation in radians")
        .def(nb::init<>())
        .def("__init__",
            [](iam_transform * self, ImVec2 pos, float rot = 0, const std::optional<const ImVec2> & scl = std::nullopt)
            {
                auto ctor_wrapper = [](iam_transform* self, ImVec2 pos, float rot = 0, ImVec2 scl = ImVec2(1, 1)) ->  void
                {
                    new(self) iam_transform(pos, rot, scl); // placement new
                };
                auto ctor_wrapper_adapt_mutable_param_with_default_value = [&ctor_wrapper](iam_transform * self, ImVec2 pos, float rot = 0, const std::optional<const ImVec2> & scl = std::nullopt)
                {

                    const ImVec2& scl_or_default = [&]() -> const ImVec2 {
                        if (scl.has_value())
                            return scl.value();
                        else
                            return ImVec2(1, 1);
                    }();

                    ctor_wrapper(self, pos, rot, scl_or_default);
                };

                ctor_wrapper_adapt_mutable_param_with_default_value(self, pos, rot, scl);
            },
            nb::arg("pos"), nb::arg("rot") = 0, nb::arg("scl").none() = nb::none(),
            "Python bindings defaults:\n    If scl is None, then its default value will be: ImVec2(1, 1)")
        .def_static("identity",
            &iam_transform::identity, "Create identity transform")
        .def("__mul__",
            &iam_transform::operator*,
            nb::arg("other"),
            "Combine transforms (this * other)")
        .def("apply",
            &iam_transform::apply,
            nb::arg("point"),
            "Apply transform to a point")
        .def("inverse",
            &iam_transform::inverse, "Get inverse transform")
        ;


    m.def("transform_lerp",
        iam_transform_lerp,
        nb::arg("a"), nb::arg("b"), nb::arg("t"), nb::arg("rotation_mode") = iam_rotation_mode::iam_rotation_shortest,
        "Blend between two transforms with rotation interpolation");

    m.def("tween_transform",
        iam_tween_transform,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("rotation_mode"), nb::arg("dt"),
        "Tween between transforms over time");

    m.def("transform_from_matrix",
        iam_transform_from_matrix,
        nb::arg("m00"), nb::arg("m01"), nb::arg("m10"), nb::arg("m11"), nb::arg("tx"), nb::arg("ty"),
        "Decompose a 3x2 matrix into transform components");

    m.def("transform_to_matrix",
        iam_transform_to_matrix,
        nb::arg("t"), nb::arg("out_matrix"),
        "Convert transform to 3x2 matrix (row-major: [m00 m01 tx; m10 m11 ty])");


    auto pyEnumdirection =
        nb::enum_<iam_direction>(m, "direction", nb::is_arithmetic(), "Direction for looping animations")
            .value("dir_normal", iam_dir_normal, "play forward")
            .value("dir_reverse", iam_dir_reverse, "play backward")
            .value("dir_alternate", iam_dir_alternate, "ping-pong");


    auto pyEnumchannel_type =
        nb::enum_<iam_channel_type>(m, "channel_type", nb::is_arithmetic(), "Channel types for keyframes")
            .value("chan_float", iam_chan_float, "")
            .value("chan_vec2", iam_chan_vec2, "")
            .value("chan_vec4", iam_chan_vec4, "")
            .value("chan_int", iam_chan_int, "")
            .value("chan_color", iam_chan_color, "Color with color space (stores in vec4 + color_space metadata)")
            .value("chan_float_rel", iam_chan_float_rel, "Float relative to anchor (percent + px_bias)")
            .value("chan_vec2_rel", iam_chan_vec2_rel, "Vec2 relative to anchor (percent.xy + px_bias.xy)")
            .value("chan_vec4_rel", iam_chan_vec4_rel, "Vec4 relative to anchor (percent.xy + px_bias.xy for x,y; z,w absolute)")
            .value("chan_color_rel", iam_chan_color_rel, "Color relative to anchor (for position-based color effects)");


    auto pyEnumresult =
        nb::enum_<iam_result>(m, "result", nb::is_arithmetic(), "Result codes")
            .value("ok", iam_ok, "")
            .value("err_not_found", iam_err_not_found, "")
            .value("err_bad_arg", iam_err_bad_arg, "")
            .value("err_no_mem", iam_err_no_mem, "");


    auto pyClassiam_spring_params =
        nb::class_<iam_spring_params>
            (m, "spring_params", "Spring parameters for physics-based animation")
        .def("__init__", [](iam_spring_params * self, float mass = float(), float stiffness = float(), float damping = float(), float initial_velocity = float())
        {
            new (self) iam_spring_params();  // placement new
            auto r_ctor_ = self;
            r_ctor_->mass = mass;
            r_ctor_->stiffness = stiffness;
            r_ctor_->damping = damping;
            r_ctor_->initial_velocity = initial_velocity;
        },
        nb::arg("mass") = float(), nb::arg("stiffness") = float(), nb::arg("damping") = float(), nb::arg("initial_velocity") = float()
        )
        .def_rw("mass", &iam_spring_params::mass, "")
        .def_rw("stiffness", &iam_spring_params::stiffness, "")
        .def_rw("damping", &iam_spring_params::damping, "")
        .def_rw("initial_velocity", &iam_spring_params::initial_velocity, "")
        ;


    auto pyEnumvariation_mode =
        nb::enum_<iam_variation_mode>(m, "variation_mode", nb::is_arithmetic(), "Variation modes for repeat animations")
            .value("var_none", iam_var_none, "No variation")
            .value("var_increment", iam_var_increment, "Add amount each iteration")
            .value("var_decrement", iam_var_decrement, "Subtract amount each iteration")
            .value("var_multiply", iam_var_multiply, "Multiply by factor each iteration")
            .value("var_random", iam_var_random, "Random in range [-amount, +amount]")
            .value("var_random_abs", iam_var_random_abs, "Random in range [0, amount]")
            .value("var_pingpong", iam_var_pingpong, "Alternate +/- each iteration")
            .value("var_callback", iam_var_callback, "Use custom callback");


    auto pyClassiam_variation_float =
        nb::class_<iam_variation_float>
            (m, "variation_float", "Float variation")
        .def("__init__", [](iam_variation_float * self, int mode = int(), float amount = float(), float min_clamp = float(), float max_clamp = float(), const std::optional<const iam_variation_float_fn> & callback = std::nullopt)
        {
            new (self) iam_variation_float();  // placement new
            auto r_ctor_ = self;
            r_ctor_->mode = mode;
            r_ctor_->amount = amount;
            r_ctor_->min_clamp = min_clamp;
            r_ctor_->max_clamp = max_clamp;
            if (callback.has_value())
                r_ctor_->callback = callback.value();
            else
                r_ctor_->callback = iam_variation_float_fn();
        },
        nb::arg("mode") = int(), nb::arg("amount") = float(), nb::arg("min_clamp") = float(), nb::arg("max_clamp") = float(), nb::arg("callback").none() = nb::none()
        )
        .def_rw("mode", &iam_variation_float::mode, "")
        .def_rw("amount", &iam_variation_float::amount, "")
        .def_rw("min_clamp", &iam_variation_float::min_clamp, "")
        .def_rw("max_clamp", &iam_variation_float::max_clamp, "")
        .def_rw("seed", &iam_variation_float::seed, "0 = global random, non-zero = deterministic")
        .def_rw("callback", &iam_variation_float::callback, "")
        .def_rw("user", &iam_variation_float::user, "")
        ;


    auto pyClassiam_variation_int =
        nb::class_<iam_variation_int>
            (m, "variation_int", "Int variation")
        .def("__init__", [](iam_variation_int * self, int mode = int(), int amount = int(), int min_clamp = int(), int max_clamp = int(), const std::optional<const iam_variation_int_fn> & callback = std::nullopt)
        {
            new (self) iam_variation_int();  // placement new
            auto r_ctor_ = self;
            r_ctor_->mode = mode;
            r_ctor_->amount = amount;
            r_ctor_->min_clamp = min_clamp;
            r_ctor_->max_clamp = max_clamp;
            if (callback.has_value())
                r_ctor_->callback = callback.value();
            else
                r_ctor_->callback = iam_variation_int_fn();
        },
        nb::arg("mode") = int(), nb::arg("amount") = int(), nb::arg("min_clamp") = int(), nb::arg("max_clamp") = int(), nb::arg("callback").none() = nb::none()
        )
        .def_rw("mode", &iam_variation_int::mode, "")
        .def_rw("amount", &iam_variation_int::amount, "")
        .def_rw("min_clamp", &iam_variation_int::min_clamp, "")
        .def_rw("max_clamp", &iam_variation_int::max_clamp, "")
        .def_rw("seed", &iam_variation_int::seed, "")
        .def_rw("callback", &iam_variation_int::callback, "")
        .def_rw("user", &iam_variation_int::user, "")
        ;


    auto pyClassiam_variation_vec2 =
        nb::class_<iam_variation_vec2>
            (m, "variation_vec2", "Vec2 variation (global mode or per-axis)")
        .def("__init__", [](iam_variation_vec2 * self, int mode = int(), const std::optional<const ImVec2> & amount = std::nullopt, const std::optional<const ImVec2> & min_clamp = std::nullopt, const std::optional<const ImVec2> & max_clamp = std::nullopt, const std::optional<const iam_variation_vec2_fn> & callback = std::nullopt, const std::optional<const iam_variation_float> & x = std::nullopt, const std::optional<const iam_variation_float> & y = std::nullopt)
        {
            new (self) iam_variation_vec2();  // placement new
            auto r_ctor_ = self;
            r_ctor_->mode = mode;
            if (amount.has_value())
                r_ctor_->amount = amount.value();
            else
                r_ctor_->amount = ImVec2();
            if (min_clamp.has_value())
                r_ctor_->min_clamp = min_clamp.value();
            else
                r_ctor_->min_clamp = ImVec2();
            if (max_clamp.has_value())
                r_ctor_->max_clamp = max_clamp.value();
            else
                r_ctor_->max_clamp = ImVec2();
            if (callback.has_value())
                r_ctor_->callback = callback.value();
            else
                r_ctor_->callback = iam_variation_vec2_fn();
            if (x.has_value())
                r_ctor_->x = x.value();
            else
                r_ctor_->x = iam_variation_float();
            if (y.has_value())
                r_ctor_->y = y.value();
            else
                r_ctor_->y = iam_variation_float();
        },
        nb::arg("mode") = int(), nb::arg("amount").none() = nb::none(), nb::arg("min_clamp").none() = nb::none(), nb::arg("max_clamp").none() = nb::none(), nb::arg("callback").none() = nb::none(), nb::arg("x").none() = nb::none(), nb::arg("y").none() = nb::none()
        )
        .def_rw("mode", &iam_variation_vec2::mode, "Global mode (iam_var_none = use per-axis)")
        .def_rw("amount", &iam_variation_vec2::amount, "")
        .def_rw("min_clamp", &iam_variation_vec2::min_clamp, "")
        .def_rw("max_clamp", &iam_variation_vec2::max_clamp, "")
        .def_rw("seed", &iam_variation_vec2::seed, "")
        .def_rw("callback", &iam_variation_vec2::callback, "")
        .def_rw("user", &iam_variation_vec2::user, "")
        .def_rw("x", &iam_variation_vec2::x, "Per-axis (used when mode == iam_var_none)")
        .def_rw("y", &iam_variation_vec2::y, "Per-axis (used when mode == iam_var_none)")
        ;


    auto pyClassiam_variation_vec4 =
        nb::class_<iam_variation_vec4>
            (m, "variation_vec4", "Vec4 variation (global mode or per-axis)")
        .def("__init__", [](iam_variation_vec4 * self, int mode = int(), const std::optional<const ImVec4> & amount = std::nullopt, const std::optional<const ImVec4> & min_clamp = std::nullopt, const std::optional<const ImVec4> & max_clamp = std::nullopt, const std::optional<const iam_variation_vec4_fn> & callback = std::nullopt, const std::optional<const iam_variation_float> & x = std::nullopt, const std::optional<const iam_variation_float> & y = std::nullopt, const std::optional<const iam_variation_float> & z = std::nullopt, const std::optional<const iam_variation_float> & w = std::nullopt)
        {
            new (self) iam_variation_vec4();  // placement new
            auto r_ctor_ = self;
            r_ctor_->mode = mode;
            if (amount.has_value())
                r_ctor_->amount = amount.value();
            else
                r_ctor_->amount = ImVec4();
            if (min_clamp.has_value())
                r_ctor_->min_clamp = min_clamp.value();
            else
                r_ctor_->min_clamp = ImVec4();
            if (max_clamp.has_value())
                r_ctor_->max_clamp = max_clamp.value();
            else
                r_ctor_->max_clamp = ImVec4();
            if (callback.has_value())
                r_ctor_->callback = callback.value();
            else
                r_ctor_->callback = iam_variation_vec4_fn();
            if (x.has_value())
                r_ctor_->x = x.value();
            else
                r_ctor_->x = iam_variation_float();
            if (y.has_value())
                r_ctor_->y = y.value();
            else
                r_ctor_->y = iam_variation_float();
            if (z.has_value())
                r_ctor_->z = z.value();
            else
                r_ctor_->z = iam_variation_float();
            if (w.has_value())
                r_ctor_->w = w.value();
            else
                r_ctor_->w = iam_variation_float();
        },
        nb::arg("mode") = int(), nb::arg("amount").none() = nb::none(), nb::arg("min_clamp").none() = nb::none(), nb::arg("max_clamp").none() = nb::none(), nb::arg("callback").none() = nb::none(), nb::arg("x").none() = nb::none(), nb::arg("y").none() = nb::none(), nb::arg("z").none() = nb::none(), nb::arg("w").none() = nb::none()
        )
        .def_rw("mode", &iam_variation_vec4::mode, "")
        .def_rw("amount", &iam_variation_vec4::amount, "")
        .def_rw("min_clamp", &iam_variation_vec4::min_clamp, "")
        .def_rw("max_clamp", &iam_variation_vec4::max_clamp, "")
        .def_rw("seed", &iam_variation_vec4::seed, "")
        .def_rw("callback", &iam_variation_vec4::callback, "")
        .def_rw("user", &iam_variation_vec4::user, "")
        .def_rw("x", &iam_variation_vec4::x, "Per-axis")
        .def_rw("y", &iam_variation_vec4::y, "Per-axis")
        .def_rw("z", &iam_variation_vec4::z, "Per-axis")
        .def_rw("w", &iam_variation_vec4::w, "Per-axis")
        ;


    auto pyClassiam_variation_color =
        nb::class_<iam_variation_color>
            (m, "variation_color", "Color variation (global mode or per-channel)")
        .def("__init__", [](iam_variation_color * self, int mode = int(), const std::optional<const ImVec4> & amount = std::nullopt, const std::optional<const ImVec4> & min_clamp = std::nullopt, const std::optional<const ImVec4> & max_clamp = std::nullopt, int color_space = int(), const std::optional<const iam_variation_vec4_fn> & callback = std::nullopt, const std::optional<const iam_variation_float> & r = std::nullopt, const std::optional<const iam_variation_float> & g = std::nullopt, const std::optional<const iam_variation_float> & b = std::nullopt, const std::optional<const iam_variation_float> & a = std::nullopt)
        {
            new (self) iam_variation_color();  // placement new
            auto r_ctor_ = self;
            r_ctor_->mode = mode;
            if (amount.has_value())
                r_ctor_->amount = amount.value();
            else
                r_ctor_->amount = ImVec4();
            if (min_clamp.has_value())
                r_ctor_->min_clamp = min_clamp.value();
            else
                r_ctor_->min_clamp = ImVec4();
            if (max_clamp.has_value())
                r_ctor_->max_clamp = max_clamp.value();
            else
                r_ctor_->max_clamp = ImVec4();
            r_ctor_->color_space = color_space;
            if (callback.has_value())
                r_ctor_->callback = callback.value();
            else
                r_ctor_->callback = iam_variation_vec4_fn();
            if (r.has_value())
                r_ctor_->r = r.value();
            else
                r_ctor_->r = iam_variation_float();
            if (g.has_value())
                r_ctor_->g = g.value();
            else
                r_ctor_->g = iam_variation_float();
            if (b.has_value())
                r_ctor_->b = b.value();
            else
                r_ctor_->b = iam_variation_float();
            if (a.has_value())
                r_ctor_->a = a.value();
            else
                r_ctor_->a = iam_variation_float();
        },
        nb::arg("mode") = int(), nb::arg("amount").none() = nb::none(), nb::arg("min_clamp").none() = nb::none(), nb::arg("max_clamp").none() = nb::none(), nb::arg("color_space") = int(), nb::arg("callback").none() = nb::none(), nb::arg("r").none() = nb::none(), nb::arg("g").none() = nb::none(), nb::arg("b").none() = nb::none(), nb::arg("a").none() = nb::none()
        )
        .def_rw("mode", &iam_variation_color::mode, "")
        .def_rw("amount", &iam_variation_color::amount, "")
        .def_rw("min_clamp", &iam_variation_color::min_clamp, "")
        .def_rw("max_clamp", &iam_variation_color::max_clamp, "")
        .def_rw("color_space", &iam_variation_color::color_space, "iam_col_oklab, etc.")
        .def_rw("seed", &iam_variation_color::seed, "")
        .def_rw("callback", &iam_variation_color::callback, "Returns ImVec4 color delta")
        .def_rw("user", &iam_variation_color::user, "")
        .def_rw("r", &iam_variation_color::r, "Per-channel")
        .def_rw("g", &iam_variation_color::g, "Per-channel")
        .def_rw("b", &iam_variation_color::b, "Per-channel")
        .def_rw("a", &iam_variation_color::a, "Per-channel")
        ;


    m.def("varf_none",
        iam_varf_none);

    m.def("varf_inc",
        iam_varf_inc, nb::arg("amt"));

    m.def("varf_dec",
        iam_varf_dec, nb::arg("amt"));

    m.def("varf_mul",
        iam_varf_mul, nb::arg("f"));

    m.def("varf_rand",
        iam_varf_rand, nb::arg("r"));

    m.def("varf_rand_abs",
        iam_varf_rand_abs, nb::arg("r"));

    m.def("varf_pingpong",
        iam_varf_pingpong, nb::arg("amt"));

    m.def("varf_fn",
        iam_varf_fn, nb::arg("fn"), nb::arg("user"));

    m.def("varf_clamp",
        iam_varf_clamp, nb::arg("v"), nb::arg("mn"), nb::arg("mx"));

    m.def("varf_seed",
        iam_varf_seed, nb::arg("v"), nb::arg("s"));

    m.def("vari_none",
        iam_vari_none);

    m.def("vari_inc",
        iam_vari_inc, nb::arg("amt"));

    m.def("vari_dec",
        iam_vari_dec, nb::arg("amt"));

    m.def("vari_rand",
        iam_vari_rand, nb::arg("r"));

    m.def("vari_fn",
        iam_vari_fn, nb::arg("fn"), nb::arg("user"));

    m.def("vari_clamp",
        iam_vari_clamp, nb::arg("v"), nb::arg("mn"), nb::arg("mx"));

    m.def("vari_seed",
        iam_vari_seed, nb::arg("v"), nb::arg("s"));

    m.def("varv2_none",
        iam_varv2_none);

    m.def("varv2_inc",
        iam_varv2_inc, nb::arg("x"), nb::arg("y"));

    m.def("varv2_dec",
        iam_varv2_dec, nb::arg("x"), nb::arg("y"));

    m.def("varv2_mul",
        iam_varv2_mul, nb::arg("f"));

    m.def("varv2_rand",
        iam_varv2_rand, nb::arg("x"), nb::arg("y"));

    m.def("varv2_fn",
        iam_varv2_fn, nb::arg("fn"), nb::arg("user"));

    m.def("varv2_axis",
        iam_varv2_axis, nb::arg("vx"), nb::arg("vy"));

    m.def("varv2_clamp",
        iam_varv2_clamp, nb::arg("v"), nb::arg("mn"), nb::arg("mx"));

    m.def("varv2_seed",
        iam_varv2_seed, nb::arg("v"), nb::arg("s"));

    m.def("varv4_none",
        iam_varv4_none);

    m.def("varv4_inc",
        iam_varv4_inc, nb::arg("x"), nb::arg("y"), nb::arg("z"), nb::arg("w"));

    m.def("varv4_dec",
        iam_varv4_dec, nb::arg("x"), nb::arg("y"), nb::arg("z"), nb::arg("w"));

    m.def("varv4_mul",
        iam_varv4_mul, nb::arg("f"));

    m.def("varv4_rand",
        iam_varv4_rand, nb::arg("x"), nb::arg("y"), nb::arg("z"), nb::arg("w"));

    m.def("varv4_fn",
        iam_varv4_fn, nb::arg("fn"), nb::arg("user"));

    m.def("varv4_axis",
        iam_varv4_axis, nb::arg("vx"), nb::arg("vy"), nb::arg("vz"), nb::arg("vw"));

    m.def("varv4_clamp",
        iam_varv4_clamp, nb::arg("v"), nb::arg("mn"), nb::arg("mx"));

    m.def("varv4_seed",
        iam_varv4_seed, nb::arg("v"), nb::arg("s"));

    m.def("varc_none",
        iam_varc_none);

    m.def("varc_inc",
        iam_varc_inc, nb::arg("r"), nb::arg("g"), nb::arg("b"), nb::arg("a"));

    m.def("varc_dec",
        iam_varc_dec, nb::arg("r"), nb::arg("g"), nb::arg("b"), nb::arg("a"));

    m.def("varc_mul",
        iam_varc_mul, nb::arg("f"));

    m.def("varc_rand",
        iam_varc_rand, nb::arg("r"), nb::arg("g"), nb::arg("b"), nb::arg("a"));

    m.def("varc_fn",
        iam_varc_fn, nb::arg("fn"), nb::arg("user"));

    m.def("varc_channel",
        iam_varc_channel, nb::arg("vr"), nb::arg("vg"), nb::arg("vb"), nb::arg("va"));

    m.def("varc_space",
        iam_varc_space, nb::arg("v"), nb::arg("space"));

    m.def("varc_clamp",
        iam_varc_clamp, nb::arg("v"), nb::arg("mn"), nb::arg("mx"));

    m.def("varc_seed",
        iam_varc_seed, nb::arg("v"), nb::arg("s"));


    auto pyClassiam_clip =
        nb::class_<iam_clip>
            (m, "clip", " ----------------------------------------------------\n iam_clip - fluent API for authoring animations\n ----------------------------------------------------")
        .def_static("begin",
            &iam_clip::begin,
            nb::arg("clip_id"),
            "Start building a new clip with the given ID")
        .def("key_float",
            &iam_clip::key_float, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_vec2",
            &iam_clip::key_vec2, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_vec4",
            &iam_clip::key_vec4, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_int",
            &iam_clip::key_int, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear)
        .def("key_color",
            &iam_clip::key_color, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("color_space") = iam_color_space::iam_col_oklab, nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_float_var",
            &iam_clip::key_float_var, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("var"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_vec2_var",
            &iam_clip::key_vec2_var, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("var"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_vec4_var",
            &iam_clip::key_vec4_var, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("var"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_int_var",
            &iam_clip::key_int_var, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("var"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear)
        .def("key_color_var",
            &iam_clip::key_color_var, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("var"), nb::arg("color_space") = iam_color_space::iam_col_oklab, nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_float_spring",
            &iam_clip::key_float_spring,
            nb::arg("channel"), nb::arg("time"), nb::arg("target"), nb::arg("spring"),
            "Spring-based keyframe (float only)")
        .def("key_float_rel",
            &iam_clip::key_float_rel, nb::arg("channel"), nb::arg("time"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("anchor_space"), nb::arg("axis"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_vec2_rel",
            &iam_clip::key_vec2_rel, nb::arg("channel"), nb::arg("time"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("anchor_space"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_vec4_rel",
            &iam_clip::key_vec4_rel, nb::arg("channel"), nb::arg("time"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("anchor_space"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("key_color_rel",
            &iam_clip::key_color_rel, nb::arg("channel"), nb::arg("time"), nb::arg("percent"), nb::arg("px_bias"), nb::arg("color_space"), nb::arg("anchor_space"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear, nb::arg("bezier4") = nb::none())
        .def("seq_begin",
            &iam_clip::seq_begin, "Start sequential block (keyframes after seq_end start after this block)")
        .def("seq_end",
            &iam_clip::seq_end)
        .def("par_begin",
            &iam_clip::par_begin, "Start parallel block (keyframes play at same time offset)")
        .def("par_end",
            &iam_clip::par_end)
        .def("marker",
            [](iam_clip & self, float time, ImGuiID marker_id, iam_marker_callback cb) -> iam_clip &
            {
                auto marker_adapt_exclude_params = [&self](float time, ImGuiID marker_id, iam_marker_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.marker(time, marker_id, cb, nullptr);
                    return lambda_result;
                };

                return marker_adapt_exclude_params(time, marker_id, cb);
            },
            nb::arg("time"), nb::arg("marker_id"), nb::arg("cb"),
            "Add marker at specific time.")
        .def("marker",
            [](iam_clip & self, float time, iam_marker_callback cb) -> iam_clip &
            {
                auto marker_adapt_exclude_params = [&self](float time, iam_marker_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.marker(time, cb, nullptr);
                    return lambda_result;
                };

                return marker_adapt_exclude_params(time, cb);
            },
            nb::arg("time"), nb::arg("cb"),
            "Add marker (auto-generated ID).")
        .def("set_loop",
            &iam_clip::set_loop, nb::arg("loop"), nb::arg("direction") = iam_direction::iam_dir_normal, nb::arg("loop_count") = -1)
        .def("set_delay",
            &iam_clip::set_delay, nb::arg("delay_seconds"))
        .def("set_stagger",
            &iam_clip::set_stagger, nb::arg("count"), nb::arg("each_delay"), nb::arg("from_center_bias") = 0.0f)
        .def("set_duration_var",
            &iam_clip::set_duration_var,
            nb::arg("var"),
            "Vary clip duration per loop")
        .def("set_delay_var",
            &iam_clip::set_delay_var,
            nb::arg("var"),
            "Vary delay between loops")
        .def("set_timescale_var",
            &iam_clip::set_timescale_var,
            nb::arg("var"),
            "Vary playback speed per loop")
        .def("on_begin",
            [](iam_clip & self, iam_clip_callback cb) -> iam_clip &
            {
                auto on_begin_adapt_exclude_params = [&self](iam_clip_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.on_begin(cb, nullptr);
                    return lambda_result;
                };

                return on_begin_adapt_exclude_params(cb);
            },     nb::arg("cb"))
        .def("on_update",
            [](iam_clip & self, iam_clip_callback cb) -> iam_clip &
            {
                auto on_update_adapt_exclude_params = [&self](iam_clip_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.on_update(cb, nullptr);
                    return lambda_result;
                };

                return on_update_adapt_exclude_params(cb);
            },     nb::arg("cb"))
        .def("on_complete",
            [](iam_clip & self, iam_clip_callback cb) -> iam_clip &
            {
                auto on_complete_adapt_exclude_params = [&self](iam_clip_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.on_complete(cb, nullptr);
                    return lambda_result;
                };

                return on_complete_adapt_exclude_params(cb);
            },     nb::arg("cb"))
        .def("end",
            &iam_clip::end, "Finalize the clip")
        .def("id",
            &iam_clip::id, "Get the clip ID")
        ;


    auto pyClassiam_instance =
        nb::class_<iam_instance>
            (m, "instance", " ----------------------------------------------------\n iam_instance - playback control for a clip\n ----------------------------------------------------")
        .def(nb::init<>())
        .def(nb::init<ImGuiID>(),
            nb::arg("inst_id"))
        .def("pause",
            &iam_instance::pause)
        .def("resume",
            &iam_instance::resume)
        .def("stop",
            &iam_instance::stop)
        .def("destroy",
            &iam_instance::destroy, "Remove instance from system (valid() will return False after this)")
        .def("seek",
            &iam_instance::seek, nb::arg("time"))
        .def("set_time_scale",
            &iam_instance::set_time_scale, nb::arg("scale"))
        .def("set_weight",
            &iam_instance::set_weight,
            nb::arg("weight"),
            "for layering/blending")
        .def("then",
            nb::overload_cast<ImGuiID>(&iam_instance::then),
            nb::arg("next_clip_id"),
            "Chain another clip to play after this one.")
        .def("then",
            nb::overload_cast<ImGuiID, ImGuiID>(&iam_instance::then),
            nb::arg("next_clip_id"), nb::arg("next_instance_id"),
            "Chain with specific instance ID.")
        .def("then_delay",
            &iam_instance::then_delay,
            nb::arg("delay"),
            "Set delay before chained clip starts.")
        .def("time",
            &iam_instance::time)
        .def("duration",
            &iam_instance::duration)
        .def("is_playing",
            &iam_instance::is_playing)
        .def("is_paused",
            &iam_instance::is_paused)
        .def("get_float",
            &iam_instance::get_float, nb::arg("channel"), nb::arg("out"))
        .def("get_vec2",
            &iam_instance::get_vec2, nb::arg("channel"), nb::arg("out"))
        .def("get_vec4",
            &iam_instance::get_vec4, nb::arg("channel"), nb::arg("out"))
        .def("get_int",
            &iam_instance::get_int, nb::arg("channel"), nb::arg("out"))
        .def("get_color",
            &iam_instance::get_color,
            nb::arg("channel"), nb::arg("out"), nb::arg("color_space") = iam_color_space::iam_col_oklab,
            "Color blended in specified color space.")
        .def("valid",
            &iam_instance::valid, "Check validity")
        .def("__bool__",
            &iam_instance::operator bool)
        .def("id",
            &iam_instance::id)
        ;


    m.def("clip_init",
        iam_clip_init, nb::arg("initial_clip_cap") = 256, nb::arg("initial_inst_cap") = 4096);

    m.def("clip_shutdown",
        iam_clip_shutdown);

    m.def("clip_update",
        iam_clip_update,
        nb::arg("dt"),
        "Per-frame update (call after iam_update_begin_frame)");

    m.def("clip_gc",
        iam_clip_gc,
        nb::arg("max_age_frames") = 600,
        "Garbage collection for instances");

    m.def("play",
        iam_play,
        nb::arg("clip_id"), nb::arg("instance_id"),
        "Play a clip on an instance (creates or reuses instance)");

    m.def("get_instance",
        iam_get_instance,
        nb::arg("instance_id"),
        "Get an existing instance (returns invalid iam_instance if not found)");

    m.def("clip_duration",
        iam_clip_duration,
        nb::arg("clip_id"),
        "Get clip duration in seconds.");

    m.def("clip_exists",
        iam_clip_exists,
        nb::arg("clip_id"),
        "Check if clip exists.");

    m.def("stagger_delay",
        iam_stagger_delay,
        nb::arg("clip_id"), nb::arg("index"),
        "Get stagger delay for element at index.");

    m.def("play_stagger",
        iam_play_stagger,
        nb::arg("clip_id"), nb::arg("instance_id"), nb::arg("index"),
        "Play with stagger delay applied.");

    m.def("layer_begin",
        iam_layer_begin,
        nb::arg("instance_id"),
        "Start blending into target instance.");

    m.def("layer_add",
        iam_layer_add,
        nb::arg("inst"), nb::arg("weight"),
        "Add source instance with weight.");

    m.def("layer_end",
        iam_layer_end,
        nb::arg("instance_id"),
        "Finalize blending and normalize weights.");

    m.def("get_blended_float",
        iam_get_blended_float,
        nb::arg("instance_id"), nb::arg("channel"), nb::arg("out"),
        "Get blended float value.");

    m.def("get_blended_vec2",
        iam_get_blended_vec2,
        nb::arg("instance_id"), nb::arg("channel"), nb::arg("out"),
        "Get blended vec2 value.");

    m.def("get_blended_vec4",
        iam_get_blended_vec4,
        nb::arg("instance_id"), nb::arg("channel"), nb::arg("out"),
        "Get blended vec4 value.");

    m.def("get_blended_int",
        iam_get_blended_int,
        nb::arg("instance_id"), nb::arg("channel"), nb::arg("out"),
        "Get blended int value.");

    m.def("clip_save",
        iam_clip_save, nb::arg("clip_id"), nb::arg("path"));

    m.def("clip_load",
        iam_clip_load, nb::arg("path"), nb::arg("out_clip_id"));

    m.def("demo_window",
        ImAnimDemoWindow, nb::arg("create_window") = true);

    m.def("doc_window",
        ImAnimDocWindow, nb::arg("create_window") = true);

    m.def("usecase_window",
        ImAnimUsecaseWindow, nb::arg("create_window") = true);
    ////////////////////    </generated_from:im_anim.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
