// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2025 Pascal Thomet - https://github.com/pthom/imgui_bundle
#ifdef IMGUI_BUNDLE_WITH_IMANIM
#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>

#include "ImAnim/im_anim.h"

namespace nb = nanobind;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_imanim(nb::module_& m)
{
    // ImAnim uses C-style API at global scope, no namespace

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:im_anim.h>    ////////////////////
    // #ifdef IMGUI_BUNDLE_PYTHON_API
    //
    // #endif
    //


    auto pyEnumease_type =
        nb::enum_<iam_ease_type>(m, "ease_type", nb::is_arithmetic(), " ----------------------------------------------------\n Public enums & descriptors (C-style)\n ----------------------------------------------------")
            .value("ease_linear", iam_ease_linear, "")
            .value("ease_in_quad", iam_ease_in_quad, "")
            .value("ease_out_quad", iam_ease_out_quad, "")
            .value("ease_in_out_quad", iam_ease_in_out_quad, "")
            .value("ease_in_cubic", iam_ease_in_cubic, "")
            .value("ease_out_cubic", iam_ease_out_cubic, "")
            .value("ease_in_out_cubic", iam_ease_in_out_cubic, "")
            .value("ease_in_quart", iam_ease_in_quart, "")
            .value("ease_out_quart", iam_ease_out_quart, "")
            .value("ease_in_out_quart", iam_ease_in_out_quart, "")
            .value("ease_in_quint", iam_ease_in_quint, "")
            .value("ease_out_quint", iam_ease_out_quint, "")
            .value("ease_in_out_quint", iam_ease_in_out_quint, "")
            .value("ease_in_sine", iam_ease_in_sine, "")
            .value("ease_out_sine", iam_ease_out_sine, "")
            .value("ease_in_out_sine", iam_ease_in_out_sine, "")
            .value("ease_in_expo", iam_ease_in_expo, "")
            .value("ease_out_expo", iam_ease_out_expo, "")
            .value("ease_in_out_expo", iam_ease_in_out_expo, "")
            .value("ease_in_circ", iam_ease_in_circ, "")
            .value("ease_out_circ", iam_ease_out_circ, "")
            .value("ease_in_out_circ", iam_ease_in_out_circ, "")
            .value("ease_in_back", iam_ease_in_back, "")
            .value("ease_out_back", iam_ease_out_back, "")
            .value("ease_in_out_back", iam_ease_in_out_back, "p0 = overshoot")
            .value("ease_in_elastic", iam_ease_in_elastic, "")
            .value("ease_out_elastic", iam_ease_out_elastic, "")
            .value("ease_in_out_elastic", iam_ease_in_out_elastic, "p0 = amplitude, p1 = period")
            .value("ease_in_bounce", iam_ease_in_bounce, "")
            .value("ease_out_bounce", iam_ease_out_bounce, "")
            .value("ease_in_out_bounce", iam_ease_in_out_bounce, "")
            .value("ease_steps", iam_ease_steps, "p0 = steps (>=1), p1 = 0:end 1:start 2:both")
            .value("ease_cubic_bezier", iam_ease_cubic_bezier, "p0=x1 p1=y1 p2=x2 p3=y2")
            .value("ease_spring", iam_ease_spring, "p0=mass p1=stiffness p2=damping p3=v0")
            .value("ease_custom", iam_ease_custom, "User-defined easing function (use iam_ease_custom_fn)");


    auto pyEnumpolicy =
        nb::enum_<iam_policy>(m, "policy", nb::is_arithmetic(), "")
            .value("crossfade", iam_policy_crossfade, "smooth into new target")
            .value("cut", iam_policy_cut, "snap to target")
            .value("queue", iam_policy_queue, "queue one pending target");


    auto pyEnumcolor_space =
        nb::enum_<iam_color_space>(m, "color_space", nb::is_arithmetic(), "")
            .value("col_srgb", iam_col_srgb, "blend in sRGB (not physically linear)")
            .value("col_srgb_linear", iam_col_srgb_linear, "sRGB<->linear, blend in linear, back to sRGB")
            .value("col_hsv", iam_col_hsv, "blend H/S/V (hue shortest arc), keep A linear")
            .value("col_oklab", iam_col_oklab, "sRGB<->OKLAB, blend in OKLAB, back to sRGB")
            .value("col_oklch", iam_col_oklch, "sRGB<->OKLCH (cylindrical OKLAB), blend in OKLCH, back to sRGB");


    auto pyClassiam_ease_desc =
        nb::class_<iam_ease_desc>
            (m, "ease_desc", "Descriptor for any easing (preset or parametric)")
        .def("__init__", [](iam_ease_desc * self, int type = int(), float p0 = float(), float p1 = float(), float p2 = float(), float p3 = float())
        {
            new (self) iam_ease_desc();  // placement new
            auto r_ctor_ = self;
            r_ctor_->type = type;
            r_ctor_->p0 = p0;
            r_ctor_->p1 = p1;
            r_ctor_->p2 = p2;
            r_ctor_->p3 = p3;
        },
        nb::arg("type") = int(), nb::arg("p0") = float(), nb::arg("p1") = float(), nb::arg("p2") = float(), nb::arg("p3") = float()
        )
        .def_rw("type", &iam_ease_desc::type, "iam_ease_type")
        .def_rw("p0", &iam_ease_desc::p0, "")
        .def_rw("p1", &iam_ease_desc::p1, "")
        .def_rw("p2", &iam_ease_desc::p2, "")
        .def_rw("p3", &iam_ease_desc::p3, "")
        ;
    // #ifdef IMGUI_BUNDLE_PYTHON_API
    //
    // #else
    //
    // #endif
    //

    m.def("update_begin_frame",
        iam_update_begin_frame, "Call once per frame before any tweens.");

    m.def("gc",
        iam_gc,
        nb::arg("max_age_frames") = 600,
        "Remove stale tween entries older than max_age_frames.");

    m.def("pool_clear",
        iam_pool_clear, "Manually clean up pools.");

    m.def("reserve",
        iam_reserve,
        nb::arg("cap_float"), nb::arg("cap_vec2"), nb::arg("cap_vec4"), nb::arg("cap_int"), nb::arg("cap_color"),
        "Pre-allocate pool capacity.");

    m.def("set_ease_lut_samples",
        iam_set_ease_lut_samples,
        nb::arg("count"),
        "Set LUT resolution for parametric easings (default: 256).");

    m.def("set_global_time_scale",
        iam_set_global_time_scale,
        nb::arg("scale"),
        "Set global time multiplier (1.0 = normal, 0.5 = half speed, 2.0 = double).");

    m.def("get_global_time_scale",
        []() -> float
        {
            auto iam_get_global_time_scale_adapt_force_lambda = []() -> float
            {
                auto lambda_result = iam_get_global_time_scale();
                return lambda_result;
            };

            return iam_get_global_time_scale_adapt_force_lambda();
        },     "Get current global time scale.");

    m.def("set_lazy_init",
        iam_set_lazy_init,
        nb::arg("enable"),
        "Enable/disable lazy initialization (default: True).");

    m.def("is_lazy_init_enabled",
        iam_is_lazy_init_enabled, "Check if lazy init is enabled.");

    m.def("register_custom_ease",
        iam_register_custom_ease,
        nb::arg("slot"), nb::arg("fn"),
        "Register custom easing in slot 0-15. Use with iam_ease_custom_fn(slot).");

    m.def("get_custom_ease",
        [](int slot) -> iam_ease_fn
        {
            auto iam_get_custom_ease_adapt_force_lambda = [](int slot) -> iam_ease_fn
            {
                auto lambda_result = iam_get_custom_ease(slot);
                return lambda_result;
            };

            return iam_get_custom_ease_adapt_force_lambda(slot);
        },
        nb::arg("slot"),
        "Get registered custom easing function.");

    m.def("show_unified_inspector",
        [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
        {
            auto iam_show_unified_inspector_adapt_modifiable_immutable_to_return = [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
            {
                bool * p_open_adapt_modifiable = nullptr;
                if (p_open.has_value())
                    p_open_adapt_modifiable = & (*p_open);

                iam_show_unified_inspector(p_open_adapt_modifiable);
                return p_open;
            };

            return iam_show_unified_inspector_adapt_modifiable_immutable_to_return(p_open);
        },
        nb::arg("p_open").none() = nb::none(),
        "Show unified inspector (merges debug window + animation inspector).");

    m.def("show_debug_timeline",
        iam_show_debug_timeline,
        nb::arg("instance_id"),
        "Show debug timeline for a clip instance.");


    auto pyEnumwave_type =
        nb::enum_<iam_wave_type>(m, "wave_type", nb::is_arithmetic(), "Oscillators - continuous periodic animations")
            .value("wave_sine", iam_wave_sine, "Smooth sine wave")
            .value("wave_triangle", iam_wave_triangle, "Triangle wave (linear up/down)")
            .value("wave_sawtooth", iam_wave_sawtooth, "Sawtooth wave (linear up, instant reset)")
            .value("wave_square", iam_wave_square, "Square wave (on/off pulse)");


    m.def("oscillate",
        iam_oscillate,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "Returns oscillating value [-amplitude, +amplitude].");

    m.def("oscillate_int",
        iam_oscillate_int,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "Returns oscillating integer value [-amplitude, +amplitude].");

    m.def("oscillate_vec2",
        iam_oscillate_vec2,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "2D oscillation.");

    m.def("oscillate_vec4",
        iam_oscillate_vec4,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("dt"),
        "4D oscillation.");

    m.def("oscillate_color",
        iam_oscillate_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("wave_type"), nb::arg("phase"), nb::arg("color_space"), nb::arg("dt"),
        "Color oscillation in specified color space.");

    m.def("shake",
        iam_shake,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "Decaying random shake. Returns offset that decays to 0.");

    m.def("shake_int",
        iam_shake_int,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "Decaying random shake for integers.");

    m.def("shake_vec2",
        iam_shake_vec2,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "2D decaying shake.");

    m.def("shake_vec4",
        iam_shake_vec4,
        nb::arg("id"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("dt"),
        "4D decaying shake.");

    m.def("shake_color",
        iam_shake_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("intensity"), nb::arg("frequency"), nb::arg("decay_time"), nb::arg("color_space"), nb::arg("dt"),
        "Color shake in specified color space.");

    m.def("wiggle",
        iam_wiggle,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "Continuous smooth random movement.");

    m.def("wiggle_int",
        iam_wiggle_int,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "Continuous smooth random movement for integers.");

    m.def("wiggle_vec2",
        iam_wiggle_vec2,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "2D continuous wiggle.");

    m.def("wiggle_vec4",
        iam_wiggle_vec4,
        nb::arg("id"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("dt"),
        "4D continuous wiggle.");

    m.def("wiggle_color",
        iam_wiggle_color,
        nb::arg("id"), nb::arg("base_color"), nb::arg("amplitude"), nb::arg("frequency"), nb::arg("color_space"), nb::arg("dt"),
        "Color wiggle in specified color space.");

    m.def("trigger_shake",
        iam_trigger_shake,
        nb::arg("id"),
        "Trigger/restart a shake animation.");

    m.def("eval_preset",
        iam_eval_preset,
        nb::arg("type"), nb::arg("t"),
        "Evaluate a preset easing function at time t (0-1).");

    m.def("tween_float",
        iam_tween_float,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value") = 0.0f,
        "Animate a float value.");

    m.def("tween_vec2",
        [](ImGuiID id, ImGuiID channel_id, ImVec2 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec2> & init_value = std::nullopt) -> ImVec2
        {
            auto iam_tween_vec2_adapt_mutable_param_with_default_value = [](ImGuiID id, ImGuiID channel_id, ImVec2 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec2> & init_value = std::nullopt) -> ImVec2
            {

                const ImVec2& init_value_or_default = [&]() -> const ImVec2 {
                    if (init_value.has_value())
                        return init_value.value();
                    else
                        return ImVec2(0, 0);
                }();

                auto lambda_result = iam_tween_vec2(id, channel_id, target, dur, ez, policy, dt, init_value_or_default);
                return lambda_result;
            };

            return iam_tween_vec2_adapt_mutable_param_with_default_value(id, channel_id, target, dur, ez, policy, dt, init_value);
        },
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value").none() = nb::none(),
        "Python bindings defaults:\n    If init_value is None, then its default value will be: ImVec2(0, 0)\n\n Animate a 2D vector.");

    m.def("tween_vec4",
        [](ImGuiID id, ImGuiID channel_id, ImVec4 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
        {
            auto iam_tween_vec4_adapt_mutable_param_with_default_value = [](ImGuiID id, ImGuiID channel_id, ImVec4 target, float dur, const iam_ease_desc & ez, int policy, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
            {

                const ImVec4& init_value_or_default = [&]() -> const ImVec4 {
                    if (init_value.has_value())
                        return init_value.value();
                    else
                        return ImVec4(0, 0, 0, 0);
                }();

                auto lambda_result = iam_tween_vec4(id, channel_id, target, dur, ez, policy, dt, init_value_or_default);
                return lambda_result;
            };

            return iam_tween_vec4_adapt_mutable_param_with_default_value(id, channel_id, target, dur, ez, policy, dt, init_value);
        },
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value").none() = nb::none(),
        "Python bindings defaults:\n    If init_value is None, then its default value will be: ImVec4(0, 0, 0, 0)\n\n Animate a 4D vector.");

    m.def("tween_int",
        iam_tween_int,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("dt"), nb::arg("init_value") = 0,
        "Animate an integer value.");

    m.def("tween_color",
        [](ImGuiID id, ImGuiID channel_id, ImVec4 target_srgb, float dur, const iam_ease_desc & ez, int policy, int color_space, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
        {
            auto iam_tween_color_adapt_mutable_param_with_default_value = [](ImGuiID id, ImGuiID channel_id, ImVec4 target_srgb, float dur, const iam_ease_desc & ez, int policy, int color_space, float dt, const std::optional<const ImVec4> & init_value = std::nullopt) -> ImVec4
            {

                const ImVec4& init_value_or_default = [&]() -> const ImVec4 {
                    if (init_value.has_value())
                        return init_value.value();
                    else
                        return ImVec4(1, 1, 1, 1);
                }();

                auto lambda_result = iam_tween_color(id, channel_id, target_srgb, dur, ez, policy, color_space, dt, init_value_or_default);
                return lambda_result;
            };

            return iam_tween_color_adapt_mutable_param_with_default_value(id, channel_id, target_srgb, dur, ez, policy, color_space, dt, init_value);
        },
        nb::arg("id"), nb::arg("channel_id"), nb::arg("target_srgb"), nb::arg("dur"), nb::arg("ez"), nb::arg("policy"), nb::arg("color_space"), nb::arg("dt"), nb::arg("init_value").none() = nb::none(),
        "Python bindings defaults:\n    If init_value is None, then its default value will be: ImVec4(1, 1, 1, 1)\n\n Animate a color in specified color space.");

    m.def("rebase_float",
        iam_rebase_float,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect float animation to new target.");

    m.def("rebase_vec2",
        iam_rebase_vec2,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect vec2 animation to new target.");

    m.def("rebase_vec4",
        iam_rebase_vec4,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect vec4 animation to new target.");

    m.def("rebase_color",
        iam_rebase_color,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect color animation to new target.");

    m.def("rebase_int",
        iam_rebase_int,
        nb::arg("id"), nb::arg("channel_id"), nb::arg("new_target"), nb::arg("dt"),
        "Smoothly redirect int animation to new target.");

    m.def("get_blended_color",
        [](ImVec4 a_srgb, ImVec4 b_srgb, float t, int color_space) -> ImVec4
        {
            auto iam_get_blended_color_adapt_force_lambda = [](ImVec4 a_srgb, ImVec4 b_srgb, float t, int color_space) -> ImVec4
            {
                auto lambda_result = iam_get_blended_color(a_srgb, b_srgb, t, color_space);
                return lambda_result;
            };

            return iam_get_blended_color_adapt_force_lambda(a_srgb, b_srgb, t, color_space);
        },
        nb::arg("a_srgb"), nb::arg("b_srgb"), nb::arg("t"), nb::arg("color_space"),
        "Blend two sRGB colors in specified color space.");

    m.def("ease_preset",
        iam_ease_preset,
        nb::arg("type"),
        "Create descriptor from preset enum.");

    m.def("ease_bezier",
        iam_ease_bezier,
        nb::arg("x1"), nb::arg("y1"), nb::arg("x2"), nb::arg("y2"),
        "Create cubic bezier easing.");

    m.def("ease_steps_desc",
        iam_ease_steps_desc,
        nb::arg("steps"), nb::arg("mode"),
        "Create step function easing.");

    m.def("ease_back",
        iam_ease_back,
        nb::arg("overshoot"),
        "Create back easing with overshoot.");

    m.def("ease_elastic",
        iam_ease_elastic,
        nb::arg("amplitude"), nb::arg("period"),
        "Create elastic easing.");

    m.def("ease_spring_desc",
        iam_ease_spring_desc,
        nb::arg("mass"), nb::arg("stiffness"), nb::arg("damping"), nb::arg("v0"),
        "Create physics spring.");

    m.def("ease_custom_fn",
        iam_ease_custom_fn,
        nb::arg("slot"),
        "Use registered custom easing (slot 0-15).");

    m.def("scroll_to_y",
        [](float target_y, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_y_adapt_mutable_param_with_default_value = [](float target_y, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_y(target_y, duration, ez_or_default);
            };

            iam_scroll_to_y_adapt_mutable_param_with_default_value(target_y, duration, ez);
        },
        nb::arg("target_y"), nb::arg("duration"), nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll current window to Y position.");

    m.def("scroll_to_x",
        [](float target_x, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_x_adapt_mutable_param_with_default_value = [](float target_x, float duration, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_x(target_x, duration, ez_or_default);
            };

            iam_scroll_to_x_adapt_mutable_param_with_default_value(target_x, duration, ez);
        },
        nb::arg("target_x"), nb::arg("duration"), nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll current window to X position.");

    m.def("scroll_to_top",
        [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_top_adapt_mutable_param_with_default_value = [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_top(duration, ez_or_default);
            };

            iam_scroll_to_top_adapt_mutable_param_with_default_value(duration, ez);
        },
        nb::arg("duration") = 0.3f, nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll to top of window.");

    m.def("scroll_to_bottom",
        [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
        {
            auto iam_scroll_to_bottom_adapt_mutable_param_with_default_value = [](float duration = 0.3f, const std::optional<const iam_ease_desc> & ez = std::nullopt)
            {

                const iam_ease_desc& ez_or_default = [&]() -> const iam_ease_desc {
                    if (ez.has_value())
                        return ez.value();
                    else
                        return iam_ease_preset(iam_ease_out_cubic);
                }();

                iam_scroll_to_bottom(duration, ez_or_default);
            };

            iam_scroll_to_bottom_adapt_mutable_param_with_default_value(duration, ez);
        },
        nb::arg("duration") = 0.3f, nb::arg("ez").none() = nb::none(),
        "Python bindings defaults:\n    If ez is None, then its default value will be: ease_preset(iam_ease_out_cubic)\n\n Scroll to bottom of window.");


    auto pyEnumdirection =
        nb::enum_<iam_direction>(m, "direction", nb::is_arithmetic(), "Direction for looping animations")
            .value("dir_normal", iam_dir_normal, "play forward")
            .value("dir_reverse", iam_dir_reverse, "play backward")
            .value("dir_alternate", iam_dir_alternate, "ping-pong");


    auto pyEnumchannel_type =
        nb::enum_<iam_channel_type>(m, "channel_type", nb::is_arithmetic(), "Channel types for keyframes")
            .value("chan_float", iam_chan_float, "")
            .value("chan_vec2", iam_chan_vec2, "")
            .value("chan_vec4", iam_chan_vec4, "")
            .value("chan_int", iam_chan_int, "")
            .value("chan_color", iam_chan_color, "Color with color space (stores in vec4 + color_space metadata)")
            .value("chan_float_rel", iam_chan_float_rel, "Float relative to anchor (percent + px_bias)")
            .value("chan_vec2_rel", iam_chan_vec2_rel, "Vec2 relative to anchor (percent.xy + px_bias.xy)")
            .value("chan_vec4_rel", iam_chan_vec4_rel, "Vec4 relative to anchor (percent.xy + px_bias.xy for x,y; z,w absolute)")
            .value("chan_color_rel", iam_chan_color_rel, "Color relative to anchor (for position-based color effects)");


    auto pyEnumresult =
        nb::enum_<iam_result>(m, "result", nb::is_arithmetic(), "Result codes")
            .value("ok", iam_ok, "")
            .value("err_not_found", iam_err_not_found, "")
            .value("err_bad_arg", iam_err_bad_arg, "")
            .value("err_no_mem", iam_err_no_mem, "");


    auto pyClassiam_spring_params =
        nb::class_<iam_spring_params>
            (m, "spring_params", "Spring parameters for physics-based animation")
        .def("__init__", [](iam_spring_params * self, float mass = float(), float stiffness = float(), float damping = float(), float initial_velocity = float())
        {
            new (self) iam_spring_params();  // placement new
            auto r_ctor_ = self;
            r_ctor_->mass = mass;
            r_ctor_->stiffness = stiffness;
            r_ctor_->damping = damping;
            r_ctor_->initial_velocity = initial_velocity;
        },
        nb::arg("mass") = float(), nb::arg("stiffness") = float(), nb::arg("damping") = float(), nb::arg("initial_velocity") = float()
        )
        .def_rw("mass", &iam_spring_params::mass, "")
        .def_rw("stiffness", &iam_spring_params::stiffness, "")
        .def_rw("damping", &iam_spring_params::damping, "")
        .def_rw("initial_velocity", &iam_spring_params::initial_velocity, "")
        ;
    // #ifdef IMGUI_BUNDLE_PYTHON_API
    //
    // #else
    //
    // #endif
    //


    auto pyClassiam_clip =
        nb::class_<iam_clip>
            (m, "clip", " ----------------------------------------------------\n iam_clip - fluent API for authoring animations\n ----------------------------------------------------")
        .def_static("begin",
            &iam_clip::begin,
            nb::arg("clip_id"),
            "Start building a new clip with the given ID")
        .def("key_float",
            [](iam_clip & self, ImGuiID channel, float time, float value, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
            {
                auto key_float_adapt_exclude_params = [&self](ImGuiID channel, float time, float value, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
                {
                    auto& lambda_result = self.key_float(channel, time, value, ease_type, nullptr);
                    return lambda_result;
                };

                return key_float_adapt_exclude_params(channel, time, value, ease_type);
            },     nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear)
        .def("key_vec2",
            [](iam_clip & self, ImGuiID channel, float time, ImVec2 value, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
            {
                auto key_vec2_adapt_exclude_params = [&self](ImGuiID channel, float time, ImVec2 value, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
                {
                    auto& lambda_result = self.key_vec2(channel, time, value, ease_type, nullptr);
                    return lambda_result;
                };

                return key_vec2_adapt_exclude_params(channel, time, value, ease_type);
            },     nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear)
        .def("key_vec4",
            [](iam_clip & self, ImGuiID channel, float time, ImVec4 value, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
            {
                auto key_vec4_adapt_exclude_params = [&self](ImGuiID channel, float time, ImVec4 value, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
                {
                    auto& lambda_result = self.key_vec4(channel, time, value, ease_type, nullptr);
                    return lambda_result;
                };

                return key_vec4_adapt_exclude_params(channel, time, value, ease_type);
            },     nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear)
        .def("key_int",
            &iam_clip::key_int, nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("ease_type") = iam_ease_type::iam_ease_linear)
        .def("key_color",
            [](iam_clip & self, ImGuiID channel, float time, ImVec4 value, int color_space = iam_color_space::iam_col_oklab, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
            {
                auto key_color_adapt_exclude_params = [&self](ImGuiID channel, float time, ImVec4 value, int color_space = iam_color_space::iam_col_oklab, int ease_type = iam_ease_type::iam_ease_linear) -> iam_clip &
                {
                    auto& lambda_result = self.key_color(channel, time, value, color_space, ease_type, nullptr);
                    return lambda_result;
                };

                return key_color_adapt_exclude_params(channel, time, value, color_space, ease_type);
            },     nb::arg("channel"), nb::arg("time"), nb::arg("value"), nb::arg("color_space") = iam_color_space::iam_col_oklab, nb::arg("ease_type") = iam_ease_type::iam_ease_linear)
        .def("marker",
            [](iam_clip & self, float time, ImGuiID marker_id, iam_marker_callback cb) -> iam_clip &
            {
                auto marker_adapt_exclude_params = [&self](float time, ImGuiID marker_id, iam_marker_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.marker(time, marker_id, cb, nullptr);
                    return lambda_result;
                };

                return marker_adapt_exclude_params(time, marker_id, cb);
            },
            nb::arg("time"), nb::arg("marker_id"), nb::arg("cb"),
            "Add marker at specific time.")
        .def("marker",
            [](iam_clip & self, float time, iam_marker_callback cb) -> iam_clip &
            {
                auto marker_adapt_exclude_params = [&self](float time, iam_marker_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.marker(time, cb, nullptr);
                    return lambda_result;
                };

                return marker_adapt_exclude_params(time, cb);
            },
            nb::arg("time"), nb::arg("cb"),
            "Add marker (auto-generated ID).")
        .def("set_loop",
            &iam_clip::set_loop, nb::arg("loop"), nb::arg("direction") = iam_direction::iam_dir_normal, nb::arg("loop_count") = -1)
        .def("set_delay",
            &iam_clip::set_delay, nb::arg("delay_seconds"))
        .def("set_stagger",
            &iam_clip::set_stagger, nb::arg("count"), nb::arg("each_delay"), nb::arg("from_center_bias") = 0.0f)
        .def("on_begin",
            [](iam_clip & self, iam_clip_callback cb) -> iam_clip &
            {
                auto on_begin_adapt_exclude_params = [&self](iam_clip_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.on_begin(cb, nullptr);
                    return lambda_result;
                };

                return on_begin_adapt_exclude_params(cb);
            },     nb::arg("cb"))
        .def("on_update",
            [](iam_clip & self, iam_clip_callback cb) -> iam_clip &
            {
                auto on_update_adapt_exclude_params = [&self](iam_clip_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.on_update(cb, nullptr);
                    return lambda_result;
                };

                return on_update_adapt_exclude_params(cb);
            },     nb::arg("cb"))
        .def("on_complete",
            [](iam_clip & self, iam_clip_callback cb) -> iam_clip &
            {
                auto on_complete_adapt_exclude_params = [&self](iam_clip_callback cb) -> iam_clip &
                {
                    auto& lambda_result = self.on_complete(cb, nullptr);
                    return lambda_result;
                };

                return on_complete_adapt_exclude_params(cb);
            },     nb::arg("cb"))
        .def("end",
            &iam_clip::end, "Finalize the clip")
        .def("id",
            &iam_clip::id, "Get the clip ID")
        ;


    auto pyClassiam_instance =
        nb::class_<iam_instance>
            (m, "instance", " ----------------------------------------------------\n iam_instance - playback control for a clip\n ----------------------------------------------------")
        .def(nb::init<>())
        .def(nb::init<ImGuiID>(),
            nb::arg("inst_id"))
        .def("pause",
            &iam_instance::pause)
        .def("resume",
            &iam_instance::resume)
        .def("stop",
            &iam_instance::stop)
        .def("destroy",
            &iam_instance::destroy, "Remove instance from system (valid() will return False after this)")
        .def("seek",
            &iam_instance::seek, nb::arg("time"))
        .def("set_time_scale",
            &iam_instance::set_time_scale, nb::arg("scale"))
        .def("set_weight",
            &iam_instance::set_weight,
            nb::arg("weight"),
            "for layering/blending")
        .def("then",
            nb::overload_cast<ImGuiID>(&iam_instance::then),
            nb::arg("next_clip_id"),
            "Chain another clip to play after this one.")
        .def("then",
            nb::overload_cast<ImGuiID, ImGuiID>(&iam_instance::then),
            nb::arg("next_clip_id"), nb::arg("next_instance_id"),
            "Chain with specific instance ID.")
        .def("then_delay",
            &iam_instance::then_delay,
            nb::arg("delay"),
            "Set delay before chained clip starts.")
        .def("time",
            &iam_instance::time)
        .def("duration",
            &iam_instance::duration)
        .def("is_playing",
            &iam_instance::is_playing)
        .def("is_paused",
            &iam_instance::is_paused)
        // #ifdef IMGUI_BUNDLE_PYTHON_API
        //
        .def("get_float",
            [](const iam_instance & self, ImGuiID channel) -> std::pair<bool, float>
            {
                auto get_float_adapt_force_lambda = [&self](ImGuiID channel) -> std::pair<bool, float>
                {
                    auto lambda_result = self.get_float(channel);
                    return lambda_result;
                };

                return get_float_adapt_force_lambda(channel);
            },     nb::arg("channel"))
        .def("get_vec2",
            [](const iam_instance & self, ImGuiID channel) -> std::pair<bool, ImVec2>
            {
                auto get_vec2_adapt_force_lambda = [&self](ImGuiID channel) -> std::pair<bool, ImVec2>
                {
                    auto lambda_result = self.get_vec2(channel);
                    return lambda_result;
                };

                return get_vec2_adapt_force_lambda(channel);
            },     nb::arg("channel"))
        .def("get_vec4",
            [](const iam_instance & self, ImGuiID channel) -> std::pair<bool, ImVec4>
            {
                auto get_vec4_adapt_force_lambda = [&self](ImGuiID channel) -> std::pair<bool, ImVec4>
                {
                    auto lambda_result = self.get_vec4(channel);
                    return lambda_result;
                };

                return get_vec4_adapt_force_lambda(channel);
            },     nb::arg("channel"))
        .def("get_int",
            [](const iam_instance & self, ImGuiID channel) -> std::pair<bool, int>
            {
                auto get_int_adapt_force_lambda = [&self](ImGuiID channel) -> std::pair<bool, int>
                {
                    auto lambda_result = self.get_int(channel);
                    return lambda_result;
                };

                return get_int_adapt_force_lambda(channel);
            },     nb::arg("channel"))
        .def("get_color",
            [](const iam_instance & self, ImGuiID channel, int color_space = iam_color_space::iam_col_oklab) -> std::pair<bool, ImVec4>
            {
                auto get_color_adapt_force_lambda = [&self](ImGuiID channel, int color_space = iam_color_space::iam_col_oklab) -> std::pair<bool, ImVec4>
                {
                    auto lambda_result = self.get_color(channel, color_space);
                    return lambda_result;
                };

                return get_color_adapt_force_lambda(channel, color_space);
            },     nb::arg("channel"), nb::arg("color_space") = iam_color_space::iam_col_oklab)
        // #endif
        //
        .def("valid",
            &iam_instance::valid, "Check validity")
        .def("__bool__",
            &iam_instance::operator bool)
        .def("id",
            &iam_instance::id)
        ;


    m.def("clip_init",
        iam_clip_init, nb::arg("initial_clip_cap") = 256, nb::arg("initial_inst_cap") = 4096);

    m.def("clip_shutdown",
        iam_clip_shutdown);

    m.def("clip_update",
        iam_clip_update,
        nb::arg("dt"),
        "Per-frame update (call after iam_update_begin_frame)");

    m.def("clip_gc",
        iam_clip_gc,
        nb::arg("max_age_frames") = 600,
        "Garbage collection for instances");

    m.def("play",
        iam_play,
        nb::arg("clip_id"), nb::arg("instance_id"),
        "Play a clip on an instance (creates or reuses instance)");

    m.def("get_instance",
        [](ImGuiID instance_id) -> iam_instance
        {
            auto iam_get_instance_adapt_force_lambda = [](ImGuiID instance_id) -> iam_instance
            {
                auto lambda_result = iam_get_instance(instance_id);
                return lambda_result;
            };

            return iam_get_instance_adapt_force_lambda(instance_id);
        },
        nb::arg("instance_id"),
        "Get an existing instance (returns invalid iam_instance if not found)");

    m.def("clip_duration",
        iam_clip_duration,
        nb::arg("clip_id"),
        "Get clip duration in seconds.");

    m.def("clip_exists",
        iam_clip_exists,
        nb::arg("clip_id"),
        "Check if clip exists.");

    m.def("stagger_delay",
        iam_stagger_delay,
        nb::arg("clip_id"), nb::arg("index"),
        "Get stagger delay for element at index.");

    m.def("play_stagger",
        iam_play_stagger,
        nb::arg("clip_id"), nb::arg("instance_id"), nb::arg("index"),
        "Play with stagger delay applied.");

    m.def("demo_basics_window",
        ImAnimDemoBasicsWindow, nb::arg("create_window") = true);
    ////////////////////    </generated_from:im_anim.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
#endif // #ifdef IMGUI_BUNDLE_WITH_IMANIM
