// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2024 Pascal Thomet - https://github.com/pthom/imgui_bundle
#ifdef IMGUI_BUNDLE_WITH_IMPLOT3D
#include <nanobind/nanobind.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/stl/optional.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>

#include "imgui.h"
#include "implot3d/implot3d.h"
#include "implot3d/implot3d_internal.h"


namespace nb = nanobind;



void implot3d_binding_manual(nb::module_& m);

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

void py_init_module_implot3d(nb::module_& m)
{
    using UInt = unsigned int;

    m.attr("IMPLOT3D_AUTO") = -1.f;
    m.attr("AUTO") = -1.f;
    m.attr("IMPLOT3D_AUTO_COL") = ImVec4(0.f, 0.f, 0.f, -1.f);
    m.attr("AUTO_COL") = ImVec4(0.f, 0.f, 0.f, -1.f);

    m.attr("VERSION") = IMPLOT3D_VERSION;

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:implot3d.h>    ////////////////////
    // #ifndef IMGUI_DISABLE
    //
    // #ifdef IMGUI_BUNDLE_PYTHON_API
    //
    // #endif
    //


    auto pyEnumProp_ =
        nb::enum_<ImPlot3DProp_>(m, "Prop_", nb::is_arithmetic(), nb::is_flag(), "Plotting properties. These provide syntactic sugar for creating ImPlot3DSpec from (ImPlot3DProp,value) pairs")
            .value("line_color", ImPlot3DProp_LineColor, "Line color; IMPLOT3D_AUTO_COL will use next Colormap color")
            .value("line_weight", ImPlot3DProp_LineWeight, "Line weight in pixels")
            .value("fill_color", ImPlot3DProp_FillColor, "Fill color (applies to shaded regions); IMPLOT3D_AUTO_COL will use next Colormap color")
            .value("fill_alpha", ImPlot3DProp_FillAlpha, "Alpha multiplier (applies to FillColor and MarkerFillColor)")
            .value("marker", ImPlot3DProp_Marker, "Marker type")
            .value("marker_size", ImPlot3DProp_MarkerSize, "Size of markers (radius) *in pixels*")
            .value("marker_line_color", ImPlot3DProp_MarkerLineColor, "Marker outline color; IMPLOT3D_AUTO_COL will use next LineColor")
            .value("marker_fill_color", ImPlot3DProp_MarkerFillColor, "Marker fill color; IMPLOT3D_AUTO_COL will use LineColor")
            .value("offset", ImPlot3DProp_Offset, "Data index offset")
            .value("stride", ImPlot3DProp_Stride, "Data stride in bytes; IMPLOT3D_AUTO will result in sizeof(T) where T is the type passed to PlotX")
            .value("flags", ImPlot3DProp_Flags, "Optional item flags; can be composed from common ImPlot3DItemFlags and/or specialized ImPlot3DXFlags");


    auto pyEnumFlags_ =
        nb::enum_<ImPlot3DFlags_>(m, "Flags_", nb::is_arithmetic(), nb::is_flag(), "Flags for ImPlot3D::BeginPlot()")
            .value("none", ImPlot3DFlags_None, "Default")
            .value("no_title", ImPlot3DFlags_NoTitle, "Hide plot title")
            .value("no_legend", ImPlot3DFlags_NoLegend, "Hide plot legend")
            .value("no_mouse_text", ImPlot3DFlags_NoMouseText, "Hide mouse position in plot coordinates")
            .value("no_clip", ImPlot3DFlags_NoClip, "Disable 3D box clipping")
            .value("no_menus", ImPlot3DFlags_NoMenus, "The user will not be able to open context menus")
            .value("equal", ImPlot3DFlags_Equal, "X, Y, and Z axes will be constrained to have the same units/pixel")
            .value("no_rotate", ImPlot3DFlags_NoRotate, "Lock rotation interaction")
            .value("no_pan", ImPlot3DFlags_NoPan, "Lock panning/translation interaction")
            .value("no_zoom", ImPlot3DFlags_NoZoom, "Lock zoom interaction")
            .value("no_inputs", ImPlot3DFlags_NoInputs, "Disable all user inputs")
            .value("canvas_only", ImPlot3DFlags_CanvasOnly, "");


    auto pyEnumCond_ =
        nb::enum_<ImPlot3DCond_>(m, "Cond_", nb::is_arithmetic(), nb::is_flag(), "Represents a condition for SetupAxisLimits etc. (same as ImGuiCond, but we only support a subset of those enums)")
            .value("none", ImPlot3DCond_None, "No condition (always set the variable), same as _Always")
            .value("always", ImPlot3DCond_Always, "No condition (always set the variable)")
            .value("once", ImPlot3DCond_Once, "Set the variable once per runtime session (only the first call will succeed)");


    auto pyEnumCol_ =
        nb::enum_<ImPlot3DCol_>(m, "Col_", nb::is_arithmetic(), nb::is_flag(), "")
            .value("title_text", ImPlot3DCol_TitleText, "Title color")
            .value("inlay_text", ImPlot3DCol_InlayText, "Color for texts appearing inside of plots")
            .value("frame_bg", ImPlot3DCol_FrameBg, "Frame background color")
            .value("plot_bg", ImPlot3DCol_PlotBg, "Plot area background color")
            .value("plot_border", ImPlot3DCol_PlotBorder, "Plot area border color")
            .value("legend_bg", ImPlot3DCol_LegendBg, "Legend background color")
            .value("legend_border", ImPlot3DCol_LegendBorder, "Legend border color")
            .value("legend_text", ImPlot3DCol_LegendText, "Legend text color")
            .value("axis_text", ImPlot3DCol_AxisText, "Axis label and tick lables color")
            .value("axis_grid", ImPlot3DCol_AxisGrid, "Axis grid color")
            .value("axis_tick", ImPlot3DCol_AxisTick, "Axis tick color (defaults to AxisGrid)")
            .value("count", ImPlot3DCol_COUNT, "");


    auto pyEnumStyleVar_ =
        nb::enum_<ImPlot3DStyleVar_>(m, "StyleVar_", nb::is_arithmetic(), nb::is_flag(), "Plot styling variables")
            .value("line_weight", ImPlot3DStyleVar_LineWeight, "float, plot item line weight in pixels")
            .value("marker", ImPlot3DStyleVar_Marker, "int,   marker specification")
            .value("marker_size", ImPlot3DStyleVar_MarkerSize, "float, marker size in pixels (roughly the marker's \"radius\")")
            .value("fill_alpha", ImPlot3DStyleVar_FillAlpha, "float, alpha modifier applied to all plot item fills")
            .value("plot_default_size", ImPlot3DStyleVar_PlotDefaultSize, "ImVec2, default size used when ImVec2(0,0) is passed to BeginPlot")
            .value("plot_min_size", ImPlot3DStyleVar_PlotMinSize, "ImVec2, minimum size plot frame can be when shrunk")
            .value("plot_padding", ImPlot3DStyleVar_PlotPadding, "ImVec2, padding between widget frame and plot area, labels, or outside legends (i.e. main padding)")
            .value("label_padding", ImPlot3DStyleVar_LabelPadding, "ImVec2, padding between axes labels, tick labels, and plot edge")
            .value("view_scale_factor", ImPlot3DStyleVar_ViewScaleFactor, "float, scale factor for 3D view, you can use it to make the whole plot larger or smaller")
            .value("legend_padding", ImPlot3DStyleVar_LegendPadding, "ImVec2, legend padding from plot edges")
            .value("legend_inner_padding", ImPlot3DStyleVar_LegendInnerPadding, "ImVec2, legend inner padding from legend edges")
            .value("legend_spacing", ImPlot3DStyleVar_LegendSpacing, "ImVec2, spacing between legend entries")
            .value("count", ImPlot3DStyleVar_COUNT, "");


    auto pyEnumMarker_ =
        nb::enum_<ImPlot3DMarker_>(m, "Marker_", nb::is_arithmetic(), nb::is_flag(), "")
            .value("none", ImPlot3DMarker_None, "No marker")
            .value("auto", ImPlot3DMarker_Auto, "Automatic marker selection")
            .value("circle", ImPlot3DMarker_Circle, "Circle marker (default)")
            .value("square", ImPlot3DMarker_Square, "Square maker")
            .value("diamond", ImPlot3DMarker_Diamond, "Diamond marker")
            .value("up", ImPlot3DMarker_Up, "Upward-pointing triangle marker")
            .value("down", ImPlot3DMarker_Down, "Downward-pointing triangle marker")
            .value("left", ImPlot3DMarker_Left, "Leftward-pointing triangle marker")
            .value("right", ImPlot3DMarker_Right, "Rightward-pointing triangle marker")
            .value("cross", ImPlot3DMarker_Cross, "Cross marker (not fillable)")
            .value("plus", ImPlot3DMarker_Plus, "Plus marker (not fillable)")
            .value("asterisk", ImPlot3DMarker_Asterisk, "Asterisk marker (not fillable)")
            .value("count", ImPlot3DMarker_COUNT, "");


    auto pyEnumItemFlags_ =
        nb::enum_<ImPlot3DItemFlags_>(m, "ItemFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for items")
            .value("none", ImPlot3DItemFlags_None, "Default")
            .value("no_legend", ImPlot3DItemFlags_NoLegend, "The item won't have a legend entry displayed")
            .value("no_fit", ImPlot3DItemFlags_NoFit, "The item won't be considered for plot fits");


    auto pyEnumScatterFlags_ =
        nb::enum_<ImPlot3DScatterFlags_>(m, "ScatterFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotScatter")
            .value("none", ImPlot3DScatterFlags_None, "Default")
            .value("no_legend", ImPlot3DScatterFlags_NoLegend, "")
            .value("no_fit", ImPlot3DScatterFlags_NoFit, "");


    auto pyEnumLineFlags_ =
        nb::enum_<ImPlot3DLineFlags_>(m, "LineFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotLine")
            .value("none", ImPlot3DLineFlags_None, "Default")
            .value("no_legend", ImPlot3DLineFlags_NoLegend, "")
            .value("no_fit", ImPlot3DLineFlags_NoFit, "")
            .value("segments", ImPlot3DLineFlags_Segments, "A line segment will be rendered from every two consecutive points")
            .value("loop", ImPlot3DLineFlags_Loop, "The last and first point will be connected to form a closed loop")
            .value("skip_nan", ImPlot3DLineFlags_SkipNaN, "NaNs values will be skipped instead of rendered as missing data");


    auto pyEnumTriangleFlags_ =
        nb::enum_<ImPlot3DTriangleFlags_>(m, "TriangleFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotTriangle")
            .value("none", ImPlot3DTriangleFlags_None, "Default")
            .value("no_legend", ImPlot3DTriangleFlags_NoLegend, "")
            .value("no_fit", ImPlot3DTriangleFlags_NoFit, "")
            .value("no_lines", ImPlot3DTriangleFlags_NoLines, "No lines will be rendered")
            .value("no_fill", ImPlot3DTriangleFlags_NoFill, "No fill will be rendered")
            .value("no_markers", ImPlot3DTriangleFlags_NoMarkers, "No markers will be rendered");


    auto pyEnumQuadFlags_ =
        nb::enum_<ImPlot3DQuadFlags_>(m, "QuadFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotQuad")
            .value("none", ImPlot3DQuadFlags_None, "Default")
            .value("no_legend", ImPlot3DQuadFlags_NoLegend, "")
            .value("no_fit", ImPlot3DQuadFlags_NoFit, "")
            .value("no_lines", ImPlot3DQuadFlags_NoLines, "No lines will be rendered")
            .value("no_fill", ImPlot3DQuadFlags_NoFill, "No fill will be rendered")
            .value("no_markers", ImPlot3DQuadFlags_NoMarkers, "No markers will be rendered");


    auto pyEnumSurfaceFlags_ =
        nb::enum_<ImPlot3DSurfaceFlags_>(m, "SurfaceFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotSurface")
            .value("none", ImPlot3DSurfaceFlags_None, "Default")
            .value("no_legend", ImPlot3DSurfaceFlags_NoLegend, "")
            .value("no_fit", ImPlot3DSurfaceFlags_NoFit, "")
            .value("no_lines", ImPlot3DSurfaceFlags_NoLines, "No lines will be rendered")
            .value("no_fill", ImPlot3DSurfaceFlags_NoFill, "No fill will be rendered")
            .value("no_markers", ImPlot3DSurfaceFlags_NoMarkers, "No markers will be rendered");


    auto pyEnumMeshFlags_ =
        nb::enum_<ImPlot3DMeshFlags_>(m, "MeshFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotMesh")
            .value("none", ImPlot3DMeshFlags_None, "Default")
            .value("no_legend", ImPlot3DMeshFlags_NoLegend, "")
            .value("no_fit", ImPlot3DMeshFlags_NoFit, "")
            .value("no_lines", ImPlot3DMeshFlags_NoLines, "No lines will be rendered")
            .value("no_fill", ImPlot3DMeshFlags_NoFill, "No fill will be rendered")
            .value("no_markers", ImPlot3DMeshFlags_NoMarkers, "No markers will be rendered");


    auto pyEnumImageFlags_ =
        nb::enum_<ImPlot3DImageFlags_>(m, "ImageFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotImage")
            .value("none", ImPlot3DImageFlags_None, "Default")
            .value("no_legend", ImPlot3DImageFlags_NoLegend, "")
            .value("no_fit", ImPlot3DImageFlags_NoFit, "");


    auto pyEnumDummyFlags_ =
        nb::enum_<ImPlot3DDummyFlags_>(m, "DummyFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for PlotDummy")
            .value("none", ImPlot3DDummyFlags_None, "Default");


    auto pyEnumLegendFlags_ =
        nb::enum_<ImPlot3DLegendFlags_>(m, "LegendFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for legends")
            .value("none", ImPlot3DLegendFlags_None, "Default")
            .value("no_buttons", ImPlot3DLegendFlags_NoButtons, "Legend icons will not function as hide/show buttons")
            .value("no_highlight_item", ImPlot3DLegendFlags_NoHighlightItem, "Plot items will not be highlighted when their legend entry is hovered")
            .value("horizontal", ImPlot3DLegendFlags_Horizontal, "Legend entries will be displayed horizontally");


    auto pyEnumLocation_ =
        nb::enum_<ImPlot3DLocation_>(m, "Location_", nb::is_arithmetic(), nb::is_flag(), "Used to position legend on a plot")
            .value("center", ImPlot3DLocation_Center, "Center-center")
            .value("north", ImPlot3DLocation_North, "Top-center")
            .value("south", ImPlot3DLocation_South, "Bottom-center")
            .value("west", ImPlot3DLocation_West, "Center-left")
            .value("east", ImPlot3DLocation_East, "Center-right")
            .value("north_west", ImPlot3DLocation_NorthWest, "Top-left")
            .value("north_east", ImPlot3DLocation_NorthEast, "Top-right")
            .value("south_west", ImPlot3DLocation_SouthWest, "Bottom-left")
            .value("south_east", ImPlot3DLocation_SouthEast, "Bottom-right");


    auto pyEnumAxisFlags_ =
        nb::enum_<ImPlot3DAxisFlags_>(m, "AxisFlags_", nb::is_arithmetic(), nb::is_flag(), "Flags for axis")
            .value("none", ImPlot3DAxisFlags_None, "Default")
            .value("no_label", ImPlot3DAxisFlags_NoLabel, "No axis label will be displayed")
            .value("no_grid_lines", ImPlot3DAxisFlags_NoGridLines, "No grid lines will be displayed")
            .value("no_tick_marks", ImPlot3DAxisFlags_NoTickMarks, "No tick marks will be displayed")
            .value("no_tick_labels", ImPlot3DAxisFlags_NoTickLabels, "No tick labels will be displayed")
            .value("lock_min", ImPlot3DAxisFlags_LockMin, "The axis minimum value will be locked when panning/zooming")
            .value("lock_max", ImPlot3DAxisFlags_LockMax, "The axis maximum value will be locked when panning/zooming")
            .value("auto_fit", ImPlot3DAxisFlags_AutoFit, "Axis will be auto-fitting to data extents")
            .value("invert", ImPlot3DAxisFlags_Invert, "The axis will be inverted")
            .value("pan_stretch", ImPlot3DAxisFlags_PanStretch, "Panning in a locked or constrained state will cause the axis to stretch if possible")
            .value("lock", ImPlot3DAxisFlags_Lock, "")
            .value("no_decorations", ImPlot3DAxisFlags_NoDecorations, "");


    auto pyEnumImAxis3D_ =
        nb::enum_<ImAxis3D_>(m, "ImAxis3D_", nb::is_arithmetic(), nb::is_flag(), "Axis indices")
            .value("x", ImAxis3D_X, "X-axis")
            .value("y", ImAxis3D_Y, "Y-axis")
            .value("z", ImAxis3D_Z, "Z-axis")
            .value("count", ImAxis3D_COUNT, "");


    auto pyEnumImPlane3D_ =
        nb::enum_<ImPlane3D_>(m, "ImPlane3D_", nb::is_arithmetic(), nb::is_flag(), "Plane indices")
            .value("yz", ImPlane3D_YZ, "YZ plane (perpendicular to X-axis)")
            .value("xz", ImPlane3D_XZ, "XZ plane (perpendicular to Y-axis)")
            .value("xy", ImPlane3D_XY, "XY plane (perpendicular to Z-axis)")
            .value("count", ImPlane3D_COUNT, "");


    auto pyEnumScale_ =
        nb::enum_<ImPlot3DScale_>(m, "Scale_", nb::is_arithmetic(), nb::is_flag(), "Axis scale")
            .value("linear", ImPlot3DScale_Linear, "Default linear scale")
            .value("log10", ImPlot3DScale_Log10, "Base 10 log scale")
            .value("sym_log", ImPlot3DScale_SymLog, "Symmetric base 10 log scale");


    auto pyEnumColormap_ =
        nb::enum_<ImPlot3DColormap_>(m, "Colormap_", nb::is_arithmetic(), nb::is_flag(), "Colormaps")
            .value("deep", ImPlot3DColormap_Deep, "Same as seaborn \"deep\"")
            .value("dark", ImPlot3DColormap_Dark, "Same as matplotlib \"Set1\"")
            .value("pastel", ImPlot3DColormap_Pastel, "Same as matplotlib \"Pastel1\"")
            .value("paired", ImPlot3DColormap_Paired, "Same as matplotlib \"Paired\"")
            .value("viridis", ImPlot3DColormap_Viridis, "Same as matplotlib \"viridis\"")
            .value("plasma", ImPlot3DColormap_Plasma, "Same as matplotlib \"plasma\"")
            .value("hot", ImPlot3DColormap_Hot, "Same as matplotlib/MATLAB \"hot\"")
            .value("cool", ImPlot3DColormap_Cool, "Same as matplotlib/MATLAB \"cool\"")
            .value("pink", ImPlot3DColormap_Pink, "Same as matplotlib/MATLAB \"pink\"")
            .value("jet", ImPlot3DColormap_Jet, "Same as matplotlib/MATLAB \"jet\"")
            .value("twilight", ImPlot3DColormap_Twilight, "Same as matplotlib \"twilight\"")
            .value("rd_bu", ImPlot3DColormap_RdBu, "Same as matplotlib \"RdBu\"")
            .value("br_bg", ImPlot3DColormap_BrBG, "Same as matplotlib \"BrGB\"")
            .value("pi_yg", ImPlot3DColormap_PiYG, "Same as matplotlib \"PiYG\"")
            .value("spectral", ImPlot3DColormap_Spectral, "Same as matplotlib \"Spectral\"")
            .value("greys", ImPlot3DColormap_Greys, "White/black");


    auto pyClassImPlot3DSpec =
        nb::class_<ImPlot3DSpec>
            (m, "Spec", " Plot item styling specification. Provide these to PlotX functions to override styling, specify\n offsetting or stride, or set optional flags. This struct can be used in the following ways:\n\n 1. By declaring and defining a struct instance:\n\n    ImPlot3DSpec spec;\n    spec.LineColor = ImVec4(1,0,0,1);\n    spec.LineWeight = 2.0;\n    spec.Marker = ImPlot3DMarker_Circle;\n    spec.Flags = ImPlot3DItemFlags_NoLegend | ImPlot3DLineFlags_Segments;\n    ImPlot3D::PlotLine(\"MyLine\", xs, ys, zs, 100, spec);\n\n 2. Inline using ImPlot3DProp,value pairs (order does NOT matter):\n\n    ImPlot3D::PlotLine(\"MyLine\", xs, ys, zs, 100, {\n      ImPlot3DProp_LineColor, ImVec4(1,0,0,1),\n      ImPlot3DProp_LineWeight, 2.0,\n      ImPlot3DProp_Marker, ImPlot3DMarker_Circle,\n      ImPlot3DProp_Flags, ImPlot3DItemFlags_NoLegend | ImPlot3DLineFlags_Segments\n    });")
        .def("__init__", [](ImPlot3DSpec * self, const std::optional<const ImVec4> & LineColor = std::nullopt, float LineWeight = 1.0f, const std::optional<const ImVec4> & FillColor = std::nullopt, float FillAlpha = IMPLOT3D_AUTO, const std::optional<const ImPlot3DMarker> & Marker = std::nullopt, float MarkerSize = IMPLOT3D_AUTO, const std::optional<const ImVec4> & MarkerLineColor = std::nullopt, const std::optional<const ImVec4> & MarkerFillColor = std::nullopt, int Offset = 0, int Stride = IMPLOT3D_AUTO, ImPlot3DItemFlags Flags = ImPlot3DItemFlags_None)
        {
            new (self) ImPlot3DSpec();  // placement new
            auto r_ctor_ = self;
            if (LineColor.has_value())
                r_ctor_->LineColor = LineColor.value();
            else
                r_ctor_->LineColor = IMPLOT3D_AUTO_COL;
            r_ctor_->LineWeight = LineWeight;
            if (FillColor.has_value())
                r_ctor_->FillColor = FillColor.value();
            else
                r_ctor_->FillColor = IMPLOT3D_AUTO_COL;
            r_ctor_->FillAlpha = FillAlpha;
            if (Marker.has_value())
                r_ctor_->Marker = Marker.value();
            else
                r_ctor_->Marker = ImPlot3DMarker_Auto;
            r_ctor_->MarkerSize = MarkerSize;
            if (MarkerLineColor.has_value())
                r_ctor_->MarkerLineColor = MarkerLineColor.value();
            else
                r_ctor_->MarkerLineColor = IMPLOT3D_AUTO_COL;
            if (MarkerFillColor.has_value())
                r_ctor_->MarkerFillColor = MarkerFillColor.value();
            else
                r_ctor_->MarkerFillColor = IMPLOT3D_AUTO_COL;
            r_ctor_->Offset = Offset;
            r_ctor_->Stride = Stride;
            r_ctor_->Flags = Flags;
        },
        nb::arg("line_color").none() = nb::none(), nb::arg("line_weight") = 1.0f, nb::arg("fill_color").none() = nb::none(), nb::arg("fill_alpha") = IMPLOT3D_AUTO, nb::arg("marker").none() = nb::none(), nb::arg("marker_size") = IMPLOT3D_AUTO, nb::arg("marker_line_color").none() = nb::none(), nb::arg("marker_fill_color").none() = nb::none(), nb::arg("offset") = 0, nb::arg("stride") = IMPLOT3D_AUTO, nb::arg("flags") = ImPlot3DItemFlags_None
        )
        .def_rw("line_color", &ImPlot3DSpec::LineColor, "Line color; IMPLOT3D_AUTO_COL will use next Colormap color")
        .def_rw("line_weight", &ImPlot3DSpec::LineWeight, "Line weight in pixels")
        .def_rw("fill_color", &ImPlot3DSpec::FillColor, "Fill color (applies to shaded regions); IMPLOT3D_AUTO_COL will use next Colormap color")
        .def_rw("fill_alpha", &ImPlot3DSpec::FillAlpha, "Alpha multiplier (applies to FillColor and MarkerFillColor)")
        .def_rw("marker", &ImPlot3DSpec::Marker, "Marker type")
        .def_rw("marker_size", &ImPlot3DSpec::MarkerSize, "Size of markers (radius) *in pixels*")
        .def_rw("marker_line_color", &ImPlot3DSpec::MarkerLineColor, "Marker outline color; IMPLOT3D_AUTO_COL will use LineColor")
        .def_rw("marker_fill_color", &ImPlot3DSpec::MarkerFillColor, "Marker fill color; IMPLOT3D_AUTO_COL will use LineColor")
        .def_rw("offset", &ImPlot3DSpec::Offset, "Data index offset")
        .def_rw("stride", &ImPlot3DSpec::Stride, "Data stride in bytes; IMPLOT3D_AUTO will result in sizeof(T) where T is the type passed to PlotX")
        .def_rw("flags", &ImPlot3DSpec::Flags, "Optional item flags; can be composed from common ImPlot3DItemFlags and/or specialized ImPlot3DXFlags")
        ;


    m.def("create_context",
        ImPlot3D::CreateContext,
        "Creates a new ImPlot3D context. Call this after ImGui::CreateContext",
        nb::rv_policy::reference);

    m.def("destroy_context",
        ImPlot3D::DestroyContext,
        nb::arg("ctx") = nb::none(),
        "Destroys an ImPlot3D context. Call this before ImGui::DestroyContext. None = destroy current context");

    m.def("get_current_context",
        ImPlot3D::GetCurrentContext,
        "Returns the current ImPlot3D context. None if no context has been set",
        nb::rv_policy::reference);

    m.def("set_current_context",
        ImPlot3D::SetCurrentContext,
        nb::arg("ctx"),
        "Sets the current ImPlot3D context");

    m.def("begin_plot",
        [](const char * title_id, const std::optional<const ImVec2> & size = std::nullopt, ImPlot3DFlags flags = 0) -> bool
        {
            auto BeginPlot_adapt_mutable_param_with_default_value = [](const char * title_id, const std::optional<const ImVec2> & size = std::nullopt, ImPlot3DFlags flags = 0) -> bool
            {

                const ImVec2& size_or_default = [&]() -> const ImVec2 {
                    if (size.has_value())
                        return size.value();
                    else
                        return ImVec2(-1, 0);
                }();

                auto lambda_result = ImPlot3D::BeginPlot(title_id, size_or_default, flags);
                return lambda_result;
            };

            return BeginPlot_adapt_mutable_param_with_default_value(title_id, size, flags);
        },
        nb::arg("title_id"), nb::arg("size").none() = nb::none(), nb::arg("flags") = 0,
        "Python bindings defaults:\n    If size is None, then its default value will be: ImVec2(-1, 0)");

    m.def("end_plot",
        ImPlot3D::EndPlot, "Only call if BeginPlot() returns True!");

    m.def("setup_axis",
        [](ImAxis3D axis, std::optional<std::string> label = std::nullopt, ImPlot3DAxisFlags flags = 0)
        {
            auto SetupAxis_adapt_const_char_pointer_with_default_null = [](ImAxis3D axis, std::optional<std::string> label = std::nullopt, ImPlot3DAxisFlags flags = 0)
            {
                const char * label_adapt_default_null = nullptr;
                if (label.has_value())
                    label_adapt_default_null = label.value().c_str();

                ImPlot3D::SetupAxis(axis, label_adapt_default_null, flags);
            };

            SetupAxis_adapt_const_char_pointer_with_default_null(axis, label, flags);
        },
        nb::arg("axis"), nb::arg("label").none() = nb::none(), nb::arg("flags") = 0,
        "Enables an axis or sets the label and/or flags for an existing axis. Leave #label = None for no label");

    m.def("setup_axis_limits",
        [](ImAxis3D axis, double v_min, double v_max, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
        {
            auto SetupAxisLimits_adapt_mutable_param_with_default_value = [](ImAxis3D axis, double v_min, double v_max, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
            {

                const ImPlot3DCond& cond_or_default = [&]() -> const ImPlot3DCond {
                    if (cond.has_value())
                        return cond.value();
                    else
                        return ImPlot3DCond_Once;
                }();

                ImPlot3D::SetupAxisLimits(axis, v_min, v_max, cond_or_default);
            };

            SetupAxisLimits_adapt_mutable_param_with_default_value(axis, v_min, v_max, cond);
        },
        nb::arg("axis"), nb::arg("v_min"), nb::arg("v_max"), nb::arg("cond").none() = nb::none(),
        " Sets an axis range limits. If ImPlot3DCond_Always is used, the axis limits will be locked.\n Note: To invert an axis, use ImPlot3DAxisFlags_Invert with SetupAxis instead of swapping min/max\n\n\nPython bindings defaults:\n    If cond is None, then its default value will be: Cond_Once");

    m.def("setup_axis_scale",
        [](ImAxis3D axis, ImPlot3DScale scale)
        {
            auto SetupAxisScale_adapt_force_lambda = [](ImAxis3D axis, ImPlot3DScale scale)
            {
                ImPlot3D::SetupAxisScale(axis, scale);
            };

            SetupAxisScale_adapt_force_lambda(axis, scale);
        },
        nb::arg("axis"), nb::arg("scale"),
        "Sets an axis' scale using built-in options");

    m.def("setup_axis_limits_constraints",
        ImPlot3D::SetupAxisLimitsConstraints,
        nb::arg("axis"), nb::arg("v_min"), nb::arg("v_max"),
        "Sets an axis' limits constraints. The axis will be constrained to never go below #v_min or above #v_max");

    m.def("setup_axis_zoom_constraints",
        ImPlot3D::SetupAxisZoomConstraints,
        nb::arg("axis"), nb::arg("zoom_min"), nb::arg("zoom_max"),
        "Sets an axis' zoom constraints. The zoom (axis range size: range.max - range.min) will be constrained between #zoom_min and #zoom_max");

    m.def("setup_axes",
        ImPlot3D::SetupAxes,
        nb::arg("x_label"), nb::arg("y_label"), nb::arg("z_label"), nb::arg("x_flags") = 0, nb::arg("y_flags") = 0, nb::arg("z_flags") = 0,
        "Sets the label and/or flags for primary X/Y/Z axes (shorthand for three calls to SetupAxis)");

    m.def("setup_axes_limits",
        [](double x_min, double x_max, double y_min, double y_max, double z_min, double z_max, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
        {
            auto SetupAxesLimits_adapt_mutable_param_with_default_value = [](double x_min, double x_max, double y_min, double y_max, double z_min, double z_max, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
            {

                const ImPlot3DCond& cond_or_default = [&]() -> const ImPlot3DCond {
                    if (cond.has_value())
                        return cond.value();
                    else
                        return ImPlot3DCond_Once;
                }();

                ImPlot3D::SetupAxesLimits(x_min, x_max, y_min, y_max, z_min, z_max, cond_or_default);
            };

            SetupAxesLimits_adapt_mutable_param_with_default_value(x_min, x_max, y_min, y_max, z_min, z_max, cond);
        },
        nb::arg("x_min"), nb::arg("x_max"), nb::arg("y_min"), nb::arg("y_max"), nb::arg("z_min"), nb::arg("z_max"), nb::arg("cond").none() = nb::none(),
        " Sets the X/Y/Z axes range limits. If ImPlot3DCond_Always is used, the axes limits will be locked (shorthand for three calls to SetupAxisLimits)\n\n\nPython bindings defaults:\n    If cond is None, then its default value will be: Cond_Once");

    m.def("setup_box_rotation",
        [](double elevation, double azimuth, bool animate = false, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
        {
            auto SetupBoxRotation_adapt_mutable_param_with_default_value = [](double elevation, double azimuth, bool animate = false, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
            {

                const ImPlot3DCond& cond_or_default = [&]() -> const ImPlot3DCond {
                    if (cond.has_value())
                        return cond.value();
                    else
                        return ImPlot3DCond_Once;
                }();

                ImPlot3D::SetupBoxRotation(elevation, azimuth, animate, cond_or_default);
            };

            SetupBoxRotation_adapt_mutable_param_with_default_value(elevation, azimuth, animate, cond);
        },
        nb::arg("elevation"), nb::arg("azimuth"), nb::arg("animate") = false, nb::arg("cond").none() = nb::none(),
        " Sets the plot box rotation given the elevation and azimuth angles in degrees. If ImPlot3DCond_Always is used, the rotation will be locked\n\n\nPython bindings defaults:\n    If cond is None, then its default value will be: Cond_Once");

    m.def("setup_box_rotation",
        [](ImPlot3DQuat rotation, bool animate = false, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
        {
            auto SetupBoxRotation_adapt_mutable_param_with_default_value = [](ImPlot3DQuat rotation, bool animate = false, const std::optional<const ImPlot3DCond> & cond = std::nullopt)
            {

                const ImPlot3DCond& cond_or_default = [&]() -> const ImPlot3DCond {
                    if (cond.has_value())
                        return cond.value();
                    else
                        return ImPlot3DCond_Once;
                }();

                ImPlot3D::SetupBoxRotation(rotation, animate, cond_or_default);
            };

            SetupBoxRotation_adapt_mutable_param_with_default_value(rotation, animate, cond);
        },
        nb::arg("rotation"), nb::arg("animate") = false, nb::arg("cond").none() = nb::none(),
        " Sets the plot box rotation given a quaternion. If ImPlot3DCond_Always is used, the rotation will be locked\n\n\nPython bindings defaults:\n    If cond is None, then its default value will be: Cond_Once");

    m.def("setup_box_initial_rotation",
        nb::overload_cast<double, double>(ImPlot3D::SetupBoxInitialRotation),
        nb::arg("elevation"), nb::arg("azimuth"),
        " Sets the plot box initial rotation given the elevation and azimuth angles in degrees. The initial rotation is the rotation the plot goes back to\n when a left mouse button double click happens");

    m.def("setup_box_initial_rotation",
        nb::overload_cast<ImPlot3DQuat>(ImPlot3D::SetupBoxInitialRotation),
        nb::arg("rotation"),
        " Sets the plot box initial rotation given a quaternion. The initial rotation is the rotation the plot goes back to when a left mouse button double\n click happens");

    m.def("setup_box_scale",
        ImPlot3D::SetupBoxScale,
        nb::arg("x"), nb::arg("y"), nb::arg("z"),
        "Sets the plot box X/Y/Z scale. A scale of 1.0 is the default. Values greater than 1.0 enlarge the plot, while values between 0.0 and 1.0 shrink it");

    m.def("setup_legend",
        ImPlot3D::SetupLegend,
        nb::arg("location"), nb::arg("flags") = 0,
        "Sets up the plot legend location and flags");

    m.def("plot_scatter",
        [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotScatter_adapt_c_buffers = [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const ImPlot3DSpec & spec = ImPlot3DSpec())
            {
                // Check if the array is 1D and C-contiguous
                if (! (xs.ndim() == 1 && xs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                size_t xs_count = xs.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (ys.ndim() == 1 && ys.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                size_t ys_count = ys.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (zs.ndim() == 1 && zs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * zs_from_pyarray = zs.data();
                size_t zs_count = zs.shape(0);

                using np_uint_l = uint64_t;
                using np_int_l = int64_t;

                // Define a lambda to compute the letter code for the buffer type
                auto _nanobind_buffer_type_to_letter_code = [](uint8_t dtype_code, size_t sizeof_item)  -> char
                {
                    #define DCODE(T) static_cast<uint8_t>(nb::dlpack::dtype_code::T)
                        const std::array<std::tuple<uint8_t, size_t, char>, 11> mappings = {{
                            {DCODE(UInt), 1, 'B'}, {DCODE(UInt), 2, 'H'}, {DCODE(UInt), 4, 'I'}, {DCODE(UInt), 8, 'L'},
                            {DCODE(Int), 1, 'b'}, {DCODE(Int), 2, 'h'}, {DCODE(Int), 4, 'i'}, {DCODE(Int), 8, 'l'},
                            {DCODE(Float), 4, 'f'}, {DCODE(Float), 8, 'd'}, {DCODE(Float), 16, 'g'}
                        }};
                    #undef DCODE
                    for (const auto& [code_val, size, letter] : mappings)
                        if (code_val == dtype_code && size == sizeof_item)
                            return letter;
                    throw std::runtime_error("Unsupported dtype");
                };

                // Compute the letter code for the buffer type
                uint8_t dtype_code_zs = zs.dtype().code;
                size_t sizeof_item_zs = zs.dtype().bits / 8;
                char zs_type = _nanobind_buffer_type_to_letter_code(dtype_code_zs, sizeof_item_zs);

                // call the correct template version by casting
                if (zs_type == 'B')
                    ImPlot3D::PlotScatter(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<const uint8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'b')
                    ImPlot3D::PlotScatter(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<const int8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'H')
                    ImPlot3D::PlotScatter(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<const uint16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'h')
                    ImPlot3D::PlotScatter(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<const int16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'I')
                    ImPlot3D::PlotScatter(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<const uint32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'i')
                    ImPlot3D::PlotScatter(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<const int32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'L')
                    ImPlot3D::PlotScatter(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<const np_uint_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'l')
                    ImPlot3D::PlotScatter(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<const np_int_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'f')
                    ImPlot3D::PlotScatter(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<const float *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'd')
                    ImPlot3D::PlotScatter(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<const double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'g')
                    ImPlot3D::PlotScatter(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<const long double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'q')
                    ImPlot3D::PlotScatter(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<const long long *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + zs_type + "') for param zs");
            };
            auto PlotScatter_adapt_mutable_param_with_default_value = [&PlotScatter_adapt_c_buffers](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                PlotScatter_adapt_c_buffers(label_id, xs, ys, zs, spec_or_default);
            };

            PlotScatter_adapt_mutable_param_with_default_value(label_id, xs, ys, zs, spec);
        },
        nb::arg("label_id"), nb::arg("xs"), nb::arg("ys"), nb::arg("zs"), nb::arg("spec").none() = nb::none(),
        " Plots a scatter plot in 3D. Points are rendered as markers at the specified coordinates\n\n\nPython bindings defaults:\n    If spec is None, then its default value will be: Spec()");

    m.def("plot_line",
        [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotLine_adapt_c_buffers = [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const ImPlot3DSpec & spec = ImPlot3DSpec())
            {
                // Check if the array is 1D and C-contiguous
                if (! (xs.ndim() == 1 && xs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                size_t xs_count = xs.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (ys.ndim() == 1 && ys.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                size_t ys_count = ys.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (zs.ndim() == 1 && zs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * zs_from_pyarray = zs.data();
                size_t zs_count = zs.shape(0);

                using np_uint_l = uint64_t;
                using np_int_l = int64_t;

                // Define a lambda to compute the letter code for the buffer type
                auto _nanobind_buffer_type_to_letter_code = [](uint8_t dtype_code, size_t sizeof_item)  -> char
                {
                    #define DCODE(T) static_cast<uint8_t>(nb::dlpack::dtype_code::T)
                        const std::array<std::tuple<uint8_t, size_t, char>, 11> mappings = {{
                            {DCODE(UInt), 1, 'B'}, {DCODE(UInt), 2, 'H'}, {DCODE(UInt), 4, 'I'}, {DCODE(UInt), 8, 'L'},
                            {DCODE(Int), 1, 'b'}, {DCODE(Int), 2, 'h'}, {DCODE(Int), 4, 'i'}, {DCODE(Int), 8, 'l'},
                            {DCODE(Float), 4, 'f'}, {DCODE(Float), 8, 'd'}, {DCODE(Float), 16, 'g'}
                        }};
                    #undef DCODE
                    for (const auto& [code_val, size, letter] : mappings)
                        if (code_val == dtype_code && size == sizeof_item)
                            return letter;
                    throw std::runtime_error("Unsupported dtype");
                };

                // Compute the letter code for the buffer type
                uint8_t dtype_code_zs = zs.dtype().code;
                size_t sizeof_item_zs = zs.dtype().bits / 8;
                char zs_type = _nanobind_buffer_type_to_letter_code(dtype_code_zs, sizeof_item_zs);

                // call the correct template version by casting
                if (zs_type == 'B')
                    ImPlot3D::PlotLine(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<const uint8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'b')
                    ImPlot3D::PlotLine(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<const int8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'H')
                    ImPlot3D::PlotLine(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<const uint16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'h')
                    ImPlot3D::PlotLine(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<const int16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'I')
                    ImPlot3D::PlotLine(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<const uint32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'i')
                    ImPlot3D::PlotLine(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<const int32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'L')
                    ImPlot3D::PlotLine(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<const np_uint_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'l')
                    ImPlot3D::PlotLine(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<const np_int_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'f')
                    ImPlot3D::PlotLine(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<const float *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'd')
                    ImPlot3D::PlotLine(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<const double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'g')
                    ImPlot3D::PlotLine(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<const long double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'q')
                    ImPlot3D::PlotLine(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<const long long *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + zs_type + "') for param zs");
            };
            auto PlotLine_adapt_mutable_param_with_default_value = [&PlotLine_adapt_c_buffers](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                PlotLine_adapt_c_buffers(label_id, xs, ys, zs, spec_or_default);
            };

            PlotLine_adapt_mutable_param_with_default_value(label_id, xs, ys, zs, spec);
        },
        nb::arg("label_id"), nb::arg("xs"), nb::arg("ys"), nb::arg("zs"), nb::arg("spec").none() = nb::none(),
        " Plots a line in 3D. Consecutive points are connected with line segments\n\n\nPython bindings defaults:\n    If spec is None, then its default value will be: Spec()");

    m.def("plot_triangle",
        [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotTriangle_adapt_c_buffers = [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const ImPlot3DSpec & spec = ImPlot3DSpec())
            {
                // Check if the array is 1D and C-contiguous
                if (! (xs.ndim() == 1 && xs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                size_t xs_count = xs.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (ys.ndim() == 1 && ys.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                size_t ys_count = ys.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (zs.ndim() == 1 && zs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * zs_from_pyarray = zs.data();
                size_t zs_count = zs.shape(0);

                using np_uint_l = uint64_t;
                using np_int_l = int64_t;

                // Define a lambda to compute the letter code for the buffer type
                auto _nanobind_buffer_type_to_letter_code = [](uint8_t dtype_code, size_t sizeof_item)  -> char
                {
                    #define DCODE(T) static_cast<uint8_t>(nb::dlpack::dtype_code::T)
                        const std::array<std::tuple<uint8_t, size_t, char>, 11> mappings = {{
                            {DCODE(UInt), 1, 'B'}, {DCODE(UInt), 2, 'H'}, {DCODE(UInt), 4, 'I'}, {DCODE(UInt), 8, 'L'},
                            {DCODE(Int), 1, 'b'}, {DCODE(Int), 2, 'h'}, {DCODE(Int), 4, 'i'}, {DCODE(Int), 8, 'l'},
                            {DCODE(Float), 4, 'f'}, {DCODE(Float), 8, 'd'}, {DCODE(Float), 16, 'g'}
                        }};
                    #undef DCODE
                    for (const auto& [code_val, size, letter] : mappings)
                        if (code_val == dtype_code && size == sizeof_item)
                            return letter;
                    throw std::runtime_error("Unsupported dtype");
                };

                // Compute the letter code for the buffer type
                uint8_t dtype_code_zs = zs.dtype().code;
                size_t sizeof_item_zs = zs.dtype().bits / 8;
                char zs_type = _nanobind_buffer_type_to_letter_code(dtype_code_zs, sizeof_item_zs);

                // call the correct template version by casting
                if (zs_type == 'B')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<const uint8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'b')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<const int8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'H')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<const uint16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'h')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<const int16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'I')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<const uint32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'i')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<const int32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'L')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<const np_uint_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'l')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<const np_int_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'f')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<const float *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'd')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<const double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'g')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<const long double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'q')
                    ImPlot3D::PlotTriangle(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<const long long *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + zs_type + "') for param zs");
            };
            auto PlotTriangle_adapt_mutable_param_with_default_value = [&PlotTriangle_adapt_c_buffers](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                PlotTriangle_adapt_c_buffers(label_id, xs, ys, zs, spec_or_default);
            };

            PlotTriangle_adapt_mutable_param_with_default_value(label_id, xs, ys, zs, spec);
        },
        nb::arg("label_id"), nb::arg("xs"), nb::arg("ys"), nb::arg("zs"), nb::arg("spec").none() = nb::none(),
        " Plots triangles in 3D. Every 3 consecutive points define a triangle\n\n\nPython bindings defaults:\n    If spec is None, then its default value will be: Spec()");

    m.def("plot_quad",
        [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotQuad_adapt_c_buffers = [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const ImPlot3DSpec & spec = ImPlot3DSpec())
            {
                // Check if the array is 1D and C-contiguous
                if (! (xs.ndim() == 1 && xs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                size_t xs_count = xs.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (ys.ndim() == 1 && ys.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                size_t ys_count = ys.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (zs.ndim() == 1 && zs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * zs_from_pyarray = zs.data();
                size_t zs_count = zs.shape(0);

                using np_uint_l = uint64_t;
                using np_int_l = int64_t;

                // Define a lambda to compute the letter code for the buffer type
                auto _nanobind_buffer_type_to_letter_code = [](uint8_t dtype_code, size_t sizeof_item)  -> char
                {
                    #define DCODE(T) static_cast<uint8_t>(nb::dlpack::dtype_code::T)
                        const std::array<std::tuple<uint8_t, size_t, char>, 11> mappings = {{
                            {DCODE(UInt), 1, 'B'}, {DCODE(UInt), 2, 'H'}, {DCODE(UInt), 4, 'I'}, {DCODE(UInt), 8, 'L'},
                            {DCODE(Int), 1, 'b'}, {DCODE(Int), 2, 'h'}, {DCODE(Int), 4, 'i'}, {DCODE(Int), 8, 'l'},
                            {DCODE(Float), 4, 'f'}, {DCODE(Float), 8, 'd'}, {DCODE(Float), 16, 'g'}
                        }};
                    #undef DCODE
                    for (const auto& [code_val, size, letter] : mappings)
                        if (code_val == dtype_code && size == sizeof_item)
                            return letter;
                    throw std::runtime_error("Unsupported dtype");
                };

                // Compute the letter code for the buffer type
                uint8_t dtype_code_zs = zs.dtype().code;
                size_t sizeof_item_zs = zs.dtype().bits / 8;
                char zs_type = _nanobind_buffer_type_to_letter_code(dtype_code_zs, sizeof_item_zs);

                // call the correct template version by casting
                if (zs_type == 'B')
                    ImPlot3D::PlotQuad(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<const uint8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'b')
                    ImPlot3D::PlotQuad(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<const int8_t *>(ys_from_pyarray), static_cast<const int8_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'H')
                    ImPlot3D::PlotQuad(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<const uint16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'h')
                    ImPlot3D::PlotQuad(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<const int16_t *>(ys_from_pyarray), static_cast<const int16_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'I')
                    ImPlot3D::PlotQuad(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<const uint32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'i')
                    ImPlot3D::PlotQuad(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<const int32_t *>(ys_from_pyarray), static_cast<const int32_t *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'L')
                    ImPlot3D::PlotQuad(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<const np_uint_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'l')
                    ImPlot3D::PlotQuad(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<const np_int_l *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'f')
                    ImPlot3D::PlotQuad(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<const float *>(ys_from_pyarray), static_cast<const float *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'd')
                    ImPlot3D::PlotQuad(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<const double *>(ys_from_pyarray), static_cast<const double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'g')
                    ImPlot3D::PlotQuad(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<const long double *>(ys_from_pyarray), static_cast<const long double *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                else if (zs_type == 'q')
                    ImPlot3D::PlotQuad(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<const long long *>(ys_from_pyarray), static_cast<const long long *>(zs_from_pyarray), static_cast<int>(zs_count), spec);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + zs_type + "') for param zs");
            };
            auto PlotQuad_adapt_mutable_param_with_default_value = [&PlotQuad_adapt_c_buffers](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                PlotQuad_adapt_c_buffers(label_id, xs, ys, zs, spec_or_default);
            };

            PlotQuad_adapt_mutable_param_with_default_value(label_id, xs, ys, zs, spec);
        },
        nb::arg("label_id"), nb::arg("xs"), nb::arg("ys"), nb::arg("zs"), nb::arg("spec").none() = nb::none(),
        " Plots quads in 3D. Every 4 consecutive points define a quadrilateral\n\n\nPython bindings defaults:\n    If spec is None, then its default value will be: Spec()");
    // #ifdef IMGUI_BUNDLE_PYTHON_API
    //

    m.def("plot_surface",
        [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, int x_count, int y_count, double scale_min = 0.0, double scale_max = 0.0, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotSurface_adapt_c_buffers = [](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, int x_count, int y_count, double scale_min = 0.0, double scale_max = 0.0, const ImPlot3DSpec & spec = ImPlot3DSpec())
            {
                // Check if the array is 1D and C-contiguous
                if (! (xs.ndim() == 1 && xs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * xs_from_pyarray = xs.data();
                size_t xs_count = xs.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (ys.ndim() == 1 && ys.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * ys_from_pyarray = ys.data();
                size_t ys_count = ys.shape(0);

                // Check if the array is 1D and C-contiguous
                if (! (zs.ndim() == 1 && zs.stride(0) == 1))
                    throw std::runtime_error("The array must be 1D and contiguous");

                // convert nb::ndarray to C standard buffer (const)
                const void * zs_from_pyarray = zs.data();
                size_t zs_count = zs.shape(0);

                using np_uint_l = uint64_t;
                using np_int_l = int64_t;

                // Define a lambda to compute the letter code for the buffer type
                auto _nanobind_buffer_type_to_letter_code = [](uint8_t dtype_code, size_t sizeof_item)  -> char
                {
                    #define DCODE(T) static_cast<uint8_t>(nb::dlpack::dtype_code::T)
                        const std::array<std::tuple<uint8_t, size_t, char>, 11> mappings = {{
                            {DCODE(UInt), 1, 'B'}, {DCODE(UInt), 2, 'H'}, {DCODE(UInt), 4, 'I'}, {DCODE(UInt), 8, 'L'},
                            {DCODE(Int), 1, 'b'}, {DCODE(Int), 2, 'h'}, {DCODE(Int), 4, 'i'}, {DCODE(Int), 8, 'l'},
                            {DCODE(Float), 4, 'f'}, {DCODE(Float), 8, 'd'}, {DCODE(Float), 16, 'g'}
                        }};
                    #undef DCODE
                    for (const auto& [code_val, size, letter] : mappings)
                        if (code_val == dtype_code && size == sizeof_item)
                            return letter;
                    throw std::runtime_error("Unsupported dtype");
                };

                // Compute the letter code for the buffer type
                uint8_t dtype_code_zs = zs.dtype().code;
                size_t sizeof_item_zs = zs.dtype().bits / 8;
                char zs_type = _nanobind_buffer_type_to_letter_code(dtype_code_zs, sizeof_item_zs);

                // call the correct template version by casting
                if (zs_type == 'B')
                    ImPlot3D::PlotSurface(label_id, static_cast<const uint8_t *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const uint8_t *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const uint8_t *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'b')
                    ImPlot3D::PlotSurface(label_id, static_cast<const int8_t *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const int8_t *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const int8_t *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'H')
                    ImPlot3D::PlotSurface(label_id, static_cast<const uint16_t *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const uint16_t *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const uint16_t *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'h')
                    ImPlot3D::PlotSurface(label_id, static_cast<const int16_t *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const int16_t *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const int16_t *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'I')
                    ImPlot3D::PlotSurface(label_id, static_cast<const uint32_t *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const uint32_t *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const uint32_t *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'i')
                    ImPlot3D::PlotSurface(label_id, static_cast<const int32_t *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const int32_t *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const int32_t *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'L')
                    ImPlot3D::PlotSurface(label_id, static_cast<const np_uint_l *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const np_uint_l *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const np_uint_l *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'l')
                    ImPlot3D::PlotSurface(label_id, static_cast<const np_int_l *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const np_int_l *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const np_int_l *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'f')
                    ImPlot3D::PlotSurface(label_id, static_cast<const float *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const float *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const float *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'd')
                    ImPlot3D::PlotSurface(label_id, static_cast<const double *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const double *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const double *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'g')
                    ImPlot3D::PlotSurface(label_id, static_cast<const long double *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const long double *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const long double *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                else if (zs_type == 'q')
                    ImPlot3D::PlotSurface(label_id, static_cast<const long long *>(xs_from_pyarray), static_cast<int>(xs_count), static_cast<const long long *>(ys_from_pyarray), static_cast<int>(ys_count), static_cast<const long long *>(zs_from_pyarray), static_cast<int>(zs_count), x_count, y_count, scale_min, scale_max, spec);
                // If we reach this point, the array type is not supported!
                else
                    throw std::runtime_error(std::string("Bad array type ('") + zs_type + "') for param zs");
            };
            auto PlotSurface_adapt_mutable_param_with_default_value = [&PlotSurface_adapt_c_buffers](const char * label_id, nb::ndarray<nb::ro> & xs, nb::ndarray<nb::ro> & ys, nb::ndarray<nb::ro> & zs, int x_count, int y_count, double scale_min = 0.0, double scale_max = 0.0, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                PlotSurface_adapt_c_buffers(label_id, xs, ys, zs, x_count, y_count, scale_min, scale_max, spec_or_default);
            };

            PlotSurface_adapt_mutable_param_with_default_value(label_id, xs, ys, zs, x_count, y_count, scale_min, scale_max, spec);
        },
        nb::arg("label_id"), nb::arg("xs"), nb::arg("ys"), nb::arg("zs"), nb::arg("x_count"), nb::arg("y_count"), nb::arg("scale_min") = 0.0, nb::arg("scale_max") = 0.0, nb::arg("spec").none() = nb::none(),
        " Plot the surface defined by a grid of vertices. The grid is defined by the x and y arrays,\n and the z array contains the height of each vertex.\n A total of x_count * y_count vertices are expected for each array.\n Leave #scale_min and #scale_max both at 0 for automatic color scaling, or set them to a predefined range.\n\n\nPython bindings defaults:\n    If spec is None, then its default value will be: Spec()");
    // #endif
    //
    // #ifdef IMGUI_BUNDLE_PYTHON_API
    //


    auto pyClassMesh =
        nb::class_<ImPlot3D::Mesh>
            (m, "Mesh", "")
        .def("__init__", [](ImPlot3D::Mesh * self, const std::optional<const std::vector<ImPlot3DPoint>> & Points = std::nullopt, const std::optional<const std::vector<UInt>> & Idx = std::nullopt)
        {
            new (self) ImPlot3D::Mesh();  // placement new
            auto r_ctor_ = self;
            if (Points.has_value())
                r_ctor_->Points = Points.value();
            else
                r_ctor_->Points = std::vector<ImPlot3DPoint>();
            if (Idx.has_value())
                r_ctor_->Idx = Idx.value();
            else
                r_ctor_->Idx = std::vector<UInt>();
        },
        nb::arg("points").none() = nb::none(), nb::arg("idx").none() = nb::none()
        )
        .def_rw("points", &ImPlot3D::Mesh::Points, "")
        .def_rw("idx", &ImPlot3D::Mesh::Idx, "Triangles are defined by the index buffer (every 3 indices form a triangle)")
        ;


    m.def("plot_mesh",
        [](const char * label_id, const ImPlot3D::Mesh & mesh, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotMesh_adapt_mutable_param_with_default_value = [](const char * label_id, const ImPlot3D::Mesh & mesh, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                ImPlot3D::PlotMesh(label_id, mesh, spec_or_default);
            };

            PlotMesh_adapt_mutable_param_with_default_value(label_id, mesh, spec);
        },
        nb::arg("label_id"), nb::arg("mesh"), nb::arg("spec").none() = nb::none(),
        "Python bindings defaults:\n    If spec is None, then its default value will be: Spec()");
    // #endif
    //

    m.def("plot_image",
        [](const char * label_id, ImTextureRef tex_ref, const ImPlot3DPoint & center, const ImPlot3DPoint & axis_u, const ImPlot3DPoint & axis_v, const std::optional<const ImVec2> & uv0 = std::nullopt, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec4> & tint_col = std::nullopt, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotImage_adapt_mutable_param_with_default_value = [](const char * label_id, ImTextureRef tex_ref, const ImPlot3DPoint & center, const ImPlot3DPoint & axis_u, const ImPlot3DPoint & axis_v, const std::optional<const ImVec2> & uv0 = std::nullopt, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec4> & tint_col = std::nullopt, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImVec2& uv0_or_default = [&]() -> const ImVec2 {
                    if (uv0.has_value())
                        return uv0.value();
                    else
                        return ImVec2(0, 0);
                }();

                const ImVec2& uv1_or_default = [&]() -> const ImVec2 {
                    if (uv1.has_value())
                        return uv1.value();
                    else
                        return ImVec2(1, 1);
                }();

                const ImVec4& tint_col_or_default = [&]() -> const ImVec4 {
                    if (tint_col.has_value())
                        return tint_col.value();
                    else
                        return ImVec4(1, 1, 1, 1);
                }();

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                ImPlot3D::PlotImage(label_id, tex_ref, center, axis_u, axis_v, uv0_or_default, uv1_or_default, tint_col_or_default, spec_or_default);
            };

            PlotImage_adapt_mutable_param_with_default_value(label_id, tex_ref, center, axis_u, axis_v, uv0, uv1, tint_col, spec);
        },
        nb::arg("label_id"), nb::arg("tex_ref"), nb::arg("center"), nb::arg("axis_u"), nb::arg("axis_v"), nb::arg("uv0").none() = nb::none(), nb::arg("uv1").none() = nb::none(), nb::arg("tint_col").none() = nb::none(), nb::arg("spec").none() = nb::none(),
        " Plots a rectangular image in 3D defined by its center and two direction vectors (axes).\n #center is the center of the rectangle in plot coordinates.\n #axis_u and #axis_v define the local axes and half-extents of the rectangle in 3D space.\n The rectangle is formed by moving from the center along axis_u and axis_v.\n #uv0 and #uv1 define the texture mapping.\n #tint_col can be used to tint the image.\n\n\nPython bindings defaults:\n    If any of the params below is None, then its default value below will be used:\n        * uv0: ImVec2(0, 0)\n        * uv1: ImVec2(1, 1)\n        * tint_col: ImVec4(1, 1, 1, 1)\n        * spec: Spec()");

    m.def("plot_image",
        [](const char * label_id, ImTextureRef tex_ref, const ImPlot3DPoint & p0, const ImPlot3DPoint & p1, const ImPlot3DPoint & p2, const ImPlot3DPoint & p3, const std::optional<const ImVec2> & uv0 = std::nullopt, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec2> & uv2 = std::nullopt, const std::optional<const ImVec2> & uv3 = std::nullopt, const std::optional<const ImVec4> & tint_col = std::nullopt, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotImage_adapt_mutable_param_with_default_value = [](const char * label_id, ImTextureRef tex_ref, const ImPlot3DPoint & p0, const ImPlot3DPoint & p1, const ImPlot3DPoint & p2, const ImPlot3DPoint & p3, const std::optional<const ImVec2> & uv0 = std::nullopt, const std::optional<const ImVec2> & uv1 = std::nullopt, const std::optional<const ImVec2> & uv2 = std::nullopt, const std::optional<const ImVec2> & uv3 = std::nullopt, const std::optional<const ImVec4> & tint_col = std::nullopt, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImVec2& uv0_or_default = [&]() -> const ImVec2 {
                    if (uv0.has_value())
                        return uv0.value();
                    else
                        return ImVec2(0, 0);
                }();

                const ImVec2& uv1_or_default = [&]() -> const ImVec2 {
                    if (uv1.has_value())
                        return uv1.value();
                    else
                        return ImVec2(1, 0);
                }();

                const ImVec2& uv2_or_default = [&]() -> const ImVec2 {
                    if (uv2.has_value())
                        return uv2.value();
                    else
                        return ImVec2(1, 1);
                }();

                const ImVec2& uv3_or_default = [&]() -> const ImVec2 {
                    if (uv3.has_value())
                        return uv3.value();
                    else
                        return ImVec2(0, 1);
                }();

                const ImVec4& tint_col_or_default = [&]() -> const ImVec4 {
                    if (tint_col.has_value())
                        return tint_col.value();
                    else
                        return ImVec4(1, 1, 1, 1);
                }();

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                ImPlot3D::PlotImage(label_id, tex_ref, p0, p1, p2, p3, uv0_or_default, uv1_or_default, uv2_or_default, uv3_or_default, tint_col_or_default, spec_or_default);
            };

            PlotImage_adapt_mutable_param_with_default_value(label_id, tex_ref, p0, p1, p2, p3, uv0, uv1, uv2, uv3, tint_col, spec);
        },
        nb::arg("label_id"), nb::arg("tex_ref"), nb::arg("p0"), nb::arg("p1"), nb::arg("p2"), nb::arg("p3"), nb::arg("uv0").none() = nb::none(), nb::arg("uv1").none() = nb::none(), nb::arg("uv2").none() = nb::none(), nb::arg("uv3").none() = nb::none(), nb::arg("tint_col").none() = nb::none(), nb::arg("spec").none() = nb::none(),
        " Plots an image using four arbitrary 3D points that define a quad in space.\n Each corner (p0 to p3) corresponds to a corner in the image, and #uv0 to #uv3 are the texture coordinates for each.\n This overload allows full control over orientation, shape, and distortion.\n Note: The quad is internally split into two triangles, so non-rectangular quads may produce rendering artifacts\n since distortion is interpolated per triangle rather than over the full quad.\n\n\nPython bindings defaults:\n    If any of the params below is None, then its default value below will be used:\n        * uv0: ImVec2(0, 0)\n        * uv1: ImVec2(1, 0)\n        * uv2: ImVec2(1, 1)\n        * uv3: ImVec2(0, 1)\n        * tint_col: ImVec4(1, 1, 1, 1)\n        * spec: Spec()");

    m.def("plot_text",
        [](const char * text, double x, double y, double z, double angle = 0.0, const std::optional<const ImVec2> & pix_offset = std::nullopt)
        {
            auto PlotText_adapt_mutable_param_with_default_value = [](const char * text, double x, double y, double z, double angle = 0.0, const std::optional<const ImVec2> & pix_offset = std::nullopt)
            {

                const ImVec2& pix_offset_or_default = [&]() -> const ImVec2 {
                    if (pix_offset.has_value())
                        return pix_offset.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImPlot3D::PlotText(text, x, y, z, angle, pix_offset_or_default);
            };

            PlotText_adapt_mutable_param_with_default_value(text, x, y, z, angle, pix_offset);
        },
        nb::arg("text"), nb::arg("x"), nb::arg("y"), nb::arg("z"), nb::arg("angle") = 0.0, nb::arg("pix_offset").none() = nb::none(),
        " Plots a centered text label at point x,y,z with optional rotation angle (in radians) and pixel offset\n\n\nPython bindings defaults:\n    If pix_offset is None, then its default value will be: ImVec2(0, 0)");

    m.def("plot_dummy",
        [](const char * label_id, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
        {
            auto PlotDummy_adapt_mutable_param_with_default_value = [](const char * label_id, const std::optional<const ImPlot3DSpec> & spec = std::nullopt)
            {

                const ImPlot3DSpec& spec_or_default = [&]() -> const ImPlot3DSpec {
                    if (spec.has_value())
                        return spec.value();
                    else
                        return ImPlot3DSpec();
                }();

                ImPlot3D::PlotDummy(label_id, spec_or_default);
            };

            PlotDummy_adapt_mutable_param_with_default_value(label_id, spec);
        },
        nb::arg("label_id"), nb::arg("spec").none() = nb::none(),
        " Plots a dummy item (can be used to modify legend entry appearance when called after plotting an item, or add a dummy legend entry)\n\n\nPython bindings defaults:\n    If spec is None, then its default value will be: Spec()");

    m.def("plot_to_pixels",
        nb::overload_cast<const ImPlot3DPoint &>(ImPlot3D::PlotToPixels), nb::arg("point"));

    m.def("plot_to_pixels",
        nb::overload_cast<double, double, double>(ImPlot3D::PlotToPixels), nb::arg("x"), nb::arg("y"), nb::arg("z"));

    m.def("pixels_to_plot_ray",
        nb::overload_cast<const ImVec2 &>(ImPlot3D::PixelsToPlotRay), nb::arg("pix"));

    m.def("pixels_to_plot_ray",
        nb::overload_cast<double, double>(ImPlot3D::PixelsToPlotRay), nb::arg("x"), nb::arg("y"));

    m.def("pixels_to_plot_plane",
        nb::overload_cast<const ImVec2 &, ImPlane3D, bool>(ImPlot3D::PixelsToPlotPlane), nb::arg("pix"), nb::arg("plane"), nb::arg("mask") = true);

    m.def("pixels_to_plot_plane",
        nb::overload_cast<double, double, ImPlane3D, bool>(ImPlot3D::PixelsToPlotPlane), nb::arg("x"), nb::arg("y"), nb::arg("plane"), nb::arg("mask") = true);

    m.def("get_plot_rect_pos",
        ImPlot3D::GetPlotRectPos, "Get the current plot rect position (top-left) in absolute screen coordinates");

    m.def("get_plot_rect_size",
        ImPlot3D::GetPlotRectSize, "Get the current plot rect size in pixels");

    m.def("get_plot_draw_list",
        nb::overload_cast<>(ImPlot3D::GetPlotDrawList),
        "Returns the ImDrawList used for rendering plot items. Use this to add custom rendering inside plots",
        nb::rv_policy::reference);

    m.def("get_style",
        ImPlot3D::GetStyle, nb::rv_policy::reference);

    m.def("set_style",
        ImPlot3D::SetStyle, nb::arg("style"));

    m.def("style_colors_auto",
        ImPlot3D::StyleColorsAuto,
        nb::arg("dst") = nb::none(),
        "Set colors with ImGui style");

    m.def("style_colors_dark",
        ImPlot3D::StyleColorsDark,
        nb::arg("dst") = nb::none(),
        "Set colors with dark style");

    m.def("style_colors_light",
        ImPlot3D::StyleColorsLight,
        nb::arg("dst") = nb::none(),
        "Set colors with light style");

    m.def("style_colors_classic",
        ImPlot3D::StyleColorsClassic,
        nb::arg("dst") = nb::none(),
        "Set colors with classic style");

    m.def("push_style_color",
        nb::overload_cast<ImPlot3DCol, ImU32>(ImPlot3D::PushStyleColor), nb::arg("idx"), nb::arg("col"));

    m.def("push_style_color",
        nb::overload_cast<ImPlot3DCol, const ImVec4 &>(ImPlot3D::PushStyleColor), nb::arg("idx"), nb::arg("col"));

    m.def("pop_style_color",
        ImPlot3D::PopStyleColor,
        nb::arg("count") = 1,
        "Undo temporary style color modification(s). Undo multiple pushes at once by increasing count");

    m.def("push_style_var",
        nb::overload_cast<ImPlot3DStyleVar, float>(ImPlot3D::PushStyleVar),
        nb::arg("idx"), nb::arg("val"),
        "Temporarily modify a style variable of float type. Don't forget to call PopStyleVar!");

    m.def("push_style_var",
        nb::overload_cast<ImPlot3DStyleVar, int>(ImPlot3D::PushStyleVar),
        nb::arg("idx"), nb::arg("val"),
        "Temporarily modify a style variable of int type. Don't forget to call PopStyleVar!");

    m.def("push_style_var",
        nb::overload_cast<ImPlot3DStyleVar, const ImVec2 &>(ImPlot3D::PushStyleVar),
        nb::arg("idx"), nb::arg("val"),
        "Temporarily modify a style variable of ImVec2 type. Don't forget to call PopStyleVar!");

    m.def("pop_style_var",
        ImPlot3D::PopStyleVar,
        nb::arg("count") = 1,
        "Undo temporary style variable modification(s). Undo multiple pushes at once by increasing count");

    m.def("get_style_color_vec4",
        ImPlot3D::GetStyleColorVec4, nb::arg("idx"));

    m.def("get_style_color_u32",
        ImPlot3D::GetStyleColorU32, nb::arg("idx"));

    m.def("next_marker",
        ImPlot3D::NextMarker, "Returns the next marker and advances the marker for the current plot. You need to call this between Begin/EndPlot!");

    m.def("add_colormap",
        nb::overload_cast<const char *, const ImVec4 *, int, bool>(ImPlot3D::AddColormap), nb::arg("name"), nb::arg("cols"), nb::arg("size"), nb::arg("qual") = true);

    m.def("add_colormap",
        nb::overload_cast<const char *, const ImU32 *, int, bool>(ImPlot3D::AddColormap), nb::arg("name"), nb::arg("cols"), nb::arg("size"), nb::arg("qual") = true);

    m.def("get_colormap_count",
        ImPlot3D::GetColormapCount, "Returns the number of available colormaps (i.e. the built-in + user-added count)");

    m.def("get_colormap_name",
        ImPlot3D::GetColormapName,
        nb::arg("cmap"),
        "Returns a null terminated string name for a colormap given an index. Returns None if index is invalid",
        nb::rv_policy::reference);

    m.def("get_colormap_index",
        ImPlot3D::GetColormapIndex,
        nb::arg("name"),
        "Returns an index number for a colormap given a valid string name. Returns -1 if name is invalid");

    m.def("push_colormap",
        nb::overload_cast<ImPlot3DColormap>(ImPlot3D::PushColormap),
        nb::arg("cmap"),
        " Temporarily switch to one of the built-in (i.e. ImPlot3DColormap_XXX) or user-added colormaps (i.e. a return value of AddColormap). Don't forget to\n call PopColormap!");

    m.def("push_colormap",
        nb::overload_cast<const char *>(ImPlot3D::PushColormap),
        nb::arg("name"),
        " Push a colormap by string name. Use built-in names such as \"Default\", \"Deep\", \"Jet\", etc. or a string you provided to AddColormap. Don't forget to\n call PopColormap!");

    m.def("pop_colormap",
        ImPlot3D::PopColormap,
        nb::arg("count") = 1,
        "Undo temporary colormap modification(s). Undo multiple pushes at once by increasing count");

    m.def("next_colormap_color",
        ImPlot3D::NextColormapColor, " Returns the next color from the current colormap and advances the colormap for the current plot\n Can also be used with no return value to skip colors if desired. You need to call it between Begin/EndPlot!");

    m.def("get_colormap_size",
        [](const std::optional<const ImPlot3DColormap> & cmap = std::nullopt) -> int
        {
            auto GetColormapSize_adapt_mutable_param_with_default_value = [](const std::optional<const ImPlot3DColormap> & cmap = std::nullopt) -> int
            {

                const ImPlot3DColormap& cmap_or_default = [&]() -> const ImPlot3DColormap {
                    if (cmap.has_value())
                        return cmap.value();
                    else
                        return IMPLOT3D_AUTO;
                }();

                auto lambda_result = ImPlot3D::GetColormapSize(cmap_or_default);
                return lambda_result;
            };

            return GetColormapSize_adapt_mutable_param_with_default_value(cmap);
        },
        nb::arg("cmap").none() = nb::none(),
        " Returns the size of a colormap\n\n\nPython bindings defaults:\n    If cmap is None, then its default value will be: IMPLOT3D_AUTO");

    m.def("get_colormap_color",
        [](int idx, const std::optional<const ImPlot3DColormap> & cmap = std::nullopt) -> ImVec4
        {
            auto GetColormapColor_adapt_mutable_param_with_default_value = [](int idx, const std::optional<const ImPlot3DColormap> & cmap = std::nullopt) -> ImVec4
            {

                const ImPlot3DColormap& cmap_or_default = [&]() -> const ImPlot3DColormap {
                    if (cmap.has_value())
                        return cmap.value();
                    else
                        return IMPLOT3D_AUTO;
                }();

                auto lambda_result = ImPlot3D::GetColormapColor(idx, cmap_or_default);
                return lambda_result;
            };

            return GetColormapColor_adapt_mutable_param_with_default_value(idx, cmap);
        },
        nb::arg("idx"), nb::arg("cmap").none() = nb::none(),
        " Returns a color from a colormap given an index >= 0 (modulo will be performed)\n\n\nPython bindings defaults:\n    If cmap is None, then its default value will be: IMPLOT3D_AUTO");

    m.def("sample_colormap",
        [](float t, const std::optional<const ImPlot3DColormap> & cmap = std::nullopt) -> ImVec4
        {
            auto SampleColormap_adapt_mutable_param_with_default_value = [](float t, const std::optional<const ImPlot3DColormap> & cmap = std::nullopt) -> ImVec4
            {

                const ImPlot3DColormap& cmap_or_default = [&]() -> const ImPlot3DColormap {
                    if (cmap.has_value())
                        return cmap.value();
                    else
                        return IMPLOT3D_AUTO;
                }();

                auto lambda_result = ImPlot3D::SampleColormap(t, cmap_or_default);
                return lambda_result;
            };

            return SampleColormap_adapt_mutable_param_with_default_value(t, cmap);
        },
        nb::arg("t"), nb::arg("cmap").none() = nb::none(),
        " Sample a color from the current colormap given t between 0 and 1\n\n\nPython bindings defaults:\n    If cmap is None, then its default value will be: IMPLOT3D_AUTO");

    m.def("show_demo_window",
        [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
        {
            auto ShowDemoWindow_adapt_modifiable_immutable_to_return = [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
            {
                bool * p_open_adapt_modifiable = nullptr;
                if (p_open.has_value())
                    p_open_adapt_modifiable = & (*p_open);

                ImPlot3D::ShowDemoWindow(p_open_adapt_modifiable);
                return p_open;
            };

            return ShowDemoWindow_adapt_modifiable_immutable_to_return(p_open);
        },
        nb::arg("p_open").none() = nb::none(),
        "Shows the ImPlot3D demo window");

    m.def("show_all_demos",
        ImPlot3D::ShowAllDemos);

    m.def("show_demo_window_maybe_docked",
        [](bool create_window, std::optional<bool> p_open = std::nullopt, ImGuiWindowFlags initial_extra_flags = 0, const std::optional<const ImVec2> & window_pos = std::nullopt, const std::optional<const ImVec2> & window_size = std::nullopt) -> std::optional<bool>
        {
            auto ShowDemoWindow_MaybeDocked_adapt_mutable_param_with_default_value = [](bool create_window, bool * p_open = NULL, ImGuiWindowFlags initial_extra_flags = 0, const std::optional<const ImVec2> & window_pos = std::nullopt, const std::optional<const ImVec2> & window_size = std::nullopt)
            {

                const ImVec2& window_pos_or_default = [&]() -> const ImVec2 {
                    if (window_pos.has_value())
                        return window_pos.value();
                    else
                        return ImVec2(0, 0);
                }();

                const ImVec2& window_size_or_default = [&]() -> const ImVec2 {
                    if (window_size.has_value())
                        return window_size.value();
                    else
                        return ImVec2(0, 0);
                }();

                ImPlot3D::ShowDemoWindow_MaybeDocked(create_window, p_open, initial_extra_flags, window_pos_or_default, window_size_or_default);
            };
            auto ShowDemoWindow_MaybeDocked_adapt_modifiable_immutable_to_return = [&ShowDemoWindow_MaybeDocked_adapt_mutable_param_with_default_value](bool create_window, std::optional<bool> p_open = std::nullopt, ImGuiWindowFlags initial_extra_flags = 0, const std::optional<const ImVec2> & window_pos = std::nullopt, const std::optional<const ImVec2> & window_size = std::nullopt) -> std::optional<bool>
            {
                bool * p_open_adapt_modifiable = nullptr;
                if (p_open.has_value())
                    p_open_adapt_modifiable = & (*p_open);

                ShowDemoWindow_MaybeDocked_adapt_mutable_param_with_default_value(create_window, p_open_adapt_modifiable, initial_extra_flags, window_pos, window_size);
                return p_open;
            };

            return ShowDemoWindow_MaybeDocked_adapt_modifiable_immutable_to_return(create_window, p_open, initial_extra_flags, window_pos, window_size);
        },
        nb::arg("create_window"), nb::arg("p_open").none() = nb::none(), nb::arg("initial_extra_flags") = 0, nb::arg("window_pos").none() = nb::none(), nb::arg("window_size").none() = nb::none(),
        "Python bindings defaults:\n    If any of the params below is None, then its default value below will be used:\n        * window_pos: ImVec2(0, 0)\n        * window_size: ImVec2(0, 0)");

    m.def("show_style_editor",
        ImPlot3D::ShowStyleEditor,
        nb::arg("ref") = nb::none(),
        "Shows ImPlot3D style editor block (not a window)");

    m.def("show_style_selector",
        ImPlot3D::ShowStyleSelector,
        nb::arg("label"),
        "Shows ImPlot3D style selector and returns True if selection is changed (not a window)");

    m.def("show_colormap_selector",
        ImPlot3D::ShowColormapSelector,
        nb::arg("label"),
        "Shows ImPlot3D colormap selector and returns True if selection is changed (not a window)");

    m.def("show_metrics_window",
        [](std::optional<bool> p_popen = std::nullopt) -> std::optional<bool>
        {
            auto ShowMetricsWindow_adapt_modifiable_immutable_to_return = [](std::optional<bool> p_popen = std::nullopt) -> std::optional<bool>
            {
                bool * p_popen_adapt_modifiable = nullptr;
                if (p_popen.has_value())
                    p_popen_adapt_modifiable = & (*p_popen);

                ImPlot3D::ShowMetricsWindow(p_popen_adapt_modifiable);
                return p_popen;
            };

            return ShowMetricsWindow_adapt_modifiable_immutable_to_return(p_popen);
        },
        nb::arg("p_popen").none() = nb::none(),
        "Shows ImPlot3D metrics/debug information window.");

    m.def("show_about_window",
        [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
        {
            auto ShowAboutWindow_adapt_modifiable_immutable_to_return = [](std::optional<bool> p_open = std::nullopt) -> std::optional<bool>
            {
                bool * p_open_adapt_modifiable = nullptr;
                if (p_open.has_value())
                    p_open_adapt_modifiable = & (*p_open);

                ImPlot3D::ShowAboutWindow(p_open_adapt_modifiable);
                return p_open;
            };

            return ShowAboutWindow_adapt_modifiable_immutable_to_return(p_open);
        },
        nb::arg("p_open").none() = nb::none(),
        "Shows ImPlot3D about window.");


    auto pyClassImPlot3DPoint =
        nb::class_<ImPlot3DPoint>
            (m, "Point", "ImPlot3DPoint: 3D vector to store points in 3D space")
        .def_rw("x", &ImPlot3DPoint::x, "Coordinates")
        .def_rw("y", &ImPlot3DPoint::y, "Coordinates")
        .def_rw("z", &ImPlot3DPoint::z, "Coordinates")
        .def(nb::init<>())
        .def(nb::init<double, double, double>(),
            nb::arg("_x"), nb::arg("_y"), nb::arg("_z"))
        .def("__getitem__",
            nb::overload_cast<size_t>(&ImPlot3DPoint::operator[]),
            nb::arg("idx"),
            "(private API)",
            nb::rv_policy::reference)
        .def("__getitem__",
            nb::overload_cast<size_t>(&ImPlot3DPoint::operator[], nb::const_),
            nb::arg("idx"),
            "(private API)")
        .def("__mul__",
            nb::overload_cast<double>(&ImPlot3DPoint::operator*, nb::const_), nb::arg("rhs"))
        .def("__truediv__",
            nb::overload_cast<double>(&ImPlot3DPoint::operator/, nb::const_), nb::arg("rhs"))
        .def("__add__",
            &ImPlot3DPoint::operator+, nb::arg("rhs"))
        .def("__sub__",
            nb::overload_cast<const ImPlot3DPoint &>(&ImPlot3DPoint::operator-, nb::const_), nb::arg("rhs"))
        .def("__mul__",
            nb::overload_cast<const ImPlot3DPoint &>(&ImPlot3DPoint::operator*, nb::const_), nb::arg("rhs"))
        .def("__truediv__",
            nb::overload_cast<const ImPlot3DPoint &>(&ImPlot3DPoint::operator/, nb::const_), nb::arg("rhs"))
        .def("__neg__",
            [](ImPlot3DPoint & self) { return self.operator-(); }, "Unary operator")
        .def("__imul__",
            nb::overload_cast<double>(&ImPlot3DPoint::operator*=),
            nb::arg("rhs"),
            nb::rv_policy::reference)
        .def("__itruediv__",
            nb::overload_cast<double>(&ImPlot3DPoint::operator/=),
            nb::arg("rhs"),
            nb::rv_policy::reference)
        .def("__iadd__",
            &ImPlot3DPoint::operator+=,
            nb::arg("rhs"),
            nb::rv_policy::reference)
        .def("__isub__",
            &ImPlot3DPoint::operator-=,
            nb::arg("rhs"),
            nb::rv_policy::reference)
        .def("__imul__",
            nb::overload_cast<const ImPlot3DPoint &>(&ImPlot3DPoint::operator*=),
            nb::arg("rhs"),
            nb::rv_policy::reference)
        .def("__itruediv__",
            nb::overload_cast<const ImPlot3DPoint &>(&ImPlot3DPoint::operator/=),
            nb::arg("rhs"),
            nb::rv_policy::reference)
        .def("__eq__",
            &ImPlot3DPoint::operator==, nb::arg("rhs"))
        .def("__ne__",
            &ImPlot3DPoint::operator!=, nb::arg("rhs"))
        .def("dot",
            &ImPlot3DPoint::Dot,
            nb::arg("rhs"),
            "Dot product")
        .def("cross",
            &ImPlot3DPoint::Cross,
            nb::arg("rhs"),
            "Cross product")
        .def("length",
            &ImPlot3DPoint::Length, "Get vector length")
        .def("length_squared",
            &ImPlot3DPoint::LengthSquared, "Get vector squared length")
        .def("normalize",
            &ImPlot3DPoint::Normalize, "Normalize to unit length")
        .def("normalized",
            &ImPlot3DPoint::Normalized, "Return vector normalized to unit length")
        .def("is_nan",
            &ImPlot3DPoint::IsNaN, "Check if the point is NaN")
        ;


    auto pyClassImPlot3DRay =
        nb::class_<ImPlot3DRay>
            (m, "Ray", "ImPlot3DRay: Represents a ray in 3D space with an origin and direction")
        .def("__init__", [](ImPlot3DRay * self, const std::optional<const ImPlot3DPoint> & Origin = std::nullopt, const std::optional<const ImPlot3DPoint> & Direction = std::nullopt)
        {
            new (self) ImPlot3DRay();  // placement new
            auto r_ctor_ = self;
            if (Origin.has_value())
                r_ctor_->Origin = Origin.value();
            else
                r_ctor_->Origin = ImPlot3DPoint();
            if (Direction.has_value())
                r_ctor_->Direction = Direction.value();
            else
                r_ctor_->Direction = ImPlot3DPoint();
        },
        nb::arg("origin").none() = nb::none(), nb::arg("direction").none() = nb::none()
        )
        .def_rw("origin", &ImPlot3DRay::Origin, "Ray origin point")
        .def_rw("direction", &ImPlot3DRay::Direction, "Ray direction (not necessarily normalized)")
        ;


    auto pyClassImPlot3DPlane =
        nb::class_<ImPlot3DPlane>
            (m, "Plane", "ImPlot3DPlane: Represents a plane in 3D space defined by a point and normal vector")
        .def("__init__", [](ImPlot3DPlane * self, const std::optional<const ImPlot3DPoint> & Point = std::nullopt, const std::optional<const ImPlot3DPoint> & Normal = std::nullopt)
        {
            new (self) ImPlot3DPlane();  // placement new
            auto r_ctor_ = self;
            if (Point.has_value())
                r_ctor_->Point = Point.value();
            else
                r_ctor_->Point = ImPlot3DPoint();
            if (Normal.has_value())
                r_ctor_->Normal = Normal.value();
            else
                r_ctor_->Normal = ImPlot3DPoint();
        },
        nb::arg("point").none() = nb::none(), nb::arg("normal").none() = nb::none()
        )
        .def_rw("point", &ImPlot3DPlane::Point, "A point on the plane")
        .def_rw("normal", &ImPlot3DPlane::Normal, "Plane normal vector")
        ;


    auto pyClassImPlot3DBox =
        nb::class_<ImPlot3DBox>
            (m, "Box", "ImPlot3DBox: Axis-aligned bounding box in 3D space")
        .def_rw("min", &ImPlot3DBox::Min, "Minimum corner of the box")
        .def_rw("max", &ImPlot3DBox::Max, "Maximum corner of the box")
        .def(nb::init<>(),
            "Default constructor")
        .def(nb::init<const ImPlot3DPoint &, const ImPlot3DPoint &>(),
            nb::arg("min"), nb::arg("max"),
            "Constructor with two points")
        .def("expand",
            &ImPlot3DBox::Expand,
            nb::arg("point"),
            "Method to expand the box to include a point")
        .def("contains",
            &ImPlot3DBox::Contains,
            nb::arg("point"),
            "Method to check if a point is inside the box")
        .def("clip_line_segment",
            &ImPlot3DBox::ClipLineSegment,
            nb::arg("p0"), nb::arg("p1"), nb::arg("p0_clipped"), nb::arg("p1_clipped"),
            "Method to clip a line segment against the box")
        ;


    auto pyClassImPlot3DRange =
        nb::class_<ImPlot3DRange>
            (m, "Range", "ImPlot3DRange: Represents a 1D range with min and max values")
        .def_rw("min", &ImPlot3DRange::Min, "Minimum value")
        .def_rw("max", &ImPlot3DRange::Max, "Maximum value")
        .def(nb::init<>())
        .def(nb::init<double, double>(),
            nb::arg("min"), nb::arg("max"))
        .def("expand",
            &ImPlot3DRange::Expand,
            nb::arg("value"),
            "Expand range to include value")
        .def("contains",
            &ImPlot3DRange::Contains,
            nb::arg("value"),
            "Check if value is within range")
        .def("size",
            &ImPlot3DRange::Size, "(private API)\n\n Get range size")
        ;


    auto pyClassImPlot3DQuat =
        nb::class_<ImPlot3DQuat>
            (m, "Quat", "ImPlot3DQuat: Quaternion for representing 3D rotations")
        .def_rw("x", &ImPlot3DQuat::x, "Quaternion components")
        .def_rw("y", &ImPlot3DQuat::y, "Quaternion components")
        .def_rw("z", &ImPlot3DQuat::z, "Quaternion components")
        .def_rw("w", &ImPlot3DQuat::w, "Quaternion components")
        .def(nb::init<>())
        .def(nb::init<double, double, double, double>(),
            nb::arg("_x"), nb::arg("_y"), nb::arg("_z"), nb::arg("_w"))
        .def(nb::init<double, const ImPlot3DPoint &>(),
            nb::arg("_angle"), nb::arg("_axis"),
            "Construct quaternion from angle-axis representation (angle in radians)")
        .def_static("from_two_vectors",
            &ImPlot3DQuat::FromTwoVectors,
            nb::arg("v0"), nb::arg("v1"),
            "Create quaternion that rotates from v0 to v1")
        .def_static("from_el_az",
            &ImPlot3DQuat::FromElAz,
            nb::arg("elevation"), nb::arg("azimuth"),
            "Create quaternion from elevation and azimuth angles (in radians)")
        .def("length",
            &ImPlot3DQuat::Length, "Get quaternion length")
        .def("normalized",
            &ImPlot3DQuat::Normalized, "Get normalized quaternion")
        .def("conjugate",
            &ImPlot3DQuat::Conjugate, "Conjugate of the quaternion")
        .def("inverse",
            &ImPlot3DQuat::Inverse, "Inverse of the quaternion")
        .def("__mul__",
            nb::overload_cast<const ImPlot3DQuat &>(&ImPlot3DQuat::operator*, nb::const_),
            nb::arg("rhs"),
            "Quaternion multiplication")
        .def("normalize",
            &ImPlot3DQuat::Normalize,
            "Normalize the quaternion in place",
            nb::rv_policy::reference)
        .def("__mul__",
            nb::overload_cast<const ImPlot3DPoint &>(&ImPlot3DQuat::operator*, nb::const_),
            nb::arg("point"),
            "Rotate a 3D point using the quaternion")
        .def("__eq__",
            &ImPlot3DQuat::operator==, nb::arg("rhs"))
        .def("__ne__",
            &ImPlot3DQuat::operator!=, nb::arg("rhs"))
        .def_static("slerp",
            &ImPlot3DQuat::Slerp,
            nb::arg("q1"), nb::arg("q2"), nb::arg("t"),
            "Spherical linear interpolation between two quaternions (t in [0,1])")
        .def("dot",
            &ImPlot3DQuat::Dot,
            nb::arg("rhs"),
            "Get quaternion dot product")
        ;


    auto pyClassImPlot3DStyle =
        nb::class_<ImPlot3DStyle>
            (m, "Style", "\n(has support for copy.copy)")
        .def_rw("line_weight", &ImPlot3DStyle::LineWeight, "Line weight in pixels")
        .def_rw("marker", &ImPlot3DStyle::Marker, "Default marker type (ImPlot3DMarker_None)")
        .def_rw("marker_size", &ImPlot3DStyle::MarkerSize, "Marker size in pixels (roughly the marker's \"radius\")")
        .def_rw("fill_alpha", &ImPlot3DStyle::FillAlpha, "Alpha modifier applied to plot fills")
        .def_rw("plot_default_size", &ImPlot3DStyle::PlotDefaultSize, "Default size used when ImVec2(0,0) is passed to BeginPlot")
        .def_rw("plot_min_size", &ImPlot3DStyle::PlotMinSize, "Minimum size plot frame can be when shrunk")
        .def_rw("plot_padding", &ImPlot3DStyle::PlotPadding, "Padding between widget frame and plot area")
        .def_rw("label_padding", &ImPlot3DStyle::LabelPadding, "Padding between axes labels, tick labels, and plot edge")
        .def_rw("view_scale_factor", &ImPlot3DStyle::ViewScaleFactor, "Scale factor for 3D view")
        .def_rw("legend_padding", &ImPlot3DStyle::LegendPadding, "Legend padding from plot edges")
        .def_rw("legend_inner_padding", &ImPlot3DStyle::LegendInnerPadding, "Legend inner padding from legend edges")
        .def_rw("legend_spacing", &ImPlot3DStyle::LegendSpacing, "Spacing between legend entries")
        .def("get_color",
            &ImPlot3DStyle::GetColor,
            nb::arg("idx"),
            "(private API)")
        .def("set_color",
            &ImPlot3DStyle::SetColor,
            nb::arg("idx"), nb::arg("col"),
            "(private API)")
        .def_rw("colormap", &ImPlot3DStyle::Colormap, "The current colormap (ImPlot3DColormap_ enum or index from AddColormap)")
        .def(nb::init<>(),
            "Constructor")
        .def(nb::init<const ImPlot3DStyle &>(),
            nb::arg("other"))
        .def("__copy__",  [](const ImPlot3DStyle &self) {
            return ImPlot3DStyle(self);
        })    ;
    // #endif
    ////////////////////    </generated_from:implot3d.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    ///////////////////////////////////////////////////////////////////////////
    // MANUAL BINDINGS BELOW
    ///////////////////////////////////////////////////////////////////////////
    //pyClassImPlotPointPtr = & pyClassImPlotPoint;
    implot3d_binding_manual(m);
}


void implot3d_binding_manual(nb::module_& m)
{
        m.def("setup_axis_ticks",
          [](ImAxis3D axis, double v_min, double v_max, int n_ticks,
              const std::optional<std::vector<std::string>>& labels = std::nullopt, bool keep_default=false)
          {
              if (!labels.has_value() || labels.value().empty())
                  ImPlot3D::SetupAxisTicks(axis, v_min, v_max, n_ticks, nullptr, keep_default);
              else
              {
                  IM_ASSERT(labels.value().size() == n_ticks && "The number of labels should match the number of ticks");
                  std::vector<const char*> label_char;
                  for (std::string const& str : labels.value()){
                      label_char.push_back(str.c_str());
                  }
                  ImPlot3D::SetupAxisTicks(axis, v_min, v_max, n_ticks, label_char.data(), keep_default);
              }
          },
          nb::arg("axis"),
          nb::arg("v_min"),
          nb::arg("v_max"),
          nb::arg("n_ticks"),
          nb::arg("labels") = std::nullopt,
          nb::arg("keep_default") = false,
          "Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true."
    );
    m.def("setup_axis_ticks",
          [](ImAxis3D axis, std::vector<double> values,
              const std::optional<std::vector<std::string>>& labels = std::nullopt, bool keep_default=false)
          {
              int n_ticks = static_cast<int>(values.size());

              if (!labels.has_value() || labels.value().empty())
                  ImPlot3D::SetupAxisTicks(axis, values.data(), n_ticks, nullptr, keep_default);
              else
              {
                  std::vector<const char*> label_char;
                  for (std::string const& str : labels.value()){
                      label_char.push_back(str.c_str());
                  }
                  ImPlot3D::SetupAxisTicks(axis, values.data(), n_ticks, label_char.data(), keep_default);
              }
          },
          nb::arg("axis"),
          nb::arg("values"),
          nb::arg("labels") = std::nullopt,
          nb::arg("keep_default") = false,
          "Sets an axis' ticks and optionally the labels for the next plot. To keep the default ticks, set #keep_default=true."
    );

}
#endif // IMGUI_BUNDLE_WITH_IMPLOT3D
