# Key Features

## Works everywhere

* **Cross-platform in C++ and Python:** Works on Windows, Linux, macOS, iOS, Android, and WebAssembly!

* **Web ready**: Develop full web applications, in C++ via Emscripten; or in Python thanks to ImGui Bundle's integration within Pyodide.

## First class support for Python

* **Python Bindings:** Using Dear ImGui Bundle in Python is extremely easy and productive.

* **Well documented Python bindings and stubs:** The Python bindings stubs reflect the C++ API and documentation, serving as a reference and aiding autocompletion in your IDE. See for example the [stubs for imgui](https://github.com/pthom/imgui_bundle/blob/main/bindings/imgui_bundle/imgui/__init__.pyi), and [for hello_imgui](https://github.com/pthom/imgui_bundle/blob/main/bindings/imgui_bundle/hello_imgui.pyi).

* Use it to create **standalone apps** (on Windows, macOS, and Linux), or to add **interactive UIs to your notebooks**. Deploy your apps **on the web** with ease, using [Pyodide](https://pyodide.org/en/stable/).

## Easy to use & well documented

* The Immediate Mode GUI (IMGUI) paradigm is simple and powerful, letting you focus on the creative aspects of your projects.

* **Easy to use, yet very powerful:** Start your first app in 3 lines.

* **Interactive Demos and Documentation:** Quickly get started with our interactive manual and demos that showcase the capabilities of the pack. Read or copy-paste the source code (Python and C++) directly from the interactive manual!


## Always up-to-date

* **Auto-generated bindings:** Python bindings are automatically generated, ensuring they stay synchronized with C++ APIs.

* **Version tracking:** ImGui Bundle version numbers match Dear ImGui releases (e.g., ImGui Bundle 1.91.x includes Dear ImGui 1.91.x). Updates typically follow within days of upstream releases.

## High performance

* **Fast:** Rendering is done via OpenGL (or any other renderer you choose), through native code.

# Comprehensive Library Integration

Dear ImGui Bundle isn't just ImGui - it's a curated ecosystem with more than 20 integrated libraries, where
Each library is:
- Available in Python and C++ with consistent APIs
- Always up to date, since Python bindings are autogenerated
- Documented with interactive examples

### Core Libraries
* <a href="https://github.com/ocornut/imgui">Dear ImGui</a> : Bloat-free Graphical User interface with minimal dependencies
* <a href="https://github.com/ocornut/imgui_test_engine">ImGui Test Engine</a> : Dear ImGui Tests & Automation Engine
* <a href="https://github.com/pthom/hello_imgui">Hello ImGui</a> : cross-platform Gui apps with the simplicity of a "Hello World" app

### Plotting & Visualization
* <a href="https://github.com/epezent/implot">ImPlot</a> : Immediate Mode Plotting
* <a href="https://github.com/brenocq/implot3d">ImPlot3D</a> : Immediate Mode 3D Plotting
* <a href="https://github.com/pthom/immvision">ImmVision</a> : Immediate image debugger and insights
* <a href="https://github.com/andyborrell/imgui_tex_inspect">imgui_tex_inspect</a> : A texture inspector tool for Dear ImGui

### Text Editing & Markdown
* <a href="https://github.com/BalazsJako/ImGuiColorTextEdit">ImGuiColorTextEdit</a> : Colorizing text editor for ImGui
* <a href="https://github.com/mekhontsev/imgui_md">imgui_md</a> : Markdown renderer for Dear ImGui using MD4C parser

### Tools
* <a href="https://github.com/CedricGuillemet/ImGuizmo">ImGuizmo</a> : Immediate mode 3D gizmo for scene editing
* <a href="https://github.com/thedmd/imgui-node-editor">imgui-node-editor</a> : Node Editor built using Dear ImGui
* <a href="https://github.com/memononen/nanovg">NanoVG</a> : Antialiased 2D vector drawing library on top of OpenGL

### Widgets
* <a href="https://github.com/pthom/ImFileDialog">ImFileDialog</a> : A file dialog library for Dear ImGui
* <a href="https://github.com/samhocevar/portable-file-dialogs">portable-file-dialogs</a> : _OS native_ file dialogs library (C++11, single-header)
* <a href="https://github.com/altschuler/imgui-knobs">imgui-knobs</a> : Knobs widgets for ImGui
* <a href="https://github.com/dalerank/imspinner">imspinner</a> : Set of nice spinners for imgui
* <a href="https://github.com/cmdwtf/imgui_toggle">imgui_toggle</a> : A toggle switch widget for Dear ImGui
* <a href="https://github.com/aiekick/ImCoolBar">ImCoolBar</a> : A Cool bar for Dear ImGui
* <a href="https://github.com/hnOsmium0001/imgui-command-palette">imgui-command-palette</a> : A Sublime Text or VSCode style command palette in ImGui


# Common Questions

## Is It Interesting for Developers?

**Absolutely yes**, for several reasons:

### 1. Joy of Use

The immediate-mode paradigm is genuinely refreshing:

```python
# Your code directly expresses intent
if imgui.button("Click Me"):
    do_something()
```

This is more readable and maintainable than callback spaghetti or complex widget trees.


### 2. Rapid Development

From zero to functional UI is remarkably fast:
- No UI designer needed
- No XML/JSON layouts to maintain
- Changes appear immediately
- Easy to iterate

### 3. Power When You Need It

The framework scales from simple to complex:
- Start with a simple window and buttons
- Add docking and multiple windows
- Incorporate 3D visualization
- Build node-based editors
- Create custom widgets

All while maintaining code clarity.

### 4. Cross-Platform Reality

The cross-platform support actually works:
- Same code runs on Windows, macOS, Linux
- WebAssembly with Python runtime (!!)
- No platform-specific hacks needed
- Mobile support (iOS, Android) is real (in C++)

### 5. Active Community

- Dear ImGui itself has 60k+ stars and is used in AAA games
- Dear ImGui Bundle is based on Dear ImGui and adds comprehensive Python support
- 1k+ stars
- Regular updates and maintenance, keeping up with Dear ImGui upstream


## "Isn't rebuilding the UI every frame slow?"

**No!** Because:
- Widget calls are cheap (just generate drawing commands)
- Actual rendering is GPU-accelerated
- Typical frame times: < 1ms for most UIs
- Easily achieves 60+ FPS even with complex interfaces

## "How's the Python performance?"

**Excellent!** Because:
- Each widget call crosses to C++ once per frame
- Heavy lifting (rendering) is in C++
- Python overhead is < 0.5ms per frame typically
- Real bottleneck is usually your application logic, not the GUI

## "Does it work on the web?"

**Yes, impressively!**
- C++ → Emscripten → WebAssembly
- Python → Pyodide → WebAssembly (!!)
- Full Python runtime in browser
- Native-speed rendering via WebGL
- Check the interactive manual: [traineq.org/ImGuiBundle](https://traineq.org/ImGuiBundle/emscripten/bin/demo_imgui_bundle.html)


# Comparison with Alternatives

The examples below implement the same "fruit picker" app.

:::{figure} ../images/choose_fruit.jpg
:width: 200 
:::

Compare the code styles:

::::{tab-set}

:::{tab-item} ImGui Bundle
**12 lines** – True immediate mode: UI declaration *is* the event handler

```python
from imgui_bundle import imgui, hello_imgui

selected_idx = 0
items = ["Apple", "Banana", "Cherry"]

def gui():
    global selected_idx
    imgui.text("Choose a fruit:")
    _changed, selected_idx = imgui.list_box("##fruits", selected_idx, items)
    imgui.text(f"You selected: {items[selected_idx]}")

hello_imgui.run(gui, window_title="Fruit Picker")
```

**Strengths**: Simplest code, real-time capable, runs on desktop + web (Pyodide), 20+ integrated libraries, full C++ support

**Best for**: Tools, visualization, games, scientific apps
:::

:::{tab-item} Qt
**31 lines** – Retained mode with class hierarchy and signals/slots

```python
from PyQt6.QtWidgets import QApplication, QWidget, QVBoxLayout, QLabel, QListWidget

items = ["Apple", "Banana", "Cherry"]

class FruitPicker(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        self.label = QLabel("Choose a fruit:")
        self.list_widget = QListWidget()
        self.list_widget.addItems(items)
        self.result_label = QLabel(f"You selected: {items[0]}")
        self.list_widget.currentRowChanged.connect(self.on_selection_changed)
        layout.addWidget(self.label)
        layout.addWidget(self.list_widget)
        layout.addWidget(self.result_label)
        self.setLayout(layout)

    def on_selection_changed(self, index):
        self.result_label.setText(f"You selected: {items[index]}")

app = QApplication([])
window = FruitPicker()
window.show()
app.exec()
```

**Qt strengths**: More widgets, Qt Designer, larger ecosystem, rich text, accessibility, native look

**ImGui Bundle strengths**: Simpler code, real-time, lighter weight, scientific viz, easier cross-compilation

**Qt is Best for**: Traditional business apps, enterprise software
:::

:::{tab-item} DearPyGui
**29 lines** – ImGui-based but with retained-mode API and callbacks

```python
import dearpygui.dearpygui as dpg

items = ["Apple", "Banana", "Cherry"]
dpg.create_context()

def on_selection_changed(sender, app_data):
    dpg.set_value("result_label", f"You selected: {app_data}")

with dpg.window(tag="Primary Window", label="Fruit Picker"):
    dpg.add_text("Choose a fruit:")
    dpg.add_listbox(items=items, callback=on_selection_changed, num_items=len(items))
    dpg.add_text("You selected: ", tag="result_label")

dpg.create_viewport(title='Fruit Picker', width=400, height=300)
dpg.setup_dearpygui()
dpg.show_viewport()
dpg.set_primary_window("Primary Window", True)
dpg.start_dearpygui()
dpg.destroy_context()
```

**DearPyGui strengths**: Familiar retained-mode API, large user base, good reputation

**ImGui Bundle strengths**: True immediate mode, more libraries (~20), C++ support, Pyodide web support

**DearPyGui is Best for**: Developers who prefer retained-mode patterns
:::

:::{tab-item} NiceGUI
**15 lines** – Web-based with callbacks

```python
from nicegui import ui

items = ["Apple", "Banana", "Cherry"]

def on_selection_change(e):
    selection_label.text = f"You selected: {e.value}"

ui.label("Choose a fruit:")
dropdown = ui.select(options=items, value=items[0], on_change=on_selection_change)
selection_label = ui.label(f"You selected: {items[0]}")

ui.run(title="Fruit Picker")
```

**NiceGUI strengths**: Web-native, modern UI, easy deployment, familiar web paradigm, reactive

**ImGui Bundle strengths**: Native performance, desktop-native, offline capable, advanced widgets, lower latency

**NiceGUI is Best for**: Web-first apps, internal dashboards, CRUD interfaces
:::

:::{tab-item} Gradio
**26 lines** – Declarative blocks with event wiring

```python
import gradio as gr

items = ["Apple", "Banana", "Cherry"]

def on_selection_change(choice):
    return f"You selected: {choice}"

def on_button_click():
    print("Button clicked")
    return "Button clicked"

with gr.Blocks() as demo:
    gr.Markdown("# Fruit Picker")
    gr.Markdown("Choose a fruit:")

    dropdown = gr.Dropdown(choices=items, value=items[0], label="Choose a fruit")
    output = gr.Textbox(value=f"You selected: {items[0]}", label="Selection", interactive=False)

    button = gr.Button("Click Me")
    button_output = gr.Textbox(label="Button Status", interactive=False)

    # Wire up the events
    dropdown.change(fn=on_selection_change, inputs=dropdown, outputs=output)
    button.click(fn=on_button_click, outputs=button_output)

demo.launch()
```

**Gradio strengths**: Web-native, ML-focused, Hugging Face integration, easy sharing, pre-built media components

**ImGui Bundle strengths**: Native performance, desktop-native, stateful apps, professional tools, flexibility

**Gradio is Best for**: ML model demos, Hugging Face Spaces, sharing with non-technical users
:::

::::

:::{note}
These example are [available here](https://github.com/pthom/imgui_bundle/tree/main/bindings/imgui_bundle/demos_python/sandbox/compare_other_libs)
:::